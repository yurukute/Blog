[{"content":"Bài toán Nguồn: Leetcode, Codewars\nĐọc hiểu: Bạn có một lượng đồng xu với các mệnh giá khác nhau và một tổng số tiền amount. Nhiệm vụ của bạn là tính xem có bao nhiêu cách khác nhau để đổi được số tiền với số xu đã cho. Số lượng xu không giới hạn.\nVí dụ:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Lời giải Với bài này mình sẽ lần lượt đi qua các giai đoạn của nó mà ở mỗi gia đoạn số xu của mình sẽ thay đổi dẫn đến sự thay đổi của kết quả bài toán. Mình có bảng quy hoạch động (ways) sau:\n    0 1 2 3 4 5     {}         {1}         {1,2}         {1,2,5}          Mỗi một ô trên bảng là một bài toán con và chúng đều có sự liên quan tới nhau. Giả sử mình ở ô $ways[1][1]$, khi đấy mình sẽ tìm tổng số cách đổi xu của số tiền $1$ với các xu {1}; nếu mình ở ô $ways[2][3]$ thì mình sẽ tìm tổng số cách đổi xu của số tiền $3$ với các xu {1,2}. Tương tự như vậy, giá trị của ô $ways[i][j]$ sẽ là đáp án của bài toán tổng số cách đổi xu của số tiền $j$ với các xu ở hàng $i$.\nBênh cạnh đó, từng hàng $i$ của bảng lại đại diện cho sự xuất hiện thêm của một đồng xu (được in đậm). Như vậy, hàng $i$ sẽ trả lời cho câu hỏi Liệu mình có dùng đồng xu thứ $i$ không?\nRõ ràng, mình sẽ không dùng đồng xu thứ $i$ nếu $coins[i-1] \u0026gt; j$, ngược lại thì có thể. Vì thế: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; coins[i-1] \u0026gt; j \\\\\nways[i-1][j] + ways[i][j-coins[i-1]], \u0026amp; coins[i-1] \u0026lt;= j \\end{cases} $$ Giải thích một chút ở công thức này nha. Khi mình không dùng đồng xu đang xét thì bài toán quay ngược lại bài toán con ở hàng trên, hàng không có sự xuất hiện của $coins[i-1]$ nên ta chỉ cần lấy kết quả đó. Nhưng nếu dùng thì số tiền lúc này chỉ còn $j - coins[i-1]$ nên mình sẽ truy hồi về ô $ways[i][j-coins[i-1]]$ để lấy số cách của ô này cộng với trường hợp [không dùng].\nĐiền cơ sở Để bắt đầu thì mình cần điền vào hàng 0 và cột 0 (cơ sở của quy hoạch động) trước. Hàng 0 mang ý nghĩa không có đồng xu nào nên ta sẽ không đổi được bất cứ số tiền nào cả, giá trị của các ô này là 0. Cột 0 thì mang ý nghĩ dùng các xu được cho đổi ra\u0026hellip; không, nên các ô của cột sẽ có giá trị là 1 vì cách duy nhất là không làm gì hết.\nĐể thuận tiện khi code, mình sẽ tạo vector 2 chiều với các phần tử là 0. Như vậy, chỉ cần điền cột 0 là được.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ways(coins.size() +1, vector\u0026lt;int\u0026gt; (amount + 1, 0)); for(int i = 0; i \u0026lt;= coins.size(); i++) ways[i][0] = 1;     0 1 2 3 4 5     {} 1 0 0 0 0 0   {1} 1 0 0 0 0 0   {1,2} 1 0 0 0 0 0   {1,2,5} 1 0 0 0 0 0    Việc cần làm tiếp theo chính các ô còn lại. Khi điền hết, ô cuối cùng chính là đáp án của bài toán\nfor(int i = 1; i \u0026lt;= coins.size(); i++) for(int j = 1; j \u0026lt;= amount; j++) ways[i][j] = ways[i-1][j]; if(j \u0026gt;= coins[i-1]) ways[i][j] += ways[i][j - coins[i-1]]; return ways[coins.size()][amount];     0 1 2 3 4 5     {} 1 0 0 0 0 0   {1} 1 1 1 1 1 1   {1,2} 1 1 2 2 3 3   {1,2,5} 1 1 2 2 3 4    Cải tiến Cách làm trên có một nhược điểm là sau khi tính xong dòng thứ $n$ thì việc lưu trữ các dòng từ $1$ đến $n-1$ là dư thừa bởi vì việc tính dòng $n+1$ chỉ phụ thuộc vào dòng $n$. Vì vậy, mình sẽ thay đổi từ mảng 2 chiều thành mảng 1 chiều để lưu kết quả và tự tính chính nó.\nvector\u0026lt;int\u0026gt; ways(amount + 1); ways[0] = 1; for(auto coin : coins) for(int i = 1; i \u0026lt;= amount; i++) if(i \u0026gt;= coin) ways[i] += ways[i - coin]; return ways[amount];    0 1 2 3 4 5     1 1 2 2 3 4    Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/countchange/","summary":"Bài toán Nguồn: Leetcode, Codewars\nĐọc hiểu: Bạn có một lượng đồng xu với các mệnh giá khác nhau và một tổng số tiền amount. Nhiệm vụ của bạn là tính xem có bao nhiêu cách khác nhau để đổi được số tiền với số xu đã cho. Số lượng xu không giới hạn.\nVí dụ:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Lời giải Với bài này mình sẽ lần lượt đi qua các giai đoạn của nó mà ở mỗi gia đoạn số xu của mình sẽ thay đổi dẫn đến sự thay đổi của kết quả bài toán.","title":"Tổng số cách đổi xu"},{"content":"Bài toán Nguồn: Leetcode\nĐọc hiểu Bạn có một lượng đồng xu có các mệnh giá khác nhau và tổng số tiền amount. Nhiệm vụ của bạn là tìm số xu ít cần ít nhất để tạo nên số tiền đó (không giới hạn số đồng xu). Nếu số tiền đó không thể tạo thành thì trả về -1.\nVí dụ:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Lời giải Cách 1: Vét cạn bằng đệ qui Lấy ví dụ như trên, mình có amount là 11. Giả sử đồng 5 là đồng cuối cùng được chọn vậy số xu cần tìm sẽ là số xu cần ít nhất để đổi số tiền còn lại cộng thêm 1. Nói cách khác, $$ coinChange(11) = coinChange(11 - 5) + 1$$ Khi đó, bài toán trở thành tìm số xu cần ít nhất để đổi số tiền còn lại. Đây là một bài toán con. Tương tự với đồng 1 và đồng 2, các bài toán con có thể được thể hiện theo sơ đồ sau graph TD; A((11))--B((10)) A--C((9)) A--D((6)) B--E((9)) B--F((8)) B--G((5)) C--H((8)) C--I((7)) C--J((4)) D--K((5)) D--L((4)) D--M((1))  Mình chỉ vẽ một phần của sơ đồ nhưng có thể thấy, khi xét từng trường hợp như vầy, mình sẽ phải lặp lại việc tính các bài toán con giống nhau (như có 2 số 9 nè, rồi 2 số 8,\u0026hellip;). Chính vì vậy, tụi mình cần một giải pháp thông minh hơn, đó là quy hoạch động.\nCách 2: Quy hoạch động Cũng với ý tưởng trên, lần này mình có một mảng như sau, gọi là dp nhé:\n   0 1 2 3 4 5 6 7 8 9 10 11                    Ô thứ $i$ của mảng lúc này là bài toán con: số xu cần ít nhất để đổi số tiền $i$. Như vậy, đáp án của ô thứ amount chính là đáp án của bài toán. Và tất nhiên, đáp án đấy sẽ được tính từ các ô trước đó nên mình có thể tận dụng các đáp số đã tính sẵn mà không cần tính lại như cách trên ^w^.\nĐể bắt đầu, mình cần điền trước vào mảng như thế này:\n   0 1 2 3 4 5 6 7 8 9 10 11     0 12 12 12 12 12 12 12 12 12 12 12    Với mỗi ô, mình sẽ xét từng xu một xem nó có lớn hơn số tiền mình đang xét hay không? Nếu không có nghĩa là mình có thể dùng đồng xu và đó giá trị của ô đó sẽ là $$dp[i] = min(dp[i-coin] + 1,dp[i])$$ Giả sử $i = 1$, vậy $dp[1] = min(0+1, 12)$. Tính lần lượt như vậy, cuối cùng mảng của mình trở thành:\n   0 1 2 3 4 5 6 7 8 9 10 11     0 1 1 2 2 1 2 2 3 3 2 3    Ô 11 có giá trị bằng 3, cũng tức là đáp án của bài toán ví dụ. Từ đấy, mình có đoạn code thế này:\nvector\u0026lt;int\u0026gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) for(int coin : coins) if(coin \u0026lt;= i \u0026amp;\u0026amp; dp[i - coin] + 1 \u0026lt; dp[i]) dp[i] = dp[i - coin] + 1; return dp[amount]; Ý tưởng là vậy. Nhưng thực tế là nạp cái code này lên sẽ wrong answer ngay, vì cái tội đọc không kỹ đề \u0026gt;D\u0026lt;. Trên đề có bảo rằng\n Nếu số tiền đó không thể tạo thành thì trả về -1.\n Vậy đấy, nên là cần phải chỉnh dòng return lại 1 tí mới qua được UwU.\nreturn (dp[amount] \u0026lt;= amount ? dp[amount] : -1); Cảm ơn bạn vì đã đọc.\nBài viết liên quan Tổng số cách đổi xu\nNhập môn quy hoạch động (VNOI)\n","permalink":"https://yurukute.github.io/Blog/post/coinchange/","summary":"Bài toán Nguồn: Leetcode\nĐọc hiểu Bạn có một lượng đồng xu có các mệnh giá khác nhau và tổng số tiền amount. Nhiệm vụ của bạn là tìm số xu ít cần ít nhất để tạo nên số tiền đó (không giới hạn số đồng xu). Nếu số tiền đó không thể tạo thành thì trả về -1.\nVí dụ:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Lời giải Cách 1: Vét cạn bằng đệ qui Lấy ví dụ như trên, mình có amount là 11.","title":"Số xu cần ít nhất để đổi một số tiền"},{"content":"Sơ lược    Phép thao tác trên bit Kí hiệu Mô tả      AND \u0026amp; Cả hai bit là 1, trả về 1. Ngược lại trả về 0.   OR \\ Một trong hai bit là 1, trả về 1. Ngược lại trả về 0.   XOR ^ Hai bit khác nhau trả về 1. Ngược lại trả về 0.   NOT ~ Đảo bit, 0 thành 1, 1 thành 0.    Dịch trái - Shift left \u0026lt;\u0026lt; Dịch tất cả các bit sang trái.    Dịch phải - Right left \u0026gt;\u0026gt; Dịch tất cả các bit sang phải.     Ứng dụng Số nguyên Thay đổi bit // Đưa bit thứ n thành 1 x |= (1 \u0026lt;\u0026lt; n); //Đưa bit 0 ngoài cùng thành 1 x |= (x+1); //Đưa bit thứ n về 0 x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Đưa bit 1 ngoài cùng về 0 x \u0026amp;= (x-1); //Đảo bit thứ n x ^= (1 \u0026lt;\u0026lt; n); //Lấy ra bit thứ n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Hoán đổi 2 bit cạnh nhau ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Nhân / Chia x với $2^n$ x \u0026lt;\u0026lt; n //nhân x \u0026gt;\u0026gt; n //chia Làm tròn lên lũy thừa cơ số 2 x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Làm tròn xuống lũy thừa cơ số 2 x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //vẫn là đoạn code trên nhưng thêm dòng này Lấy phần nguyên của x x \u0026gt;\u0026gt; 0; 6.723 \u0026gt;\u0026gt; 0; //6 Đảo dấu x x = ~x + 1; // hoặc x = (x ^ -1) + 1; // x = -x Giá trị tuyệt đối của x int abs = (x ^ (x \u0026gt;\u0026gt; 31)) - (x \u0026gt;\u0026gt; 31); Ước lũy thừa cơ số 2 lớn nhất của x x \u0026amp; (-x); Giá trị nguyên nhỏ nhất / lớn nhất int minInt = 1 \u0026lt;\u0026lt; 31; int minInt = 1 \u0026lt;\u0026lt; -1; int maxInt = ~(1 \u0026lt;\u0026lt; 31); int maxInt = (1 \u0026lt;\u0026lt; 31) - 1; int maxInt = (1 \u0026lt;\u0026lt; -1) - 1; int maxInt = -1u \u0026gt;\u0026gt; 1; int maxLong = ((long)1 \u0026lt;\u0026lt; 127) -1; Số nhỏ nhất / lớn nhất giữa 2 số //Cách 1 int min = a \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); int max = b \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); //Cách 2 int min = (b ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); int max = (a ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); Trung bình cộng 2 số int avg = (x + y) \u0026gt;\u0026gt; 1; int avg = ((x ^ y) \u0026gt;\u0026gt; 1) + (x \u0026amp; y); Hoán đổi giá trị 2 biến //Cách 1 a ^= b; b ^= a; a ^= b; //Cách 2 a = a ^ b ^ (b = a) Gõ nhanh điều kiện if Trong một số trường hợp, ta sẽ có đoạn code tựa tựa vầy:\nif(x == a) x = b; //hoặc if(x == b) x = a; Tương tự, ta đưa đoạn code về dòng sau với phép XOR:\nx ^= a ^ b; Kiểm tra   giá trị của bit thứ n   x \u0026amp; (1 \u0026lt;\u0026lt; n)   x là số lẻ   (x \u0026amp; 1) == 1;   x là lũy thừa cơ số 2   x \u0026gt; 0 \u0026amp;\u0026amp; (x \u0026amp; (x - 1)) == 0;   a = b   (Nhanh hơn 35% trong Javascript)\n(a ^ b) == 0;   2 số a, b cùng dấu   (a ^ b) \u0026gt;= 0; Chuỗi Chuyển kí tự thường thành hoa c \u0026amp; \u0026#39;_\u0026#39; Nếu kí tự được chuyển đã là kí tự hoa thì không thay đổi. Ví dụ:\nchar c; c = \u0026#39;a\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; c = \u0026#39;A\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; Chuyển kí tự hoa thành thường c | \u0026#39; \u0026#39; Nếu kí tự được chuyển đã là kí tự thường thì không thay đổi. Ví dụ:\nchar c; c = \u0026#39;A\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; Đảo ngược kiểu kí tự c ^ \u0026#39; \u0026#39; Ví dụ:\nchar c; c = \u0026#39;A\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;A\u0026#39; Vị trí của kí tự trong bảng chữ cái //Đối với chữ thường c ^ \u0026#39;`\u0026#39; //Đối với chữ hoa c ^ \u0026#39;@\u0026#39; //Không phân biệt c \u0026amp; \u0026#34;\\x1F\u0026#34; Nhảm nhí khác Dùng XOR để mã hóa một chuỗi #include\u0026lt;iostream\u0026gt;#define key 5  int main(){ std::string s; std::cin \u0026gt;\u0026gt; s; //Mã hóa  for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; //Giải mã  for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; } Input: Hello Output: M`iij Hello Đổi hệ màu từ R5G5B5 sang R8G8B8 R8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) G8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) B8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) Viết xong cái này thì mình cũng sắp lú rồi, cảm ơn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/bitwise/","summary":"Sơ lược    Phép thao tác trên bit Kí hiệu Mô tả      AND \u0026amp; Cả hai bit là 1, trả về 1. Ngược lại trả về 0.   OR \\ Một trong hai bit là 1, trả về 1. Ngược lại trả về 0.   XOR ^ Hai bit khác nhau trả về 1. Ngược lại trả về 0.   NOT ~ Đảo bit, 0 thành 1, 1 thành 0.","title":"Ứng dụng của các phép thao tác bit"},{"content":"Bài toán Nguồn: Codewars\nCho một số $n$ được nhập vào, việc của tụi mình là phân tích giai thừa của nó ra thừa số nguyên tố. Ví dụ:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Có 1 lưu ý nho nhỏ là giá trị của $n$ có thể lên tới 4000, tất nhiên, 4000! sẽ trở thành 1 con số không hề nhỏ, nó có hơn 12000 chữ số lận á! ∑(O_O;)\nLời giải Ý tưởng Theo định nghĩa, giai thừa của $n$, kí hiệu là $n!$, là tích của $n$ số dương đầu tiên với nhau:\n$$12! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12$$\nNhư vậy, phân tích $n!$ cũng đồng nghĩa với việc phân tích từng thừa số của $n!$ rồi nhân các kết quả lại với nhau. Ví dụ: với $n = 12$ mình có bảng phân tích ứng với từng thừa số sau:\n   12! 2 3 4 5 6 7 8 9 10 11 12     decomp $2$ $3$ $2^2$ $5$ $2\\times3$ $7$ $2^3$ $3^2$ $2\\times5$ $11$ $2^2\\times3$    Sau khi nhân các kết quả lại, mình được kết quả cuối cùng là tích thừa số nguyên tố của $n!$ mà mình cần tìm $$2\\times3\\times2^2\\times5\\times2\\times3\\times7\\times2^3\\times3^2\\times2\\times5\\times11\\times2^2\\times3 = 2^{10}\\times3^5\\times5^2\\times7\\times11$$\nChương trình Bước đầu tiên, mình khởi tạo 2 mảng một chiêu để lưu tính nguyên tố và giá trị của các thừa số\nbool prime[n+1]; int value[n+1]; prime[0] = prime[1] = false; for(int i = 2; i \u0026lt;= n; i++){ prime[i] = true; value[i] = i; } Thông thường, mình dùng sàng Eratosthene để đánh dấu các số nguyên tố nhưng với một chút thay đổi, mình có thể phân tích một lượt các hợp số là bội của số nguyên tố tìm được. Như vậy sẽ tiết kiệm thời gian hơn so với mình phân tích từng số một rồi mới tổng hợp kết quả.\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ //Lưu ý: j = i+i chứ không còn là i*i  f[j].prime = false; while(f[j].value % i == 0){ f[j].value /= i; power++; } } } } Sau cùng, mình thêm vào vài dòng hỗ trợ cho việc output là có thể submit\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ res += (\u0026#34; * \u0026#34; + std::to_string(i)); int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ prime[j] = false; while(value[j] % i == 0){ value[j] /= i; power++; } } if(power \u0026gt; 1) res += (\u0026#34;^\u0026#34; + std::to_string(power)); } } res.erase(res.begin(), res.begin()+3); return res; Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/factorialdecomp/","summary":"Bài toán Nguồn: Codewars\nCho một số $n$ được nhập vào, việc của tụi mình là phân tích giai thừa của nó ra thừa số nguyên tố. Ví dụ:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Có 1 lưu ý nho nhỏ là giá trị của $n$ có thể lên tới 4000, tất nhiên, 4000! sẽ trở thành 1 con số không hề nhỏ, nó có hơn 12000 chữ số lận á!","title":"Phân tích thừa số nguyên tố của n!"},{"content":"Bài toán Nguồn: Codewars\nĐọc hiểu Cho một số dương $n$ \u0026gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\n Trong đó:  a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra    Ví dụ:\nInput: n = 86240 Output: (2**5)(5)(7**2) Lời giải Thông thường, để phân tích ra thừa số nguyên tố, mỉnh đem chia số đó cho ước nguyên tố nhỏ nhất của nó. Cứ tiếp tục như vậy cho đến khi thương = 1.\nVí dụ: n = 160\n   N I     160 2   80 2   40 2   20 2   10 2   5 5   1     Với ý tưởng trên, mỉnh có đoạn code sau:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } Đối với code, mỉnh không cần phải tìm trước các số nguyên tố mà chỉ cần 1 dòng for từ 2 đến $\\sqrt{n}$ để xét tính chia hết là đủ. Bởi vì thương sẽ chia mãi cho đến khi không thể chia hết, đồng nghĩa với việc đã chia cả các hợp số nên không cần băn khoăn nữa UwU. Bây giờ chỉnh sửa lại một tí cho output là xong\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Cảm ơn bạn vì đã đọc.\nBài viết liên quan: Phân tích thừa số nguyên tố của n!\n","permalink":"https://yurukute.github.io/Blog/post/primesinnumbers/","summary":"Bài toán Nguồn: Codewars\nĐọc hiểu Cho một số dương $n$ \u0026gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\n Trong đó:  a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra    Ví dụ:\nInput: n = 86240 Output: (2**5)(5)(7**2) Lời giải Thông thường, để phân tích ra thừa số nguyên tố, mỉnh đem chia số đó cho ước nguyên tố nhỏ nhất của nó.","title":"Phân tích thừa số nguyên tố"},{"content":"Bài toán Nguồn: Codeforces\nĐọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\\sqrt{x}$ của nó phải là 1 số nguyên tố.\nNói cách khác, $x$ là t-prime nếu nó là bình phương của 1 số nguyên tố.\nTrong bài toán này, mình sẽ kiểm tra 1 dãy $n$ các số $x$ rằng $x_i$ có phải là t-prime hay không.\nVí dụ\nInput: 3 4 5 6 Output: YES NO NO Lời giải Đầu tiên, mình cần tìm tất cả các số nguyên tố từ 2 đến $\\sqrt{x}$ bằng sàng Eratosthene. X giới hạn đến $10^{12}$ nên $\\sqrt{x}$ lớn nhất sẽ là $10^6$.\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } Sau cùng, chỉ cần kiểm tra $\\sqrt{x}$ có phải là số nguyên (không phải số thập phân :v) và là số nguyên tố hay không. Đơn giản phải không nào? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/t-primes/","summary":"Bài toán Nguồn: Codeforces\nĐọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\\sqrt{x}$ của nó phải là 1 số nguyên tố.","title":"T-Primes"},{"content":"Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \u0026quot;(2 12)(3 27)(5 15)\u0026quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:\n Nếu số $i_j$ chia hết cho $p$  $sum$ += $i_j$    Lời giải Liệt kê các số nguyên tố Cách liệt kê nhanh nhất là dùng sàng Eratosthene. Chúng ta sẽ tìm tất cả các số nguyên tố nhỏ hơn giá trị tuyệt đối lớn nhất trong mảng (max). Vì vậy, việc đầu tiên cần làm sau khi nhập mảng là tìm max, lưu lại các số nguyên tố bé hơn max để dùng cho bước xử lí.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Bắt đầu xử lí for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Thế là xong! Ghép lại là có thể submit UwU.\nCảm ơn bạn vì đã đọc\n","permalink":"https://yurukute.github.io/Blog/post/sumbyfactors/","summary":"Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \u0026quot;(2 12)(3 27)(5 15)\u0026quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:","title":"Sum by Factors"},{"content":"Bài toán: Nguồn: Codewars.com\nCho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng. Nếu mảng chỉ có số âm, trả về $0$\nMột mảng rỗng sẽ được xem như có tổng lớn nhất là $0$. Lưu ý rằng mảng rỗng cũng là mảng con/đoạn con hợp lệ.\nLời giải Cách 1: Vét cạn Đây là cách dễ tiếp cận nhất với 2 bước:\n Tìm tổng từng đoạn con {-2}, {1}, {-2, 1} \u0026hellip; So sánh các tổng để tìm ra kết quả lớn nhất.  Tuy nhiên, với độ phức tạp là $O(n^3)$ cách này sẽ không giải quyết được vấn đề khi nó mang 3 nhược điểm rất lớn:\n Làm chậm quá trình xử lí do phải tính quá nhiều. Sẽ tồn tại những phép tính không cần thiết. Các hành động lặp đi lặp lại.  Chính vì vậy, mình cần một giải pháp nhanh và tốt hơn!\nCách 2:  mình gọi $f[i]$ là tổng $i$ phần tử đầu tiên, $f[i]$ được tính như sau:  $f[0] = 0$ $f[i] = f[i-1] + a[i]$   Như vậy, tổng các phần tử từ $i$ đến $j$ là: $f[j] – f[i-1]$  Với cách này, mình sẽ tính được $f[i]$ mà không phải lặp lại việc tính toán vì mình đã tính trước ở $f[i-1]$ =\u0026gt; Không mắc nhược điểm thứ 3 của cách 1 (UwU). Vậy là giảm độ phức tạp xuống còn $O(n^2)$. Nhưng mà, bài toán này coàn có một cách giải với độ phức tạp $O(n)$ OwO)/\nCách 3: Với ý tưởng của cách 2, mình thêm một biến sum để lưu tổng đang tính. Khi duyệt mảng, mình sẽ đứng trước 2 lựa chọn: Thêm phần tử đang xét vào đoạn hay hắt đầu một đoạn con mới. Như vậy mình cần so sánh xem tổng hiện tại (sum) cộng thêm phần tử arr[i] đang xét liệu có lớn hơn phần tử đó hay không. Nói cách khác mình lấy max(sum + a[i], a[i]) -\u0026gt; Đây cũng chính là kết quả cần tìm.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/maxsubarraysum/","summary":"Bài toán: Nguồn: Codewars.com\nCho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng.","title":"Đoạn Con Có Tổng Lớn Nhất"}]