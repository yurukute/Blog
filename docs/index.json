[{"content":"Bài toán Nguồn: Codewars\nĐọc hiểu Cho một số dương $n$ \u0026gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\n Trong đó:  a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra    Ví dụ:\nInput: n = 86240 Output: (2**5)(5)(7**2) Lời giải Thông thường, để phân tích ra thừa số nguyên tố, ta đem chia số đó cho ước nguyên tố nhỏ nhất của nó. Cứ tiếp tục như vậy cho đến khi thương = 1.\nVí dụ: n = 160\n   N I     160 2   80 2   40 2   20 2   10 2   5 5   1     Với ý tưởng trên, ta có đoạn code sau:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } Đối với code, ta không cần phải tìm trước các số nguyên tố mà chỉ cần 1 dòng for từ 2 đến $\\sqrt{n}$ để xét tính chia hết là đủ. Bởi vì thương sẽ chia mãi cho đến khi không thể chia hết, đồng nghĩa với việc đã chia cả các hợp số nên không cần băn khoăn nữa UwU. Bây giờ chỉnh sửa lại một tí cho output là xong\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Cảm ơn bạn vì đã đọc. ","permalink":"https://yurukute.github.io/Blog/post/primesinnumbers/","summary":"Bài toán Nguồn: Codewars\nĐọc hiểu Cho một số dương $n$ \u0026gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\n Trong đó:  a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra    Ví dụ:\nInput: n = 86240 Output: (2**5)(5)(7**2) Lời giải Thông thường, để phân tích ra thừa số nguyên tố, ta đem chia số đó cho ước nguyên tố nhỏ nhất của nó.","title":"Phân tích thừa số nguyên tố"},{"content":"Bài toán Nguồn: Codeforces\nĐọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\\sqrt{x}$ của nó phải là 1 số nguyên tố.\nNói cách khác, $x$ là t-prime nếu nó là bình phương của 1 số nguyên tố.\nTrong bài toán này, ta sẽ kiểm tra 1 dãy $n$ các số $x$ rằng $x_i$ có phải là t-prime hay không.\nVí dụ\nInput: 3 4 5 6 Output: YES NO NO Lời giải Đầu tiên, ta cần tìm tất cả các số nguyên tố từ 2 đến $\\sqrt{x}$ bằng sàng Eratosthene. X giới hạn đến $10^{12}$ nên $\\sqrt{x}$ lớn nhất sẽ là $10^6$.\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } Sau cùng, chỉ cần kiểm tra $\\sqrt{x}$ có phải là số nguyên (không phải số thập phân :v) và là số nguyên tố hay không. Đơn giản phải không nào? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Cảm ơn bạn vì đã đọc. ","permalink":"https://yurukute.github.io/Blog/post/t-primes/","summary":"Bài toán Nguồn: Codeforces\nĐọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\\sqrt{x}$ của nó phải là 1 số nguyên tố.","title":"T-Primes"},{"content":"Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \u0026quot;(2 12)(3 27)(5 15)\u0026quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:\n Nếu số $i_j$ chia hết cho $p$  $sum$ += $i_j$    Lời giải Liệt kê các số nguyên tố Cách liệt kê nhanh nhất là dùng sàng Eratosthene. Chúng ta sẽ tìm tất cả các số nguyên tố nhỏ hơn giá trị tuyệt đối lớn nhất trong mảng (max). Vì vậy, việc đầu tiên cần làm sau khi nhập mảng là tìm max, lưu lại các số nguyên tố bé hơn max để dùng cho bước xử lí.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Bắt đầu xử lí for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Thế là xong! Ghép lại là có thể submit UwU.\nCảm ơn bạn vì đã đọc ","permalink":"https://yurukute.github.io/Blog/post/sumbyfactors/","summary":"Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \u0026quot;(2 12)(3 27)(5 15)\u0026quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:","title":"Sum by Factors"},{"content":"Bài toán: Nguồn: Codewars.com\nCho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng. Nếu mảng chỉ có số âm, trả về $0$\nMột mảng rỗng sẽ được xem như có tổng lớn nhất là $0$. Lưu ý rằng mảng rỗng cũng là mảng con/đoạn con hợp lệ.\nLời giải Cách 1: Vét cạn Đây là cách dễ tiếp cận nhất với 2 bước:\n Tìm tổng từng đoạn con {-2}, {1}, {-2, 1} \u0026hellip; So sánh các tổng để tìm ra kết quả lớn nhất.  Tuy nhiên, với độ phức tạp là $O(n^3)$ cách này sẽ không giải quyết được vấn đề khi nó mang 3 nhược điểm rất lớn:\n Làm chậm quá trình xử lí do phải tính quá nhiều. Sẽ tồn tại những phép tính không cần thiết. Các hành động lặp đi lặp lại.  Chính vì vậy, ta cần một giải pháp nhanh và tốt hơn!\nCách 2:  Ta gọi $f[i]$ là tổng $i$ phần tử đầu tiên, $f[i]$ được tính như sau:  $f[0] = 0$ $f[i] = f[i-1] + a[i]$   Như vậy, tổng các phần tử từ $i$ đến $j$ là: $f[j] – f[i-1]$  Với cách này, ta sẽ tính được $f[i]$ mà không phải lặp lại việc tính toán vì ta đã tính trước ở $f[i-1]$ =\u0026gt; Không mắc nhược điểm thứ 3 của cách 1 (UwU). Vậy là giảm độ phức tạp xuống còn $O(n^2)$. Nhưng mà, bài toán này coàn có một cách giải với độ phức tạp $O(n)$ OwO)/\nCách 3: Với ý tưởng của cách 2, ta thêm một biến sum để lưu tổng đang tính. Khi duyệt mảng, ta sẽ đứng trước 2 lựa chọn: Thêm phần tử đang xét vào đoạn hay hắt đầu một đoạn con mới. Như vậy ta cần so sánh xem tổng hiện tại (sum) cộng thêm phần tử arr[i] đang xét liệu có lớn hơn phần tử đó hay không. Nói cách khác ta lấy max(sum + a[i], a[i]) -\u0026gt; Đây cũng chính là kết quả cần tìm.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Cảm ơn bạn vì đã đọc. ","permalink":"https://yurukute.github.io/Blog/post/maxsubarraysum/","summary":"Bài toán: Nguồn: Codewars.com\nCho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng.","title":"Đoạn Con Có Tổng Lớn Nhất"},{"content":"","permalink":"https://yurukute.github.io/Blog/archive/","summary":"archive","title":"Lưu trữ"},{"content":"","permalink":"https://yurukute.github.io/Blog/search/","summary":"search","title":"Tìm kiếm"}]