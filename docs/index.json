[{"content":"Bài toán Nguồn: Codewars Đọc hiểu Cho một mảng kích thước nxn, trả về các phần tử của mảng từ ngoài vào trong theo chiều kim đồng hồ.\narray = [[1,2,3], [4,5,6], [7,8,9]] snail(array) #=\u0026gt; [1,2,3,6,9,8,7,4,5] Để hiểu rõ hơn, hãy lần lượt xem các số liên tiếp trong mảng tiếp theo:\narray = [[1,2,3], [8,9,4], [7,6,5]] snail(array) #=\u0026gt; [1,2,3,4,5,6,7,8,9] Bức hình sau sẽ thể hiện mọi thức rõ ràng hơn:\nCHÚ Ý: Ý tưởng không phải là sắp xếp các phần tử từ bé đến lớn mà là duyệt mảng 2 chiều theo hình xoắn ốc thuận chiều kim đồng hồ.\nCHÚ Ý 2: Mảng rỗng 0x0 được biểu diễn là một mảng chỉ chứa một mảng rỗng [[]].\nLời giải Mác 4 kyu nhưng bài này lại đơn giản hơn mấy bài khác. Để duyệt được hình xoắn ốc thì mình duyệt lần lượt hàng 0, cột n-1, hàng n-1, cột 1,\u0026hellip; từ ngoài vào trong.\nĐầu tiên là mình cần khai báo các biến sau nè:\nstd::vector\u0026lt;int\u0026gt; res; int row_start = 0; // Hàng trên ngoài cùng int col_start = 0; // Cột trái ngoài cùng int row_end = snail_map.size(); // Hàng dưới ngoài cùng int col_end = row_end; // Cột phải ngoài cùng Bắt đầu từ hàng trên ngoài cùng, để duyệt hàng thì ta tăng chỉ số cột của hàng đó lên:\nfor (int i = col_start; i \u0026lt; col_end; i++) res.push_back(snail_map[row_start][i]); Tương tự với cột phải thì ta tăng chỉ số hàng. Lưu ý là phải bỏ qua phần tử ở góc phải trên cùng (snail_map[row_start][col_end-1]) vì nó đã được duyệt.\nfor (int i = ++row_start; i \u0026lt; row_end; i++) res.push_back(snail_map[i][col_end-1]); Vì là hình xoắn ốc nên khi duyệt hàng dưới phải duyệt theo chiều ngược lại: giảm chỉ số cột thay vì tăng. Và vì phần tử góc phải dưới cùng (snail_map[row_end-1][col_end-1]) đã được duyệt, cột ngoài cùng sẽ được bỏ qua.\nfor (i = (--col_end)-1; i \u0026gt;= col_start; --i) res.push_back(snail_map[row_end-1][i]); Tương tự với cột trái ngoài cùng, giảm chỉ số của hàng để duyệt ngược lên, bỏ qua hàng dưới.\nfor (int i = (--row_end)-1; i \u0026gt;= row_start; --i) res.push_back(snail_map[i][col_start]); Các hành động này được lặp đi lặp lại cho đến khi hết mảng, hay nói cách khác là row_start và row_end, hoặc col_start và col_end, chạy qua nhau (_start $\\geq$ _end). Ngoài ra, cần phải xét đến trường hợp mảng rỗng.\nif(snail_map.empty() || snail_map[0].empty()) return {}; Như vậy, lời giải của bài toán đã hoàn thiện.\n#include\u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; snail(const std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;snail_map){ if(snail_map.empty() || snail_map[0].empty()) return {}; std::vector\u0026lt;int\u0026gt; res; int row_start = 0; // Hàng trên ngoài cùng int col_start = 0; // Cột trái ngoài cùng int row_end = snail_map.size()-1; // Hàng dưới ngoài cùng int col_end = row_end; // Cột phải ngoài cùng while (row_start \u0026lt;= row_end \u0026amp;\u0026amp; col_start \u0026lt;= col_end){ for (int i = col_start; i \u0026lt;= col_end; i++) res.push_back(snail_map[row_start][i]); for (int i = ++row_start; i \u0026lt;= row_end; i++) res.push_back(snail_map[i][col_end]); for (int i = --col_end; i \u0026gt;= col_start; i--) res.push_back(snail_map[row_end][i]); for (int i = row_end; i \u0026gt;= row_start; i--) res.push_back(snail_map[i][col_start]); col_start++; } return res; }; Vẫn là lời giải Nếu bạn là người quen nhìn while thì lời giải có thể viết lại thế này:\nint row = 0, col = 0; while (row_start \u0026lt;= row_end \u0026amp;\u0026amp; col_start \u0026lt;= col_end) { while (col \u0026lt; col_end) res.push_back(snail_map[row][col++]); row_start++; while (row \u0026lt; row_end) res.push_back(snail_map[row++][col]); col_end--; while (col \u0026gt; col_start) res.push_back(snail_map[row][col--]); row_end--; while (row \u0026gt; row_start) res.push_back(snail_map[row--][col]); col_start++; } res.push_back(snail_map[row][col]); // Bổ sung phần tử cuối Hai biến row và col được dùng để đánh dấu hàng và cột đang duyệt, hai biến này chỉ chạy từ 0 đến n-2 và ngược lại. Sở dĩ chỉ chạy đến n-2 là để ở dòng while tiếp theo vẫn có thể tận dụng lại giá trị của row, col mà không duyệt trùng phần tử, nói cách khác, thay vì bỏ qua phần tử đã duyệt trùng thì giờ mình luôn chừa lại một phần tử cuối hàng/cột mỗi lần duyệt. Vì thế, sau khi kết thúc dòng while mình cần bổ sung phần tử cuối cùng vào để ra đáp án hoàn chỉnh.\nCảm ơn bạn vì đã đọc.\nTái bút Hồi bé ngơ ngác thi tin học trẻ cũng gặp một bài xoắn ốc như này, mà nó tên là Thành Cổ Loa cơ. Lạy Chúa chứ lúc đó đọc để chả hiểu gì đâu, nay lướt trúng kata này nhìn lại thì thấy nó đơn giản (hoặc do mình quên cái đề hồi đó rồi (:3 ). Thôi thì đấm kata này coi như mở bát 2024 và ôn kỷ niệm luôn.\n","permalink":"https://yurukute.github.io/Blog/post/snail/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Cho một mảng kích thước nxn, trả về các phần tử của mảng từ ngoài vào trong theo chiều kim đồng hồ.\narray = [[1,2,3], [4,5,6], [7,8,9]] snail(array) #=\u0026gt; [1,2,3,6,9,8,7,4,5] Để hiểu rõ hơn, hãy lần lượt xem các số liên tiếp trong mảng tiếp theo:\narray = [[1,2,3], [8,9,4], [7,6,5]] snail(array) #=\u0026gt; [1,2,3,4,5,6,7,8,9] Bức hình sau sẽ thể hiện mọi thức rõ ràng hơn:","title":"Xoắn ốc"},{"content":"Bài toán Source: Codewars Giới thiệu Bất cứ nhóc Joey nào cũng biết bức ảnh này nghĩa là gì và tại sao nó là một nỗi đau (về mặt tâm lý TvT):\nTrong nhiều trò chơi giải đố ma trận 2D, có một loại điển hình được gọi là \u0026lsquo;ice puzzle\u0026rsquo;:\nBạn cần phải đi từ điểm A sang điểm B Bạn có thể di chuyển theo 1 trong 4 hướng trực giao Một vài ô sẽ có tính trơn: Nếu bạn bước vào ô trơn, bạn sẽ bị trượt trên hướng đang đi cho đến khi gặp một ô không trơn hoặc va chạm vào vật cản/tường. Ví dụ, lời giải cho mê cung trên cùng bên trái của câu đố trên:\nĐọc hiểu Cho một hình chữ nhật kích thước M x N được chuẩn hóa theo dạng sau:\nvar map = \u0026#39;\\ x \\n\\ # \\n\\ E \\n\\ # \\n\\ # \\n\\ S #\u0026#39;; /* Người chơi xuất phát tại điểm bắt đầu và kết thúc khi đi đến ô kết thúc S: ô bắt đầu (trơn, tồn tại duy nhất) E: ô kết thúc (không trơn, tồn tại duy nhất) : ô trơn x: ô không trơn #: vật cản (Bạn khổng thể đi ra khỏi rìa của ma trận, nó đóng vai trò như các bức tường của câu đố.) */ Lời giải nên là tối ưu (số bước di chuyển là tối thiểu) và trả về mảng các hướng:'u', 'd', 'l', 'r' lần lượt là up/down/left/right. Ví dụ với mê cung trên, cần trả về ['u', 'r', 'd', 'l', 'u', 'r']. Nếu có nhiều lời giải với cùng số bước di chuyển, trả về lời giải với quãng đường đi ít nhất. Nếu vẫn bằng nhau, trả về bất cứ lời giải nào.\nThêm vào đó, trả về null cho qua một số mê cung không có lời giải thích hợp.\nLời giải Mê cung đọc vào ở dạng chuỗi, sử dụng đồ thị thì rối với tính chất của mê cung, mình cũng lười đưa nó về ma trận nên để vậy tính luôn. Lấy mê cung sau làm ví dụ:\n\u0026#34; x \\n\u0026#34; \u0026#34; # \\n\u0026#34; \u0026#34; E \\n\u0026#34; \u0026#34; # \\n\u0026#34; \u0026#34; # \\n\u0026#34; \u0026#34;S #\u0026#34; Nếu xem chuỗi mê cung là một ma trận, vậy số cột col của nó là vị trí của '\\n' + 1 và là một ma trận đánh số bắt đầu từ 0.\nDễ thấy, nếu ô hiện tại ở vị trí i thì vị trí của 4 ô liền kề lần lượt là:\nÔ bên trên: i - col Ô bên dưới: i + col Ô bên trái: i - 1 Ô bên phải: i + 1 Như vậy, để tìm được đích đến của một bước di chuyển nào mình dùng vòng lặp như sau:\n#define UP 0 #define DOWN 1 #define LEFT 2 #define RIGHT 3 int next_tile(const std::string \u0026amp;map, int col, int curr, char dir) { int row = (map.length() + 1) / col; while (map[curr] != \u0026#39;E\u0026#39; \u0026amp;\u0026amp; is_valid(curr, dir, col, row)) { int next; switch (dir) { case UP: next = curr - col; break; case DOWN: next = curr + col; break; case LEFT: next = curr - 1; break; default: next = curr + 1; break; } if (map[next] == \u0026#39;#\u0026#39;) return curr; if (map[next] == \u0026#39;x\u0026#39;) return next; curr = next; } return curr; } Hàm is_valid dùng để đảm bảo việc di chuyển không vượt qua khỏi phạm vi mê cung\nbool is_valid(int pos, char dir, int col, int row) { switch (dir) { case UP: return pos \u0026gt;= col; case DOWN: return pos \u0026lt;= col * (row - 1) - 1; case LEFT: return pos % col != 0; } return (pos - col + 2) % col != 0; } Thuật toán chính cho bài này là tìm kiếm theo chiều rộng (tìm kiếm theo chiều sâu vẫn khả thi, nhưng nó không thực sự hiệu quả đối với các map lớn). Mỗi khi xét một ô, xác định đích đến (next) của 4 hướng xung quanh rồi cho vào hàng đợi. Có 2 trường hợp sẽ xảy ra: tồn tại một đường đi khác đến next và ngược lại.\nNếu tồn tại một đường đi khác, next sẽ không được thêm vào hàng đợi mà đường đi đến next sẽ được cập nhật lại sao cho lời giải sau cùng là tối ưu. Khởi tạo mảng precell lưu trữ ô trước đó, mặc định tất cả các ô là -1, hỗ trợ việc truy vết đường đi từ start đến một ô bất kỳ.\nNgoài ra, cần phải lưu ý tránh thêm ô xuất phát vào hàng đợi, gây vô hạn lặp.\nstd::vector\u0026lt;char\u0026gt; ice_maze_solver(const std::string \u0026amp;map) { int col = map.find(\u0026#34;\\n\u0026#34;) + 1, start = map.find(\u0026#34;S\u0026#34;), end = map.find(\u0026#34;E\u0026#34;); bool solvable = false; std::vector\u0026lt;char\u0026gt; solution; std::vector\u0026lt;int\u0026gt; precell(map.length(), -1); std::queue\u0026lt;int\u0026gt; queue; queue.push(start); while (!queue.empty()) { int curr = queue.front(); queue.pop(); if(curr == end){ solvable = true; continue; } for (int i = 0; i \u0026lt; 4; i++) { int next = next_tile(map, col, curr, i); if (next != curr \u0026amp;\u0026amp; next != precell[curr]) { if(precell[next] != -1){ update_path(precell, col, curr, next); } else if (next != start){ precell[next] = curr; queue.push(next); } } } } if (solvable){ while (end != start) { char move; if ((precell[end] - end) % col == 0) move = (precell[end] \u0026gt; end) ? \u0026#39;u\u0026#39; : \u0026#39;d\u0026#39;; else move = (precell[end] \u0026gt; end) ? \u0026#39;l\u0026#39; : \u0026#39;r\u0026#39;; solution.insert(solution.begin(), move); end = precell[end]; } } return solution; } Đường đi được cập nhật thông qua 2 yếu tố:\nSố bước di chuyển Tổng độ dài của đường đi, trong đó: Khoảng cách của 2 ô $i, j$ bất kỳ trên cùng một hàng ngang được tính bằng $|i-j|$ Nếu 2 ô trên cùng hàng dọc: $\\dfrac{|i-j|}{col}$ std::vector\u0026lt;int\u0026gt; get_length( std::vector\u0026lt;int\u0026gt; const \u0026amp;parent, const int col, int curr) { int length = 0; int step = 0; while (parent[curr] != -1) { step++; length += abs(parent[curr] - curr) / ((parent[curr] - curr) % col == 0 ? col : 1); curr = parent[curr]; } return {step, length}; } void update_path(std::vector\u0026lt;int\u0026gt; \u0026amp;parent, const int col, int curr, int next) { auto oldPath = get_length(parent, col, next); auto newPath = get_length(parent, col, curr); newPath[0] += 1; newPath[1] += abs(curr - next) / ((curr - next) % col == 0 ? col : 1); if (newPath \u0026lt; oldPath) { parent[next] = curr; } } Cảm ơn bạn vì đã đọc vì cái lời giải này nó nghiệp dư vô cùng, và mình \u0026ldquo;đấm\u0026rdquo; cái kata này vì nó có liên quan tới pokemon thôi.\n","permalink":"https://yurukute.github.io/Blog/post/warningice/","summary":"Bài toán Source: Codewars Giới thiệu Bất cứ nhóc Joey nào cũng biết bức ảnh này nghĩa là gì và tại sao nó là một nỗi đau (về mặt tâm lý TvT):\nTrong nhiều trò chơi giải đố ma trận 2D, có một loại điển hình được gọi là \u0026lsquo;ice puzzle\u0026rsquo;:\nBạn cần phải đi từ điểm A sang điểm B Bạn có thể di chuyển theo 1 trong 4 hướng trực giao Một vài ô sẽ có tính trơn: Nếu bạn bước vào ô trơn, bạn sẽ bị trượt trên hướng đang đi cho đến khi gặp một ô không trơn hoặc va chạm vào vật cản/tường.","title":"ASCII Games: Cảnh báo: Băng trơn!"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Viết chương trình trả về tổng của 2 số nguyên. Đầu vào là 2 số được biểu diễn dưới dạng chuỗi và kết quả trả về cũng lả chuỗi.\nVí dụ\nadd(\u0026#34;123\u0026#34;, \u0026#34;321\u0026#34;); -\u0026gt; \u0026#34;444\u0026#34; add(\u0026#34;11\u0026#34;, \u0026#34;99\u0026#34;); -\u0026gt; \u0026#34;110\u0026#34; Lời giải Trong số học, phép cộng có thể được thực hiện bằng cách sắp các số hạng theo chiều dọc và cộng lần lượt từng cột bắt đầu từ cột đơn vị (ngoài cùng bên phải). $$ \\begin{aligned} 105 \\\\ +\\quad6\\\\ \\hline 111\\\\ \\end{aligned} $$ Để mô phỏng các bước thực hiện, hai chuỗi số hạng được duyệt song song từ vị trí cuối, lần lượt cộng giá trị nguyên của chữ số tại vị trí đó và thêm vào chuỗi kết quả. Do hai chuỗi có độ dài khác nhau và được căn phải nên vị trí của chữ số được tính bằng length - i với i từ 1 đến length.\nKhởi tạo biến carry = 0 để lưu số \u0026ldquo;nhớ\u0026rdquo; của phép toán, là số hàng chục khi tổng hai số ở cột đang tính vượt quá 9. Phần số nhớ sẽ được cộng vào tổng của hai chữ số ở cột tiếp theo hoặc chuỗi kết quả sau khi tính toán xong các cột.\n#include \u0026lt;string\u0026gt; std::string add(const std::string\u0026amp; a, const std::string\u0026amp; b) { std::string res = \u0026#34;\u0026#34;; int len_a = a.length(), len_b = b.length(), n = std::max(len_a, len_b); int carry = 0; for(int i = 1; i \u0026lt;= n; i++){ if(i \u0026lt;= lenA) carry += a[lenA - i] - \u0026#39;0\u0026#39;; if(i \u0026lt;= lenB) carry += b[lenB - i] - \u0026#39;0\u0026#39;; res.insert(res.begin(), carry % 10 + \u0026#39;0\u0026#39;); carry /= 10; } res.insert(res.begin(), carry + \u0026#39;0\u0026#39;); while(res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.front() == \u0026#39;0\u0026#39;) res.erase(res.begin()); return res; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/addingbignumbers/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Viết chương trình trả về tổng của 2 số nguyên. Đầu vào là 2 số được biểu diễn dưới dạng chuỗi và kết quả trả về cũng lả chuỗi.\nVí dụ\nadd(\u0026#34;123\u0026#34;, \u0026#34;321\u0026#34;); -\u0026gt; \u0026#34;444\u0026#34; add(\u0026#34;11\u0026#34;, \u0026#34;99\u0026#34;); -\u0026gt; \u0026#34;110\u0026#34; Lời giải Trong số học, phép cộng có thể được thực hiện bằng cách sắp các số hạng theo chiều dọc và cộng lần lượt từng cột bắt đầu từ cột đơn vị (ngoài cùng bên phải).","title":"Cộng 2 số lớn"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Một tòa nhà nhiều tầng có thang máy trong đó. Ở mỗi tầng có một hàng người chờ được di chuyển đến tầng họ muốn, được thể hiện bằng một số.\nNhiệm vụ: Đưa tất cả mọi người đến các tầng mà họ muốn đến trong khi tuân thủ các quy luật bên dưới.\nTRƯỚC (Mọi người trong hàng đợi) SAU (Mọi người tại đích đến của họ) +--+ +--+ /----------------| |----------------\\ /----------------| |----------------\\ 10| | | 1,4,3,2 | 10| 10 | | | |----------------| |----------------| |----------------| |----------------| 9| | | 1,10,2 | 9| | | | |----------------| |----------------| |----------------| |----------------| 8| | | | 8| | | | |----------------| |----------------| |----------------| |----------------| 7| | | 3,6,4,5,6 | 7| | | | |----------------| |----------------| |----------------| |----------------| 6| | | | 6| 6,6,6 | | | |----------------| |----------------| |----------------| |----------------| 5| | | | 5| 5,5 | | | |----------------| |----------------| |----------------| |----------------| 4| | | 0,0,0 | 4| 4,4,4 | | | |----------------| |----------------| |----------------| |----------------| 3| | | | 3| 3,3 | | | |----------------| |----------------| |----------------| |----------------| 2| | | 4 | 2| 2,2,2 | | | |----------------| |----------------| |----------------| |----------------| 1| | | 6,5,2 | 1| 1,1 | | | |----------------| |----------------| |----------------| |----------------| G| | | | G| 0,0,0 | | | |====================================| |====================================| Trả về danh sách tất cả các tầng mà thang máy đã dừng lại (theo thứ tự dừng).\nLƯU Ý: Thang máy luôn bắt đầu ở tầng trệt (và mọi người đang chờ ở tầng trệt có thể vào ngay lập tức).\nqueues = { {}, {}, {5,5,5}, {}, {}, {}, {} }; capacity = 5; result = {0, 2, 5, 0}; Quy luật Quy luật của thang máy Thang máy chỉ đi lên hoặc đi xuống!\nMỗi tầng có cả nút UP và DOWN (ngoại trừ tầng trên cùng và tầng trệt chỉ có nút DOWN hoặc UP tương ứng).\nThang máy không bao giờ thay đổi hướng cho đến khi không còn người nào muốn đi lên/xuống theo hướng nó đang di chuyển.\nKhi trống, thang máy sẽ cố gắng trở nên thông minh. Ví dụ,\nNếu nó đang đi lên thì nó có thể tiếp tục đi lên để gom những người ở tầng cao nhất muốn đi xuống. Nếu nó đang đi xuống thì nó có thể tiếp tục đi xuống để gom những người ở tầng thấp nhất muốn đi lên. Thang máy có một sức chứa tối đa.\nKhi được gọi, thang máy vẫn sẽ dừng ngay cả khi nó đã đầy, không ai khác có thể vào thang máy trừ khi có người muốn xuống!\nNếu thang máy trống và không có người chờ, thì thang máy sẽ quay trở lại tầng trệt.\nQuy luật của hàng người Mọi người ở trong \u0026ldquo;hàng đợi\u0026rdquo; đại diện cho thứ tự đến của họ để chờ thang máy.\nTất cả mọi người đều có thể nhấn nút UP/DOWN.\nChỉ những người đi cùng hướng mới có thể vào thang máy.\nVào theo thứ tự \u0026ldquo;hàng đợi\u0026rdquo;, những người không vào cũng không chặn những người đứng sau họ muốn vào.\nNếu một người không thể vào một thang máy đã đầy, họ sẽ nhấn lại nút UP/DOWN sau khi đã khởi hành mà không có họ.\nLời giải Thang máy chỉ quay lại tầng trệt chỉ khi thang máy trống và không có người chờ. Vì thế, cho đến thời điểm đó, thang máy sẽ lặp đi lặp lại chu kỳ như sau:\nĐi lên: Vì thang máy luôn bắt đầu ở tầng trệt nên điều đầu tiên nó làm là đi lên các tầng trên. Đi xuống: Xảy ra sau khi thang đã lên đến tầng trên cùng Tại mỗi tầng $i$ đi qua:\nTrả những người trong thang máy nếu $i$ là tầng họ muốn xuống. bool remove_people(std::vector\u0026lt;int\u0026gt; *lift, int floor){ bool stop = false; for (auto person = lift-\u0026gt;begin(); person != lift-\u0026gt;end(); person++){ if (*person == floor){ lift-\u0026gt;erase(person--); stop = true; } } return stop; } Đưa người vào thang máy nếu số tầng họ muốn đến thuận với chiều đi chuyển của thang máy cho đến khi hết người hoặc thang máy đầy. bool add_people(std::vector\u0026lt;int\u0026gt; *lift, std::vector\u0026lt;int\u0026gt; *people, int floor, int capacity, int direction){ bool stop = false; for(auto person = people-\u0026gt;begin(); person != people-\u0026gt;end(); person++){ if((*person \u0026gt; floor \u0026amp;\u0026amp; direction == UP) || (*person \u0026lt; floor \u0026amp;\u0026amp; direction == DOWN)){ stop = true; if(int(lift-\u0026gt;size()) \u0026lt; capacity){ lift-\u0026gt;push_back(*person); people-\u0026gt;erase(person--); } } } return stop; } Nếu một trong hai hành động trên được thực hiện, lưu $i$ vào mảng kết quả. #include \u0026lt;vector\u0026gt; #define UP 1 #define DOWN 0 bool remove_people(std::vector\u0026lt;int\u0026gt; *lift, int floor){...} bool add_people(std::vector\u0026lt;int\u0026gt; *lift, std::vector\u0026lt;int\u0026gt; *people, int floor, int capacity, int direction){...} std::vector\u0026lt;int\u0026gt; the_lift(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; queues, int capacity) { std::vector\u0026lt;int\u0026gt; res = {0}, lift; int top = queues.size(); bool unfinish = true; while(unfinish){ unfinish = false; for(int floor = 0; floor \u0026lt; top; floor++){ bool stop = remove_people(\u0026amp;lift, floor); stop = add_people(\u0026amp;lift, \u0026amp;queues[floor], floor, capacity, UP) || stop; if(!queues[floor].empty()) unfinish = true; if(stop \u0026amp;\u0026amp; res.back() != floor) res.push_back(floor); } for(int floor = top-1; floor \u0026gt;= 0; floor--){ bool stop = remove_people(\u0026amp;lift, floor); stop = add_people(\u0026amp;lift, \u0026amp;queues[floor], floor, capacity, DOWN) || stop; if(!queues[floor].empty()) unfinish = true; if(stop \u0026amp;\u0026amp; res.back() != floor) res.push_back(floor); } } if(res.back()) res.push_back(0); return res; } ","permalink":"https://yurukute.github.io/Blog/post/thelift/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Một tòa nhà nhiều tầng có thang máy trong đó. Ở mỗi tầng có một hàng người chờ được di chuyển đến tầng họ muốn, được thể hiện bằng một số.\nNhiệm vụ: Đưa tất cả mọi người đến các tầng mà họ muốn đến trong khi tuân thủ các quy luật bên dưới.\nTRƯỚC (Mọi người trong hàng đợi) SAU (Mọi người tại đích đến của họ) +--+ +--+ /----------------| |----------------\\ /----------------| |----------------\\ 10| | | 1,4,3,2 | 10| 10 | | | |----------------| |----------------| |----------------| |----------------| 9| | | 1,10,2 | 9| | | | |----------------| |----------------| |----------------| |----------------| 8| | | | 8| | | | |----------------| |----------------| |----------------| |----------------| 7| | | 3,6,4,5,6 | 7| | | | |----------------| |----------------| |----------------| |----------------| 6| | | | 6| 6,6,6 | | | |----------------| |----------------| |----------------| |----------------| 5| | | | 5| 5,5 | | | |----------------| |----------------| |----------------| |----------------| 4| | | 0,0,0 | 4| 4,4,4 | | | |----------------| |----------------| |----------------| |----------------| 3| | | | 3| 3,3 | | | |----------------| |----------------| |----------------| |----------------| 2| | | 4 | 2| 2,2,2 | | | |----------------| |----------------| |----------------| |----------------| 1| | | 6,5,2 | 1| 1,1 | | | |----------------| |----------------| |----------------| |----------------| G| | | | G| 0,0,0 | | | |====================================| |====================================| Trả về danh sách tất cả các tầng mà thang máy đã dừng lại (theo thứ tự dừng).","title":"Thang máy"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Số Hamming là một số dương có dạng $2^ỉ3^j5^k$ với $i, j, k$ là các số không âm.\nViết chương trình tính số Hamming nhỏ nhất thứ n.\nĐặc biệt:\nSố Hamming đầu tiên là $1 = 2^03^05^0$ Số Hamming thứ hai là $2 = 2^13^05^0$ Số Hamming thứ ba là $3 = 2^03^15^0$ Số Hamming thứ tư là $4 = 2^23^05^0$ Số Hamming thứ năm là $5 = 2^03^05^1$ 20 số Hamming nhỏ nhất đầu tiên được đưa vào trong test mẫu.\nChương trình cần phải tính toán được 5000 (Clojure: 2000, NASM: 13282) số Hamming nhỏ nhất mà không bị timeout.\nLời giải Vét cạn Phương pháp đơn giản nhất chính là lần lượt kiểm tra các số từ $2$ trở đi xem nó có phải số Hamming hay không và tăng biến đếm cho đến khi tìm được số Hamming thứ n. Để kiểm tra một số liệu có phải là số Hamming hay không thì dựa vào các điểm sau:\nSố Hamming là một tích các lũy thừa cơ số 2, 3 và 5. 2, 3 vả 5 là số nguyên tố. Nói cách khác, số Hamming là một số có ước nguyên tố không lớn hơn 5. Mình sẽ thông qua việc phân tích thừa số nguyên tố để kiểm tra và việc phân tích sẽ chỉ dừng ở số 5, nếu phần còn lại của số cần kiểm tra bằng 1 - tức là không còn thừa số nào khác - thì số đó là số Hamming.\n#include \u0026lt;cstdint\u0026gt; int isHamber(uint64_t n){ for(int i = 2; i \u0026lt;= 5; i++) while (n % i == 0) n /= i; return n == 1; } uint64_t hamber(int n){ uint64_t res = 0; int count = 0; while(count \u0026lt; n){ res++; if(isHamber(res)) count++; } return res; } Tuy nhiên, phương pháp này sẽ dẫn đến mất thời gian để chạy chương trình, nhất là khi có một yêu cầu cụ thể rằng:\nChương trình cần phải tính toán được 5000 (Clojure: 2000, NASM: 13282) số Hamming nhỏ nhất mà không bị timeout.\nQuy hoạch động Do đặc điểm là một tích các lũy thừa cơ số 2, 3, và 5, số Hamming có thể được phân tách thành tích của một số Hamming nhỏ hơn với 2, 3, hoặc là 5: $$ 2^ỉ3^j5^k = \\Bigg[ \\begin{array}{1} 2^{i-1}3^j5^k \\times 2 \\\\ 2^i3^{j-1}5^k \\times 3 \\\\ 2^i3^j5^{k-1} \\times 5 \\\\ \\end{array} $$ Như vậy, dãy số Hamming có thể được xây dựng như sau: $$ \\begin{cases} H_1 = 1 \\\\ H_x = min(H_i \\times 2, H_j \\times 3, H_k \\times 5) \\end{cases} $$ với $i, j, k$ là chỉ số của dãy Hamming ($i, j, k \u0026lt; x$). Các chỉ số này được tính từ $1$ và chỉ tăng khi bội của số Hamming ở vị trí tương ứng đã được thêm vào dãy. Ví dụ:\n$H_2 = min(H_1 \\times 2, H_1 \\times 3, H_1 \\times 5) = min(1 \\times 2, 1 \\times 3, 1 \\times 5) = 2$\n$\\Rightarrow$ $i$ tăng lên 1 do tích $H_i \\times 2$ được chọn: $i = 2$.\n$H_3 = min(H_2 \\times 2, H_1 \\times 3, H_1 \\times 5) = min(2 \\times 2, 1 \\times 3, 1 \\times 5) = 3$\n$\\Rightarrow$ $j$ tăng lên 1.\n\u0026hellip;\n$H_6 = min(H_3 \\times 2, H_2 \\times 3, H_2 \\times 5) = min(3 \\times 2, 2 \\times 3, 2 \\times 5) = 6$\n$\\Rightarrow$ $i$ và $j$ tăng lên 1.\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;algorithm\u0026gt; uint64_t hamber(int n){ uint64_t hambers[13282], next2 = 2, next3 = 3, next5 = 5; int i = 0, j = 0, k = 0; hambers[0] = 1; for(int x = 1; x \u0026lt; n; x++){ hambers[x] = std::min(std::min(next2, next3), next5); if(hambers[x] == next2) next2 = hambers[++i]*2; if(hambers[x] == next3) next3 = hambers[++j]*3; if(hambers[x] == next5) next5 = hambers[++k]*5; } return hambers[n-1]; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/hammingnumber/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Số Hamming là một số dương có dạng $2^ỉ3^j5^k$ với $i, j, k$ là các số không âm.\nViết chương trình tính số Hamming nhỏ nhất thứ n.\nĐặc biệt:\nSố Hamming đầu tiên là $1 = 2^03^05^0$ Số Hamming thứ hai là $2 = 2^13^05^0$ Số Hamming thứ ba là $3 = 2^03^15^0$ Số Hamming thứ tư là $4 = 2^23^05^0$ Số Hamming thứ năm là $5 = 2^03^05^1$ 20 số Hamming nhỏ nhất đầu tiên được đưa vào trong test mẫu.","title":"Hamming Number"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Với $n$ là tử số và $d$ là mẫu số, phân số được định nghĩa là tối giản nếu và chỉ nếu $GCD(n,d) = 1$.\nVí dụ, $\\displaystyle\\frac{5}{16}$ là phân số tối giản, trong khi $\\displaystyle\\frac{6}{16}$ không phải vì cả 6 và 16 đều chia hết cho 2 nên phân số rút gọn thành $\\displaystyle\\frac{3}{8}$\nCho một số $d$, hỏi có bao nhiêu phân số thực sự (phân số có tử bé hơn mẫu) tối giản nếu dùng $d$ làm mẫu số?\nVí dụ, cho $d = 15$: có tổng cộng 8 phân số thực sự tối giản mang giá trị từ 0 đến 1 là $$\\displaystyle\\frac{1}{15},\\frac{2}{15},\\frac{4}{15},\\frac{7}{15},\\frac{8}{15},\\frac{11}{15},\\frac{13}{15},\\frac{14}{15}$$\nYêu cầu: xây dựng một hàm tính xem có bao nhiêu phân số thực sự tối giản với mẫu số đã cho:\nproperFractions(1) == 0 properFractions(2) == 1 properFractions(5) == 4 properFractions(15) == 8 properFractions(25) == 20 Và hàm phải xử lí được số lớn.\n(proper là do người ra đề viết nhầm với reduced)\nLời giải Chạy trâu Bài toán có thể vét cạn: với mỗi số $n \\leq d$ tính GCD của chúng đồng thời tăng biến đếm nếu GCD = 1. GCD (hay ước chung lớn nhất) của 2 số được tính bằng giải thuật Euclid.\nlong gcd(long a, long b) { while(b){ int t = a % b; a = b; b = t; } return a; } long properFractions(long d) { int count = 0; for(int n = 1; n \u0026lt; d; n++) if(gcd(n,d) == 1) count++; return count; } Tuy nhiên, đề bài cho biết $d$ có thể là một số lớn nên phương pháp này không khả thi.\nHàm phi Euler Vì bài toán chỉ xét các phân số thực sự ($n \u0026lt; d$) nên bài toán trở thành Tính hàm phi Euler của d.\nTrong lý thuyết số, hàm số Euler của một số nguyên dương $n$ được định nghĩa là số các số nguyên dương nhỏ hơn hoặc bằng $n$ nguyên tố cùng nhau với $n$. Hàm Euler được ký hiệu bởi $\\phi (n)$ hoặc $\\varphi (n)$, do đó hàm được gọi làm hàm phi Euler.\nWikipedia Hàm phi Euler được tính bằng công thức: $$\\begin{aligned} \\phi(n) \u0026amp;= n \\times (1 - \\frac{1}{p_1}) \\times (1 - \\frac{1}{p_2}) \\times\u0026hellip;\\times (1 - \\frac{1}{p_k})\\\\ \u0026amp;= n\\prod_{i=1}^k(1 - \\frac{1}{p_i}) \\end{aligned}$$\ntrong đó, $\\ p_i$ là các thừa số nguyên tố khác nhau của $n$.\nKết hợp giải thuật phân tích thừa số nguyên tố của n với công thức trên, mình có được lời giải cho bài toán:\nlong properFractions(long n) { if(n == 1) return 0; long res = n; for(long i = 2; i*i \u0026lt;= n; i++){ if(n % i == 0){ while (n % i == 0) n /= i; res -= res/i; } } if (n \u0026gt; 1) res -= res/n; return res; } Cảm ơn bạn vì đã đọc\n","permalink":"https://yurukute.github.io/Blog/post/reducedfractions/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Với $n$ là tử số và $d$ là mẫu số, phân số được định nghĩa là tối giản nếu và chỉ nếu $GCD(n,d) = 1$.\nVí dụ, $\\displaystyle\\frac{5}{16}$ là phân số tối giản, trong khi $\\displaystyle\\frac{6}{16}$ không phải vì cả 6 và 16 đều chia hết cho 2 nên phân số rút gọn thành $\\displaystyle\\frac{3}{8}$\nCho một số $d$, hỏi có bao nhiêu phân số thực sự (phân số có tử bé hơn mẫu) tối giản nếu dùng $d$ làm mẫu số?","title":"Số phân số tối giản với mẫu số d"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Trong lý thuyết số, hàm Carmichael của một số nguyên dương $n$, ký hiệu $\\lambda(n)$, là số nguyên dương m nhỏ nhất sao cho $a^m \\equiv 1 \\mod n$ với mọi $a \\leq n$ là các số nguyên tố cùng nhau với n.\nVí dụ $n = 8$. Các số nguyên tố cùng nhau với $8$ không vượt quá $8: 1, 3, 5, 7.$ $$ \\begin{aligned} 1^2 \\equiv 1 \\mod 8 \\\\ 3^2 \\equiv 1 \\mod 8 \\\\ 5^2 \\equiv 1 \\mod 8 \\\\ 7^2 \\equiv 1 \\mod 8 \\\\ \\end{aligned} $$\nVì vậy, $\\lambda(8) = 2$.\nCó 2 cách để tính hàm này:\nVới mỗi số nguyên tố cùng nhau với n không vượt quá n, kiểm tra $a^m \\equiv 1 \\mod n$ với $m$ tăng dần. Cách này không hiệu quả đối với số lớn. Dùng công thức chính xác như hàm phi Euler. Đây là công thức tường minh để tính $\\lambda(n)$ dựa trên phân tích thừa số nguyên tố của n. Ở phương pháp thứ hai, công thức được suy ra từ công thức bcnn của $\\lambda$ và hàm phi:\nCho $p_1,\u0026hellip;,p_n$ là các thừa số nguyên tố của n với các số mũ $w_1,\u0026hellip;,w_n$ của chúng: $$ \\begin{aligned} \\lambda(n) \u0026amp; = \\lambda(p_1^{w_1} \\times p_2^{w_2} \\times \u0026hellip; \\times p_n^{w_n}) \\\\ \\lambda(n) \u0026amp; = lcm(\\lambda(p_1^{w_1}), \\lambda(p_2^{w_2}),\u0026hellip;, \\lambda(p_n^{w_n})) \\\\ \\end{aligned} $$ Đối với mỗi số nguyên tố p, ta có sự liên kết giữa $\\lambda(p^w)$ và hàm phi Euler $\\phi(p^w)$: $$ \\begin{aligned} \\lambda(p^w) \u0026amp;= \\phi(p^w) \u0026amp; p \u0026amp;\u0026gt; 2\\\\ \\lambda(p^w) \u0026amp;= \\phi(p^w) \u0026amp; p \u0026amp;= 2, w \u0026lt; 3\\\\ \\lambda(p^w) \u0026amp;= \\frac{1}{2} \\phi(p^w)\t\u0026amp; p \u0026amp;= 2, w \\geq 3 \\end{aligned} $$ Viết hàm Carmichael, nhận vào một số nguyên $n \\geq 1$ và trả về $\\lambda(n)$. Nếu $n \u0026lt; 1$ trả về 0\nKhoảng nhập: $1 \\leq n \\leq 1e10$\nLời giải Hàm phi Euler của $n = p_1^{w_1} \\times p_2^{w_2} \\times\u0026hellip;\\times p_k^{w_n}$ được tính bởi công thức sau: $$ \\phi(n) = n \\times (1 - \\frac{1}{p_1}) \\times (1 - \\frac{1}{p_2}) \\times\u0026hellip;\\times (1 - \\frac{1}{p_k})$$\nCho $n = p^w$ công thức được viết lại như sau: $$ \\phi(n) = p^w \\times (1 - \\frac{1}{p}) = p^{w-1} \\times (p-1)$$\nKết hợp vừa phân tích thừa số nguyên tố của n, vừa tính $\\lambda$ của chúng thông qua $\\phi$ mình có đoạn chương trình sau:\n#include \u0026lt;vector\u0026gt; #include \u0026lt;math.h\u0026gt; long long Carmichael(long long n){ if (n \u0026lt; 1) return 0; if (n == 1) return 1; std::vector\u0026lt;long long\u0026gt; factors; for(long long i = 2; i*i \u0026lt;= n; i += 2){ long long w = 0; while(n % i == 0){ w++; n /= i; } if (i == 2 \u0026amp;\u0026amp; w \u0026gt;= 3) factors.push_back((pow(i, w-1) * (i-1))/2); else if(i \u0026gt;= 2 \u0026amp;\u0026amp; w \u0026gt; 0) factors.push_back(pow(i, w-1) * (i-1)); if(i == 2) i--; } if(n != 1) factors.push_back(n-1); } Lúc này, mình đã có được một dãy các kết quả của $\\lambda(p_1^{w_1}), \\lambda(p_2^{w_2}),\u0026hellip;, \\lambda(p_n^{w_n})$. Công đoạn cuối là tính bội chung nhỏ nhất của chúng. Một trong những phương pháp đơn giản là lấy tích chia cho ước chung lớn nhất: $$ LCM(a, b) = \\frac{a \\times b}{GCD(a,b)} = a \\times \\frac{b}{GCD(a, b)} $$\nVới a là kết quả cần tính và b là các phần tử $\\lambda(p_i^{w_i})$ trong factors, mình có thể khởi động vòng lặp tính lcm như sau:\nlong long res = 1; for(auto i : factors) res *= i/gcd(res, i); return res; Hàm gcd sử dụng giải thuật Euclid long long gcd(int a, int b) { while(b){ long long t = a % b; a = b; b = t; } return a; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/carmichael/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Trong lý thuyết số, hàm Carmichael của một số nguyên dương $n$, ký hiệu $\\lambda(n)$, là số nguyên dương m nhỏ nhất sao cho $a^m \\equiv 1 \\mod n$ với mọi $a \\leq n$ là các số nguyên tố cùng nhau với n.\nVí dụ $n = 8$. Các số nguyên tố cùng nhau với $8$ không vượt quá $8: 1, 3, 5, 7.$ $$ \\begin{aligned} 1^2 \\equiv 1 \\mod 8 \\\\ 3^2 \\equiv 1 \\mod 8 \\\\ 5^2 \\equiv 1 \\mod 8 \\\\ 7^2 \\equiv 1 \\mod 8 \\\\ \\end{aligned} $$","title":"Hàm Carmichael"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/\nVí dụ\nsum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u0026gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u0026gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u0026gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau. Có hai trường hợp như sau:\nĐầu khoảng này là đuôi khoảng kia. Ví dụ: [1, 4] và [3, 5] Thời điểm cuối của khoảng thứ hai lớn hơn thời điểm cuối của khoảng thứ nhất Khoảng sau khi gộp là: [1, 5] Khoảng này nằm hoàn toàn trong khoảng kia. Ví dụ: [1, 5] và [2, 4] Thời điểm cuối của khoảng thứ hai nhỏ hơn thời điểm cuối của khoảng thứ nhất Khoảng sau khi gộp là khoảng thứ nhất: [1, 5] Vậy, trước tiên mình cần sort intervals từ bé đến lớn theo các thời điểm đầu để không bỏ sót các khoảng lồng nhau nào, dẫn đến kết quả trả về cao hơn kỳ vọng. Dùng một mảng merged để lưu các khoảng sau khi gộp, với merged.back() đóng vai trò là khoảng liền trước khoảng đang xét. Lúc này, nếu khoảng đang xét có lồng với khoảng trước thì cập nhật thời điểm cuối của khoảng trước đó - merged.back() - cho phù hợp, nếu không thì thêm khoảng đang xét vào merged. Sau cùng chỉ cần cộng các khoảng đã gộp là xong.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;algorithm\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { int size = intervals.size(); std::sort(intervals.begin(), intervals.end()); std::vector\u0026lt;std::pair\u0026lt;int,int\u0026gt;\u0026gt; merged = {{intervals[0].first, inttervals[0].second}}; for(int i = 1; i \u0026lt; size; i++){ if(intervals[i].first \u0026lt;= merged.back().second) //Lồng nhau: if (intervals[i].second \u0026gt;= merged.back().second) // Trường hợp (1) merged.back().second = intervals.second; else continue; // Trường hợp (2) else merged.push_back(intervals[i]); // Không lồng nhau } int res = 0; for(const auto \u0026amp;i : merged) res += i.second - i.first; return res; } Cải tiến Gọi x là thời điểm cuối của khoảng trước khoảng đang xét (tức là nó chứa giá trị của merged.back().second ở trên). Vẫn với hai trường hợp lồng nhau nhưng mình sẽ thay đổi thứ tự của các trường hợp khi xét:\nNếu thời điểm cuối của khoảng đang xét lớn hơn hoặc bằng x sẽ có 2 khả năng: Nếu thời điểm đầu của nó mà nhỏ hơn x thì nó đang bị lồng theo trường hợp (1) Nếu thời điểm đầu của nó mà lớn hơn x thì nó không có lồng nhau với khoảng trước nó. Dù là khả năng thứ nhất hay thứ hai thì giá trị của x sẽ cần được cập nhật thành thời điểm cuối của khoảng đang xét. Ngược lại, nếu nó nhỏ hơn x thì nó đang bị lồng theo trường hợp (2). Tức là có thể bỏ qua nó. Với phương pháp này mình chỉ sử dụng cấu trúc if một lần và không cần mảng merged khiến code trông gọn hơn.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;algorithm\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { std::sort(intervals.begin(), intervals.end()); int x = intervals[0].first, res = 0; for (auto \u0026amp;i : intervals){ if (i.second \u0026gt;= x){ res += i.second - (i.first \u0026gt; x ? i.first : x); x = i.second; } } return res; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/sumofintervals/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/\nVí dụ\nsum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u0026gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u0026gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u0026gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau.","title":"Tổng các khoảng"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Cho lớp RomanNumerals để chuyển đổi các chữ số la mã về số nguyên và ngược lại.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; class RomanHelper{ public: std::string to_roman(unsigned int n){ } int from_roman(std::string rn){ } } RomanNumerals; Việc chuyển đổi phải tuân theo nguyên tắc sau:\nChữ số La Mã hiện đại được viết bằng cách thể hiện từng chữ số riêng biệt bắt đầu bằng chữ số tận cùng bên trái và bỏ qua bất kỳ chữ số nào có giá trị bằng 0.\n1990 được viết là 1000 = M, 900 = CM, 90 = XC; =\u0026gt; MCMXC. 2008 được viết là 2000 = MM, 8 = VIII; =\u0026gt; MMVIII. 1666 cũng tương tự: MDCLXVI. Ví dụ:\nRomanNumerals.toRoman(1000); // Trả về: \u0026#39;M\u0026#39; RomanNumerals.fromRoman(\u0026#39;M\u0026#39;); // Trả về: 1000 Bảng kí tự:\nKí tự I V X L C D M Chữ số 1 5 10 50 100 500 1000 Lời giải Chuyển số nguyên sang số la mã Ý tưởng là mình sẽ chuyển từng chữ số theo từng hàng: nghìn, trăm, chục, đơn vị. Giả sử, nếu số cần chuyển lớn hơn 1000 thì ta trừ đi 1000 và thêm kí tự M vào chuỗi kết quả. Cứ trừ đến khi nó không được nữa thì chuyển đến hàng trăm. Tính cả các số được biểu diễn đặc biệt như 4 (IV) hay 9 (IX) thì có tất cả 13 trường hợp:\nstd::string to_roman(unsigned int n){ std::string res = \u0026#34;\u0026#34;; std::string rnums[] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; int nums[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; for(int i = 0; i \u0026lt; 13; i ++){ while (n \u0026gt;= nums[i]){ res.append(rnums[i]); n -= nums[i]; } } return res; } Chuyển số la mã sang số nguyên Như đã biết, mỗi kí tự số la mã đại diện cho một số nguyên, nên trước hết mình sẽ đưa từng kí tự về số nguyên mà nó đại diện.\nint from_roman(std::string rn){ int from_roman(std::string rn){ std::vector\u0026lt;int\u0026gt; a; for(char i : rn){ switch(i){ case \u0026#39;I\u0026#39;: a.push_back(1); break; case \u0026#39;V\u0026#39;: a.push_back(5); break; case \u0026#39;X\u0026#39;: a.push_back(10); break; case \u0026#39;L\u0026#39;: a.push_back(50); break; case \u0026#39;C\u0026#39;: a.push_back(100); break; case \u0026#39;D\u0026#39;: a.push_back(500); break; case \u0026#39;M\u0026#39;: a.push_back(1000); break; } } ... } Mục đích của việc này là để tiện cho việc so sánh. Để ý rằng, nếu chữ số phía trước lớn hơn hoặc bằng chữ số phía sau thì cộng thêm vào, chẳng hạn: VI = V + I = 6. Ngược lại, nếu chữ số phía trước nhỏ hơn thì trừ đi. Từ đây, mình sẽ so sánh từng cặp số liên tiếp trong mảng a rồi cộng trừ các kiểu như trên để cho ra kết quả cuối cùng. Vì phần tử cuối cùng không có phần tử phía sau để so sánh nên sẽ được cộng vào trước.\nint from_roman(std::string rn){ ... int res = a.back(), size = a.size(); for(int i = 0; i \u0026lt; size-1; i++) if(a[i] \u0026gt;= a[i+1]) res += a[i]; else res -= a[i]; return res; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/romannumeral/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Cho lớp RomanNumerals để chuyển đổi các chữ số la mã về số nguyên và ngược lại.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; class RomanHelper{ public: std::string to_roman(unsigned int n){ } int from_roman(std::string rn){ } } RomanNumerals; Việc chuyển đổi phải tuân theo nguyên tắc sau:\nChữ số La Mã hiện đại được viết bằng cách thể hiện từng chữ số riêng biệt bắt đầu bằng chữ số tận cùng bên trái và bỏ qua bất kỳ chữ số nào có giá trị bằng 0.","title":"Chuyển đổi số la mã"},{"content":"Bài toán Nguồn: CSES In ra tổng số cách đặt hai con mã lên bàn cờ $k \\times k, k = 1,2,\u0026hellip;,n$ ($n$ nhập từ bàn phím) sao cho chúng không ăn nhau. Ví dụ:\nInput: 8 Output: 0 6 28 96 252 550 1056 1848 Lời giải Ý tưởng Phương pháp đơn giản là ứng với mỗi vị trí của con mã thứ nhất, mình tìm các vị trí thích hợp cho con mã thứ hai rồi trả về tổng số vị trí tìm được. Thực hiện việc tìm kiếm $n$ lần cho các bàn cờ từ $1 \\times 1$ đến $n \\times n$ khá là liều lĩnh khi có nhiều vòng lặp lồng nhau nên mình cần cách khôn ngoan hơn 👀\nThay vì tìm trực tiếp như trên, mình có thể tiến hành tìm gián tiếp bằng cách lấy tổng số cách đặt hai con mã vào bàn cờ trừ đi số cách đặt hai con mã để chúng ăn nhau.\nTổng số cách đặt hai con mã vào bàn cờ $k \\times k$ là: $$C^2_{k^2} = \\frac{k^2!}{2!(k^2-2)!} = \\frac{k^2(k^2-1)(k^2-2)!}{2(k^2-2)!} = \\frac{k^2(k^2-1)}{2}$$ Để ý rằng, khi hai con mã ở vị trí có thể ăn nhau, chúng tạo thành đường chéo của hình chữ nhật $2 \\times 3$ (nằm ngang) hoặc $3 \\times 2$ (nằm dọc). Bàn cờ là hình vuông nên số lượng hình chữ nhật $2 \\times 3$ sẽ bằng với $3 \\times 2$, vì thế ta chỉ việc đếm một loại rồi nhân đôi.\nCác bước đếm được tiến hành như sau:\nBắt đầu từ ô trái trên cùng, mình vẽ ra một hình chữ nhật $2 \\times 3$. Dịch hình chữ nhật sang phải 1 ô đến khi không thể dịch nữa. Vì 2 cột phải cùng của hình chữ nhật ko thể lọt ra ngoài bàn cờ nên mình dịch được $k-2$ lần. Tương tự, số lần mình dịch hình chữ nhật xuống dưới sẽ là $k-1$ (bởi hàng dưới cùng không thể lọt ra ngoài). Cuối cùng, nhân số lần dịch sang phải với số lần dịch xuống, rồi nhân đôi lên $$2(k-1)(k-2)$$ Ngoài ra, một hình chữ nhật có hai đường chéo, đồng nghĩa là có 2 cách cho hai con mã ăn nhau trong mỗi trường hợp. Vậy số cách đặt hai con mã để chúng ăn nhau là: $$4(k-1)(k-2)$$\nSau cùng, mình có được đáp án của bài toán này là: $$\\frac{k^2(k^2-1)}{2} - 4(k-1)(k-2)$$\nChương trình #include\u0026lt;iostream\u0026gt; int main(){ int n; std::cin \u0026gt;\u0026gt; n; for(long long i = 1; i \u0026lt;= n; i++){ std::cout \u0026lt;\u0026lt; i*i*(i*i - 1)/2 - 4*(i-1)*(i-2) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } Cảm ơn bạn vì đã đọc 👀\n","permalink":"https://yurukute.github.io/Blog/post/2knights/","summary":"Bài toán Nguồn: CSES In ra tổng số cách đặt hai con mã lên bàn cờ $k \\times k, k = 1,2,\u0026hellip;,n$ ($n$ nhập từ bàn phím) sao cho chúng không ăn nhau. Ví dụ:\nInput: 8 Output: 0 6 28 96 252 550 1056 1848 Lời giải Ý tưởng Phương pháp đơn giản là ứng với mỗi vị trí của con mã thứ nhất, mình tìm các vị trí thích hợp cho con mã thứ hai rồi trả về tổng số vị trí tìm được.","title":"Hai quân mã"},{"content":"Bài toán Nguồn:\nTiếng Việt: Codeforces - Bản dễ Có thể giải với $O(n^2)$ Codeforces - Bản khó Cần giải bằng $O(n\\log n)$ Tiếng Anh: Leetcode Cho một dãy số nguyên nums. Tìm độ dài của dãy con tăng đơn điệu dài nhất. Biết rằng dãy con tăng đơn điệu là 1 dãy $a_1,..,a_k$ thỏa mãn $$ \\begin{align} \u0026amp;i_1 \u0026lt; i_2 \u0026lt; \\dots \u0026lt; i_k,\\\\\\ \u0026amp;nums[i_1] \u0026lt; nums[i_2] \u0026lt; \\dots \u0026lt; nums[i_k] \\end{align} $$ Ví dụ:\nInput: {0,1,0,3,2,3} Output: 4 //{0,1,2,3} Lời giải Vét cạn Đây là phương pháp bần nhất có thể nghĩ: liệt kê hết tất cả các dãy con tăng đơn điệu rồi tìm đâu là dãy con lớn nhất để trả về kết quả. Với độ phức tạp là $O(2^n),$ đây cũng là cách không hiệu quả nhất khi $n$ trở nên lớn.\nQuy hoạch động $O(n^2)$ Để giải bài này, mình chia nó thành các bài toán con và tìm từng kết quả của chúng. Chẳng hạn với nums = {0,1,0,3,2,3}, các bài toán con mà mình cần giải quyết lần lượt là:\nTìm dãy con tăng đơn điệu dài nhất của:\n[0-0] {0}\n[0-1] {0, 1}\n[0-2] {0, 1, 0}\n[0-3] {0, 1, 0, 3}\n[0-4] {0, 1, 0, 3, 2}\n[0-5] {0, 1, 0, 3, 2, 3} $\\Rightarrow$ Bài toán đang giải.\nVậy, bảng quy hoạch động d của mình sẽ gồm 5 ô mà mỗi ô tượng trưng cho 1 bài toán con. Giả sử mình đã có đáp án cho các ô 0, 1, 2 và cần tìm đáp án cho ô thứ 3, khi đó, mình cần hỏi bản thân 3 câu hỏi:\nLiệu mình có thể thêm $nums[3]$ vào dãy con đã tìm ở $d[0]$ hay không? Liệu mình có thể thêm $nums[3]$ vào dãy con đã tìm ở $d[1]$ hay không? Liệu mình có thể thêm $nums[3]$ vào dãy con đã tìm ở $d[2]$ hay không? Và nếu câu trà lời là có (tức là $nums[3] \u0026gt; nums[i]$), mình sẽ lựa chọn xem có nên hay không nên việc thêm $nums[3]$ vào nếu đáp án ở ô $nums[3]$ hiện tại bé hơn / lớn hơn cái tìm được.\nKhái quát hơn: $$d[i] = \\max_{\\substack{j = 0 \\dots i-1 \\\\\\ nums[j] \u0026lt; nums[i]}} \\left(d[j] + 1\\right)$$\nCơ sở của d sẽ là 1 vì với một dãy chỉ có 1 phần tử, 1 chính là đáp áp, việc của mình là làm tăng đáp án đó lên khi duyệt qua nó.\ni 0 1 2 3 4 5 $nums$ 0 1 0 3 2 3 $d$ 1 1 1 1 1 1 Vậy lúc này, công thức sẽ trở thành $$d[i] = \\max\\left(1, \\max_{\\substack{j = 0 \\dots i-1 \\\\\\ nums[j] \u0026lt; nums[i]}} \\left(d[j] + 1\\right)\\right)$$\nCuối cùng, đáp án chính là ô mang giá trị lớn nhất trong d.\nint lis(std::vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(), max = 1; std::vector\u0026lt;int\u0026gt; lis(n,1); for(int i = 1; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; i; j++) if(nums[j] \u0026lt; nums[i] \u0026amp;\u0026amp; lis[i] \u0026lt; lis[j]+1) lis[i] = lis[j] + 1; if(lis[i] \u0026gt; max) max = lis[i]; } return max; } i 0 1 2 3 4 5 $nums$ 0 1 0 3 2 3 $d$ 1 2 1 3 3 4 $\\Rightarrow$ đáp án Quy hoạch động và tìm kiếm nhị phân $O(n\\log n)$ Mình sẽ vẫn sử dùng bảng quy hoạch động d nhưng để lưu lại phần tử kết thúc của dãy con có độ dài là $i$.\nCơ sở quy hoạch động là $d[0] = -\\infty$ trong khi các ô còn lại $d[i] = \\infty$ Vậy độ dài của dãy con tăng đơn điệu dài nhất sẽ là $l$ với $l$ lớn nhất mà $d[l] \u0026lt; \\infty$\nint lis(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), max = 1; const int INF = 1e9; std::vector\u0026lt;int\u0026gt; d(n+1, INF); d[0] = -INF; for (int i = 0; i \u0026lt; n; i++) for (int j = 1; j \u0026lt;= n; j++) { if (d[j-1] \u0026lt; nums[i] \u0026amp;\u0026amp; nums[i] \u0026lt; d[j]) d[j] = nums[i]; } for (int i = 0; i \u0026lt;= n; i++) if (d[i] \u0026lt; INF) max = i; return max; } i 0 1 2 3 4 5 $nums$ 0 1 0 3 2 3 $d$ $-\\infty$ 0 1 2 3 $\\infty$ Mình thấy được rằng:\nd luôn được sắp xếp tăng dần phần tử $nums[i]$ sẽ chỉ cập nhật nhiều nhất một giá trị $d[j]$ Vì vậy, mình có thể tìm phần tử trong d bằng Tìm kiếm nhị phân O($\\log n$). Trên thực tế, mình chỉ đơn giản là tìm phần tử đầu tiên lớn hơn $nums[i]$ và cập nhật nó như cách thực hiện bên trên.\nint lis(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), max = 1; const int INF = 1e9; std::vector\u0026lt;int\u0026gt; d(n+1, INF); d[0] = -INF; for (int i = 0; i \u0026lt; n; i++){ int j = upper_bound(d.begin(), d.end(), a[i]) - d.begin(); if (d[j-1] \u0026lt; nums[i] \u0026amp;\u0026amp; nums[i] \u0026lt; d[j]) d[j] = nums[i]; } for (int i = 0; i \u0026lt;= n; i++) if (d[i] \u0026lt; INF) max = i; return max; Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/lis/","summary":"Bài toán Nguồn:\nTiếng Việt: Codeforces - Bản dễ Có thể giải với $O(n^2)$ Codeforces - Bản khó Cần giải bằng $O(n\\log n)$ Tiếng Anh: Leetcode Cho một dãy số nguyên nums. Tìm độ dài của dãy con tăng đơn điệu dài nhất. Biết rằng dãy con tăng đơn điệu là 1 dãy $a_1,..,a_k$ thỏa mãn $$ \\begin{align} \u0026amp;i_1 \u0026lt; i_2 \u0026lt; \\dots \u0026lt; i_k,\\\\\\ \u0026amp;nums[i_1] \u0026lt; nums[i_2] \u0026lt; \\dots \u0026lt; nums[i_k] \\end{align} $$ Ví dụ:","title":"Dãy con tăng đơn điệu dài nhất"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Theo Wikipedia :\nBài toán xâu con chung dài nhất là bài toán tìm một xâu có độ dài lớn nhất và là xâu con của mọi xâu trong một tập hợp các xâu. Khác với chuỗi con, các phần tử của xâu con không nhất thiết phải liên tiếp nhau.\nVới 2 chuỗi được nhập vào, nhiệm vụ của bạn chính là tìm ra xâu con dài nhất của chúng.\nVí dụ:\nInput: \u0026#34;ab\u0026#34; \u0026#34;azb\u0026#34; Output: \u0026#34;ab\u0026#34; Lời giải Mình giải bài này theo 2 bước:\nTìm độ dài của xâu con bằng quy hoạch động. Sừ dụng bảng quy hoạch động để quay lui tìm xâu con. Bước 1: Cho lcs(\u0026quot;aab\u0026quot;, \u0026quot;azb\u0026quot;) là hàm tìm xâu con dài nhất (bài toán lớn). Quy trình của nó có thể được mô tả như sau:\nXét thấy kí tự cuối cùng của 2 xâu là giống nhau: Độ dài của xâu con tăng thêm một. Đưa bài toán về lcs(\u0026quot;aa\u0026quot;, \u0026quot;az\u0026quot;). Xét 2 xâu mới, kí tự cuối cùng của 2 xâu không giống nhau: Lần lượt bỏ kí tự cuối ở mỗi xâu và tìm xâu con lớn nhất giữa chúng. max(lcs(\u0026quot;a\u0026quot;, \u0026quot;az\u0026quot;), lcs(\u0026quot;aa\u0026quot;, \u0026quot;a\u0026quot;) graph TD; A(\"lcs(aab, azb)\")--\u003eB((1)) A--\u003eC(\"lcs(aa, az)\") C--\u003eD(\"max(lcs(a, az), lcs(aa, a)\") D--\u003eE(\"lcs(a,az)\") D--\u003eF(\"lcs(aa, a)\") E--\u003eG(\"max(lcs(a, a), lcs(``, az)\") F--\u003eH((1)) F--\u003eI(\"lcs(a, ``)\") G--\u003eJ(\"lcs(a, a)\")--\u003eL((1)) G--\u003eK(\"lcs(``, az)\")--\u003eM((0)) I--\u003eN((0)) Gọi dp[i][j] là độ dài lớn nhất của xâu con từ $i$ phần tử đầu tiên của xâu $x$ và $j$ phần tử đầu tiên của xâu $y$, như vậy: $$dp[i][j]= \\begin{cases} 1 + dp[i-1][j-1] \u0026amp; x[i] = y[j]\\\\ max(dp[i-1][j],\\ dp[i][j-1]) \u0026amp; x[i] \\ne y[j] \\end{cases} $$\nint n = x.length(), m = y.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1, vector(m+1, 0)); for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) if(x[i-1] == y[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; else dp[i][j] = (dp[i-1][j] \u0026gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]); Bảng quy hoạch động của mình sẽ trông như thế này\n\u0026quot;\u0026quot; a z b \u0026quot;\u0026quot; 0 0 0 0 a 0 1 1 1 a 0 1 1 1 b 0 1 1 2 Bước 2: Để ý rằng, tại những ô mà ô phía trên và ô bên trái của nó có giá trị nhỏ hơn thì cột (hoặc hàng) của ô đó đại diện cho kí tự chung. Để tìm được xâu con chung, mình bắt từ ô cuối cùng (dp[n][m]), lùi dần lên (hoặc sang trái) cho đến khi gặp ô như mình đã nói, lưu lại kí tự chung, sau đó nhảy sang ô ở hàng trên và cột bên trái của nó (dp[i-1][j-1]) để dò tiếp.\nstring res = \u0026#34;\u0026#34;; while(dp[n][m] != 0){ while(dp[n][m] == dp[n-1][m]){ n--; } while(dp[n][m] == dp[n][m-1]){ m--; } res.insert(res.begin(), x[n-1]); n--; m--; } return res; Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/lcs/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Theo Wikipedia :\nBài toán xâu con chung dài nhất là bài toán tìm một xâu có độ dài lớn nhất và là xâu con của mọi xâu trong một tập hợp các xâu. Khác với chuỗi con, các phần tử của xâu con không nhất thiết phải liên tiếp nhau.\nVới 2 chuỗi được nhập vào, nhiệm vụ của bạn chính là tìm ra xâu con dài nhất của chúng.","title":"Xâu con chung dài nhất"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?\nTheo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số) Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:\nInput: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω\u0026lt;)☆.\nMình có bảng quy hoạch động (ways) sau:\n0 1 2 3 4 0 1 2 3 4 Như vậy,ways[i][j] sẽ là số cách phân tích số $j$ thành tổng các số nguyên dương $\\leq i$. Cách phân tích số $j$ có thể chia làm hai loại\nKhông chứa số i\nBài toán lúc này trở thành số cách phân tích số $i$ thành tổng các số nguyên dương $\u0026lt; i$, nói cách khác là $\\leq i - 1$\nChứa số i\nKhi đó, nếu bỏ đi $i$ mình sẽ được các cách phân tích số $j - i$\nRõ ràng, các cách phân tích chỉ có thể là loại 1 nếu $i \u0026gt; j$, ngược lại, số cách sẽ là tổng 2 loại trên. Vì thế: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; i \u0026gt; j \\\\ ways[i-1][j] + ways[i][j-i], \u0026amp; i \\leq j \\end{cases} $$\nĐể tính được ways[i][j] thì mình phải tính trướcways[i-1][j] và ways[i][j-i] nên ban đầu mình phải điền vào hàng 0, cơ sở của bảng. Vì số cách phân tích số 0 là 1 nên ways[0][0] = 1, còn lại tất cả sẽ là 0. Sau đó, dùng công thức truy hồi tìm tất cả các ô, lúc này ways[n][n] sẽ là kết quả mình cần tìm.\n#include\u0026lt;vector\u0026gt; using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vector\u0026lt;std::vector\u0026lt;ull\u0026gt;\u0026gt; ways(n+1, std::vector\u0026lt;ull\u0026gt; (n+1, 0)); ways[0][0] = 1; for(unsigned int i = 1; i \u0026lt;= n; i++){ for(unsigned int j = i; j \u0026lt;= n; j++){ ways[i][j] = ways[i-1][j]; if(i \u0026lt;= j) ways[i][j] += ways[i][j-i]; } } return ways[n][n]; } 0 1 2 3 4 0 1 0 0 0 0 1 1 1 1 1 1 2 1 1 2 2 3 3 1 1 2 3 4 4 1 1 2 3 5 Cải tiến Có thể thấy, sau khi tính xong dòng thứ $n$ thì việc lưu trữ các dòng từ $1$ đến $n-1$ là dư thừa bởi vì việc tính dòng $n+1$ chỉ phụ thuộc vào dòng $n$. Nên mình sẽ dùng mảng 1 chiểu để lưu trữ và tự tính chính nó.\n#include\u0026lt;vector\u0026gt; using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vector\u0026lt;ull\u0026gt; ways(n+1, 0); ways[0] = 1; for(unsigned int i = 1; i \u0026lt;= n; i++){ for(unsigned int j = i; j \u0026lt;= n; j++){ ways[j] += ways[j - i]; } } return ways[n]; } 0 1 2 3 4 1 1 2 3 5 Cảm ơn bạn vì đã đọc.\nBài viết liên quan Tổng số đổi đồng xu ","permalink":"https://yurukute.github.io/Blog/post/explosivesum/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?\nTheo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số) Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:\nInput: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω\u0026lt;)☆.","title":"Tổng số cách phân tích n"},{"content":"Bài toán Nguồn: Codeforces Đọc hiểu Tìm phần dư của số Fibonacci thứ $n$ ($n \u0026lt;= 10^{18}$) cho $10^9 + 7$. Như vậy, mình cần tìm $F_n$ trong dãy số được định nghĩa: $$\n\\begin{aligned} F_0 \u0026amp; = 0\\\\ F_1 \u0026amp; = 1\\\\ F_i \u0026amp; = F_{i-1} + F_{i-2} (i \u0026gt;= 2) \\end{aligned} $$ Ví dụ:\nInput: 50 Output: 586268941 Lời giải Cách 1: Quy hoạch động Xem phương trình sai phân của dãy fibonacci là công thức truy hồi, mình có thể viết thành đoạn code sau:\nint f0 = 0, f1 = 1, fn; for(int i = 2; i \u0026lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; Với độ phức tạp là $O(n)$, đoạn code này chạy ổn với $n \u0026lt;= 5. 10^6$. Tuy nhiên, $n$ có thể lên đến $10^{18}$ ở bài toán này nên mình cần một giải thuật tốt hơn, ít nhất phải là $O(log^2 n)$\nCách 2: Nhân ma trận Từ phương trình sai phân của dãy fibonacci, mình có thể viết lại như sau: $$ \\begin{aligned} F_{n+1} \u0026amp; = 1\\ F_n + 1\\ F_{n-1}\\\\ F_{n} \u0026amp; = 1\\ F_n + 0\\ F_{n-1}\\\\ \\\\ =\u0026gt; \\begin{bmatrix} F_{n+1} \\\\ F_n \\end{bmatrix} \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} F_n \\\\ F_{n-1} \\end{bmatrix} \\\\\\\\ \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}^n \\begin{bmatrix} F_1 \\\\ F_0 \\end{bmatrix} \\end{aligned} $$ Có thể thấy $F_n$ sẽ bằng dòng thứ 2 của $\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix}^n$ nhân với $\\begin{bmatrix} F_1 \\\\ F_0 \\end{bmatrix}$. Mình lại có $F_1 = 1, F_0 = 0$ nên $F_n$ lúc này sẽ là phần tử ở dòng 2 cột 1 của $\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix}^n$.\nTính lũy thừa với n lớn Đối với $n$ lớn, thay vì cứ nhân cơ số $n$ lần theo định nghĩa, mình sẽ bình phương cơ số, đồng thời giảm số mũ đi một nửa. Ví dụ: Thay vì tính $2^6 = 2\\times2\\times2\\times2\\times2\\times2,$ mình sẽ tính $2^6 = 4^4 = 8^2$\nNói cách khác, mình sẽ cố gắng thay thế việc nhân nhiều lần một số nhỏ thành nhân vài lần các số lớn với nhau. Với cách này mình sẽ đưa độ phức tạp về $O(logn)$.\nint res = 1; while (b \u0026gt; 0){ if(b % 2) res = res * a; a = a * a; b \u0026gt;\u0026gt;= 1 } Hiện tại, cơ số của mình là một ma trận $2\\times2$ nên mình cần khai báo struct và thêm hàm để thuận lợi cho việc tính toán cũng như lưu trữ:\nconst unsigned long long mod = 1e9 + 7; struct matrix{ unsigned long long a, b, c, d; }; matrix multiply(matrix A, matrix B){ matrix C; C.a = (A.a*B.a + A.b*B.c) % mod; C.b = (A.a*B.b + A.b*B.d) % mod; C.c = (A.c*B.a + A.d*B.c) % mod; C.d = (A.c*B.b + A.d*B.d) % mod; return C; } matrix power(matrix a, long long b){ matrix res; //cho res là ma trận đơn vị res.a = res.d = 1; res.b = res.c = 0; while (b \u0026gt; 0){ if(b % 2) res = multiply(res, a); a = multiply(a, a); b \u0026gt;\u0026gt;= 1; } return res; } Cuối cùng, ta cho $F = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}$, kết quả cuối cùng sẽ là power(F,n).c.\nCảm ơn bạn vì đã đọc. Chúc bạn có một năm mới tràn đầy niềm vui và hạnh phúc =w=.\n","permalink":"https://yurukute.github.io/Blog/post/fibonacci/","summary":"Bài toán Nguồn: Codeforces Đọc hiểu Tìm phần dư của số Fibonacci thứ $n$ ($n \u0026lt;= 10^{18}$) cho $10^9 + 7$. Như vậy, mình cần tìm $F_n$ trong dãy số được định nghĩa: $$\n\\begin{aligned} F_0 \u0026amp; = 0\\\\ F_1 \u0026amp; = 1\\\\ F_i \u0026amp; = F_{i-1} + F_{i-2} (i \u0026gt;= 2) \\end{aligned} $$ Ví dụ:\nInput: 50 Output: 586268941 Lời giải Cách 1: Quy hoạch động Xem phương trình sai phân của dãy fibonacci là công thức truy hồi, mình có thể viết thành đoạn code sau:","title":"Fibonacci"},{"content":"Bài toán Nguồn: Leetcode , Codewars Đọc hiểu: Bạn có một lượng đồng xu với các mệnh giá khác nhau và một tổng số tiền amount. Nhiệm vụ của bạn là tính xem có bao nhiêu cách khác nhau để đổi được số tiền với số xu đã cho. Số lượng xu không giới hạn.\nVí dụ:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Lời giải Với bài này mình sẽ lần lượt đi qua các giai đoạn của nó mà ở mỗi gia đoạn số xu của mình sẽ thay đổi dẫn đến sự thay đổi của kết quả bài toán. Mình có bảng quy hoạch động (ways) sau:\n0 1 2 3 4 5 {} {1} {1,2} {1,2,5} Mỗi một ô trên bảng là một bài toán con và chúng đều có sự liên quan tới nhau. Giả sử mình ở ô $ways[1][1]$, khi đấy mình sẽ tìm tổng số cách đổi xu của số tiền $1$ với các xu {1}; nếu mình ở ô $ways[2][3]$ thì mình sẽ tìm tổng số cách đổi xu của số tiền $3$ với các xu {1,2}. Tương tự như vậy, giá trị của ô $ways[i][j]$ sẽ là đáp án của bài toán tổng số cách đổi xu của số tiền $j$ với các xu ở hàng $i$.\nBênh cạnh đó, từng hàng $i$ của bảng lại đại diện cho sự xuất hiện thêm của một đồng xu (được in đậm). Như vậy, hàng $i$ sẽ trả lời cho câu hỏi Liệu mình có dùng đồng xu thứ $i$ không?\nRõ ràng, mình sẽ không dùng đồng xu thứ $i$ nếu $coins[i-1] \u0026gt; j$, ngược lại thì có thể. Vì thế: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; coins[i-1] \u0026gt; j \\\\ ways[i-1][j] + ways[i][j-coins[i-1]], \u0026amp; coins[i-1] \\leq j \\end{cases} $$ Giải thích một chút ở công thức này nha. Khi mình không dùng đồng xu đang xét thì bài toán quay ngược lại bài toán con ở hàng trên, hàng không có sự xuất hiện của $coins[i-1]$ nên ta chỉ cần lấy kết quả đó. Nhưng nếu dùng thì số tiền lúc này chỉ còn $j - coins[i-1]$ nên mình sẽ truy hồi về ô $ways[i][j-coins[i-1]]$ để lấy số cách của ô này cộng với trường hợp [không dùng].\nĐiền cơ sở Để bắt đầu thì mình cần điền vào hàng 0 và cột 0 (cơ sở của quy hoạch động) trước. Hàng 0 mang ý nghĩa không có đồng xu nào nên ta sẽ không đổi được bất cứ số tiền nào cả, giá trị của các ô này là 0. Cột 0 thì mang ý nghĩ dùng các xu được cho đổi ra\u0026hellip; không, nên các ô của cột sẽ có giá trị là 1 vì cách duy nhất là không làm gì hết.\nĐể thuận tiện khi code, mình sẽ tạo vector 2 chiều với các phần tử là 0. Như vậy, chỉ cần điền cột 0 là được.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ways(coins.size() +1, vector\u0026lt;int\u0026gt; (amount + 1, 0)); for(int i = 0; i \u0026lt;= coins.size(); i++) ways[i][0] = 1; 0 1 2 3 4 5 {} 1 0 0 0 0 0 {1} 1 0 0 0 0 0 {1,2} 1 0 0 0 0 0 {1,2,5} 1 0 0 0 0 0 Việc cần làm tiếp theo chính là điền các ô còn lại. Khi điền hết, ô cuối cùng chính là đáp án của bài toán\nfor(int i = 1; i \u0026lt;= coins.size(); i++) for(int j = 1; j \u0026lt;= amount; j++) ways[i][j] = ways[i-1][j]; if(j \u0026gt;= coins[i-1]) ways[i][j] += ways[i][j - coins[i-1]]; return ways[coins.size()][amount]; 0 1 2 3 4 5 {} 1 0 0 0 0 0 {1} 1 1 1 1 1 1 {1,2} 1 1 2 2 3 3 {1,2,5} 1 1 2 2 3 4 Cải tiến Cách làm trên có một nhược điểm là sau khi tính xong dòng thứ $n$ thì việc lưu trữ các dòng từ $1$ đến $n-1$ là dư thừa bởi vì việc tính dòng $n+1$ chỉ phụ thuộc vào dòng $n$. Vì vậy, mình sẽ thay đổi từ mảng 2 chiều thành mảng 1 chiều để lưu kết quả và tự tính chính nó.\nvector\u0026lt;int\u0026gt; ways(amount + 1); ways[0] = 1; for(auto coin : coins) for(int i = 1; i \u0026lt;= amount; i++) if(i \u0026gt;= coin) ways[i] += ways[i - coin]; return ways[amount]; 0 1 2 3 4 5 1 1 2 2 3 4 Cảm ơn bạn vì đã đọc.\nBài viết liên quan Tổng số cách phân tích số n ","permalink":"https://yurukute.github.io/Blog/post/countchange/","summary":"Bài toán Nguồn: Leetcode , Codewars Đọc hiểu: Bạn có một lượng đồng xu với các mệnh giá khác nhau và một tổng số tiền amount. Nhiệm vụ của bạn là tính xem có bao nhiêu cách khác nhau để đổi được số tiền với số xu đã cho. Số lượng xu không giới hạn.\nVí dụ:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Lời giải Với bài này mình sẽ lần lượt đi qua các giai đoạn của nó mà ở mỗi gia đoạn số xu của mình sẽ thay đổi dẫn đến sự thay đổi của kết quả bài toán.","title":"Tổng số cách đổi xu"},{"content":"Bài toán Nguồn: Leetcode Đọc hiểu Bạn có một lượng đồng xu có các mệnh giá khác nhau và tổng số tiền amount. Nhiệm vụ của bạn là tìm số xu ít cần ít nhất để tạo nên số tiền đó (không giới hạn số đồng xu). Nếu số tiền đó không thể tạo thành thì trả về -1.\nVí dụ:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Lời giải Cách 1: Vét cạn bằng đệ qui Lấy ví dụ như trên, mình có amount là 11. Giả sử đồng 5 là đồng cuối cùng được chọn vậy số xu cần tìm sẽ là số xu cần ít nhất để đổi số tiền còn lại cộng thêm 1. Nói cách khác, $$ coinChange(11) = coinChange(11 - 5) + 1$$ Khi đó, bài toán trở thành tìm số xu cần ít nhất để đổi số tiền còn lại. Đây là một bài toán con. Tương tự với đồng 1 và đồng 2, các bài toán con có thể được thể hiện theo sơ đồ sau graph TD; A((11))--\u003eB((10)) A--\u003eC((9)) A--\u003eD((6)) B--\u003eE((9)) B--\u003eF((8)) B--\u003eG((5)) C--\u003eH((8)) C--\u003eI((7)) C--\u003eJ((4)) D--\u003eK((5)) D--\u003eL((4)) D--\u003eM((1)) Mình chỉ vẽ một phần của sơ đồ nhưng có thể thấy, khi xét từng trường hợp như vầy, mình sẽ phải lặp lại việc tính các bài toán con giống nhau (như có 2 số 9 nè, rồi 2 số 8,\u0026hellip;). Chính vì vậy, tụi mình cần một giải pháp thông minh hơn, đó là quy hoạch động.\nCách 2: Quy hoạch động Cũng với ý tưởng trên, lần này mình có một mảng như sau, gọi là dp nhé:\n0 1 2 3 4 5 6 7 8 9 10 11 Ô thứ $i$ của mảng lúc này là bài toán con: số xu cần ít nhất để đổi số tiền $i$. Như vậy, đáp án của ô thứ amount chính là đáp án của bài toán. Và tất nhiên, đáp án đấy sẽ được tính từ các ô trước đó nên mình có thể tận dụng các đáp số đã tính sẵn mà không cần tính lại như cách trên ^w^.\nĐể bắt đầu, mình cần điền trước vào mảng như thế này:\n0 1 2 3 4 5 6 7 8 9 10 11 0 12 12 12 12 12 12 12 12 12 12 12 Với mỗi ô, mình sẽ xét từng xu một xem nó có lớn hơn số tiền mình đang xét hay không? Nếu không có nghĩa là mình có thể dùng đồng xu và đó giá trị của ô đó sẽ là $$dp[i] = min(dp[i-coin] + 1,dp[i])$$ Giả sử $i = 1$, vậy $dp[1] = min(0+1, 12)$. Tính lần lượt như vậy, cuối cùng mảng của mình trở thành:\n0 1 2 3 4 5 6 7 8 9 10 11 0 1 1 2 2 1 2 2 3 3 2 3 Ô 11 có giá trị bằng 3, cũng tức là đáp án của bài toán ví dụ. Từ đấy, mình có đoạn code thế này:\nvector\u0026lt;int\u0026gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) for(int coin : coins) if(coin \u0026lt;= i \u0026amp;\u0026amp; dp[i - coin] + 1 \u0026lt; dp[i]) dp[i] = dp[i - coin] + 1; return dp[amount]; Ý tưởng là vậy. Nhưng thực tế là nạp cái code này lên sẽ wrong answer ngay, vì cái tội đọc không kỹ đề \u0026gt;D\u0026lt;. Trên đề có bảo rằng\nNếu số tiền đó không thể tạo thành thì trả về -1.\nVậy đấy, nên là cần phải chỉnh dòng return lại 1 tí mới qua được UwU.\nreturn (dp[amount] \u0026lt;= amount ? dp[amount] : -1); Cảm ơn bạn vì đã đọc.\nBài viết liên quan Tổng số cách đổi xu Nhập môn quy hoạch động (VNOI) ","permalink":"https://yurukute.github.io/Blog/post/coinchange/","summary":"Bài toán Nguồn: Leetcode Đọc hiểu Bạn có một lượng đồng xu có các mệnh giá khác nhau và tổng số tiền amount. Nhiệm vụ của bạn là tìm số xu ít cần ít nhất để tạo nên số tiền đó (không giới hạn số đồng xu). Nếu số tiền đó không thể tạo thành thì trả về -1.\nVí dụ:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Lời giải Cách 1: Vét cạn bằng đệ qui Lấy ví dụ như trên, mình có amount là 11.","title":"Số xu cần ít nhất để đổi một số tiền"},{"content":"Sơ lược Phép thao tác trên bit Kí hiệu Mô tả AND \u0026amp; Cả hai bit là 1, trả về 1. Ngược lại trả về 0. OR \\ Một trong hai bit là 1, trả về 1. Ngược lại trả về 0. XOR ^ Hai bit khác nhau trả về 1. Ngược lại trả về 0. NOT ~ Đảo bit, 0 thành 1, 1 thành 0. Dịch trái - Shift left \u0026lt;\u0026lt; Dịch tất cả các bit sang trái. Dịch phải - Right left \u0026gt;\u0026gt; Dịch tất cả các bit sang phải. Ứng dụng Số nguyên Thay đổi bit // Đưa bit thứ n thành 1 x |= (1 \u0026lt;\u0026lt; n); //Đưa bit 0 ngoài cùng thành 1 x |= (x+1); //Đưa bit thứ n về 0 x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Đưa bit 1 ngoài cùng về 0 x \u0026amp;= (x-1); //Đảo bit thứ n x ^= (1 \u0026lt;\u0026lt; n); //Lấy ra bit thứ n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Hoán đổi 2 bit cạnh nhau ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Nhân / Chia x với $2^n$ x \u0026lt;\u0026lt; n //nhân x \u0026gt;\u0026gt; n //chia Làm tròn lên lũy thừa cơ số 2 x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Làm tròn xuống lũy thừa cơ số 2 x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //vẫn là đoạn code trên nhưng thêm dòng này Lấy phần nguyên của x x \u0026gt;\u0026gt; 0; 6.723 \u0026gt;\u0026gt; 0; //6 Đảo dấu x x = ~x + 1; // hoặc x = (x ^ -1) + 1; // x = -x Giá trị tuyệt đối của x int abs = (x ^ (x \u0026gt;\u0026gt; 31)) - (x \u0026gt;\u0026gt; 31); Ước lũy thừa cơ số 2 lớn nhất của x x \u0026amp; (-x); Giá trị nguyên nhỏ nhất / lớn nhất int minInt = 1 \u0026lt;\u0026lt; 31; int minInt = 1 \u0026lt;\u0026lt; -1; int maxInt = ~(1 \u0026lt;\u0026lt; 31); int maxInt = (1 \u0026lt;\u0026lt; 31) - 1; int maxInt = (1 \u0026lt;\u0026lt; -1) - 1; int maxInt = -1u \u0026gt;\u0026gt; 1; int maxLong = ((long)1 \u0026lt;\u0026lt; 127) -1; Số nhỏ nhất / lớn nhất giữa 2 số //Cách 1 int min = a \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); int max = b \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); //Cách 2 int min = (b ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); int max = (a ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); Trung bình cộng 2 số int avg = (x + y) \u0026gt;\u0026gt; 1; int avg = ((x ^ y) \u0026gt;\u0026gt; 1) + (x \u0026amp; y); Hoán đổi giá trị 2 biến //Cách 1 a ^= b; b ^= a; a ^= b; //Cách 2 a = a ^ b ^ (b = a) Gõ nhanh điều kiện if Trong một số trường hợp, ta sẽ có đoạn code tựa tựa vầy:\nif(x == a) x = b; //hoặc if(x == b) x = a; Tương tự, ta đưa đoạn code về dòng sau với phép XOR:\nx ^= a ^ b; Kiểm tra giá trị của bit thứ n x \u0026amp; (1 \u0026lt;\u0026lt; n) x là số lẻ (x \u0026amp; 1) == 1; x là lũy thừa cơ số 2 x \u0026gt; 0 \u0026amp;\u0026amp; (x \u0026amp; (x - 1)) == 0; a = b (Nhanh hơn 35% trong Javascript)\n(a ^ b) == 0; 2 số a, b cùng dấu (a ^ b) \u0026gt;= 0; Chuỗi Chuyển kí tự thường thành hoa c \u0026amp; \u0026#39;_\u0026#39; Nếu kí tự được chuyển đã là kí tự hoa thì không thay đổi. Ví dụ:\nchar c; c = \u0026#39;a\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; c = \u0026#39;A\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; Chuyển kí tự hoa thành thường c | \u0026#39; \u0026#39; Nếu kí tự được chuyển đã là kí tự thường thì không thay đổi. Ví dụ:\nchar c; c = \u0026#39;A\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; Đảo ngược kiểu kí tự c ^ \u0026#39; \u0026#39; Ví dụ:\nchar c; c = \u0026#39;A\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;A\u0026#39; Vị trí của kí tự trong bảng chữ cái //Đối với chữ thường c ^ \u0026#39;`\u0026#39; //Đối với chữ hoa c ^ \u0026#39;@\u0026#39; //Không phân biệt c \u0026amp; \u0026#34;\\x1F\u0026#34; Nhảm nhí khác Dùng XOR để mã hóa một chuỗi #include\u0026lt;iostream\u0026gt; #define key 5 int main(){ std::string s; std::cin \u0026gt;\u0026gt; s; //Mã hóa for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; //Giải mã for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; } Input: Hello Output: M`iij Hello Đổi hệ màu từ R5G5B5 sang R8G8B8 R8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) G8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) B8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) Viết xong cái này thì mình cũng sắp lú rồi, cảm ơn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/bitwise/","summary":"Sơ lược Phép thao tác trên bit Kí hiệu Mô tả AND \u0026amp; Cả hai bit là 1, trả về 1. Ngược lại trả về 0. OR \\ Một trong hai bit là 1, trả về 1. Ngược lại trả về 0. XOR ^ Hai bit khác nhau trả về 1. Ngược lại trả về 0. NOT ~ Đảo bit, 0 thành 1, 1 thành 0. Dịch trái - Shift left \u0026lt;\u0026lt; Dịch tất cả các bit sang trái.","title":"Ứng dụng của các phép thao tác bit"},{"content":"Bài toán Nguồn: Codewars Cho một số $n$ được nhập vào, việc của tụi mình là phân tích giai thừa của nó ra thừa số nguyên tố. Ví dụ:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Có 1 lưu ý nho nhỏ là giá trị của $n$ có thể lên tới 4000, tất nhiên, 4000! sẽ trở thành 1 con số không hề nhỏ, nó có hơn 12000 chữ số lận á! ∑(O_O;)\nLời giải Ý tưởng Theo định nghĩa, giai thừa của $n$, kí hiệu là $n!$, là tích của $n$ số dương đầu tiên với nhau:\n$$12! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12$$\nNhư vậy, phân tích $n!$ cũng đồng nghĩa với việc phân tích từng thừa số của $n!$ rồi nhân các kết quả lại với nhau. Ví dụ: với $n = 12$ mình có bảng phân tích ứng với từng thừa số sau:\n12! 2 3 4 5 6 7 8 9 10 11 12 decomp $2$ $3$ $2^2$ $5$ $2\\times3$ $7$ $2^3$ $3^2$ $2\\times5$ $11$ $2^2\\times3$ Sau khi nhân các kết quả lại, mình được kết quả cuối cùng là tích thừa số nguyên tố của $n!$ mà mình cần tìm $$2\\times3\\times2^2\\times5\\times2\\times3\\times7\\times2^3\\times3^2\\times2\\times5\\times11\\times2^2\\times3 = 2^{10}\\times3^5\\times5^2\\times7\\times11$$\nChương trình Bước đầu tiên, mình khởi tạo 2 mảng một chiêu để lưu tính nguyên tố và giá trị của các thừa số\nbool prime[n+1]; int value[n+1]; prime[0] = prime[1] = false; for(int i = 2; i \u0026lt;= n; i++){ prime[i] = true; value[i] = i; } Thông thường, mình dùng sàng Eratosthene để đánh dấu các số nguyên tố nhưng với một chút thay đổi, mình có thể phân tích một lượt các hợp số là bội của số nguyên tố tìm được. Như vậy sẽ tiết kiệm thời gian hơn so với mình phân tích từng số một rồi mới tổng hợp kết quả.\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ //Lưu ý: j = i+i chứ không còn là i*i f[j].prime = false; while(f[j].value % i == 0){ f[j].value /= i; power++; } } } } Sau cùng, mình thêm vào vài dòng hỗ trợ cho việc output là có thể submit\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ res += (\u0026#34; * \u0026#34; + std::to_string(i)); int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ prime[j] = false; while(value[j] % i == 0){ value[j] /= i; power++; } } if(power \u0026gt; 1) res += (\u0026#34;^\u0026#34; + std::to_string(power)); } } res.erase(res.begin(), res.begin()+3); return res; Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/factorialdecomp/","summary":"Bài toán Nguồn: Codewars Cho một số $n$ được nhập vào, việc của tụi mình là phân tích giai thừa của nó ra thừa số nguyên tố. Ví dụ:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Có 1 lưu ý nho nhỏ là giá trị của $n$ có thể lên tới 4000, tất nhiên, 4000! sẽ trở thành 1 con số không hề nhỏ, nó có hơn 12000 chữ số lận á!","title":"Phân tích thừa số nguyên tố của n!"},{"content":"Bài toán Nguồn: Codewars Đọc hiểu Cho một số dương $n$ \u0026gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nTrong đó: a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra Ví dụ:\nInput: n = 86240 Output: (2**5)(5)(7**2) Lời giải Để phân tích ra thừa số nguyên tố, mỉnh đem chia số đó cho ước nguyên tố nhỏ nhất của nó. Cứ tiếp tục như vậy cho đến khi thương = 1.\nVí dụ: n = 160\nN I 160 2 80 2 40 2 20 2 10 2 5 5 1 Với ý tưởng trên, mỉnh có đoạn code sau:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } } Mỉnh không cần phải tìm trước các số nguyên tố mà chỉ cần 1 dòng for từ 2 đến $\\sqrt{n}$ để xét tính chia hết là đủ. Bởi vì thương sẽ chia mãi cho đến khi không thể chia hết, đồng nghĩa với việc đã chia cả các hợp số nên không cần băn khoăn nữa UwU. Kết thúc vòng lặp thì lst là thừa số cuối cùng, nó có thể là 1 hoặc một số nguyên tố. Vì vậy, nếu nó khác 1 ta cần thêm vào chuỗi kết quả.\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Cảm ơn bạn vì đã đọc.\nBài viết liên quan: Phân tích thừa số nguyên tố của n! ","permalink":"https://yurukute.github.io/Blog/post/primesinnumbers/","summary":"Bài toán Nguồn: Codewars Đọc hiểu Cho một số dương $n$ \u0026gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nTrong đó: a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra Ví dụ:\nInput: n = 86240 Output: (2**5)(5)(7**2) Lời giải Để phân tích ra thừa số nguyên tố, mỉnh đem chia số đó cho ước nguyên tố nhỏ nhất của nó.","title":"Phân tích thừa số nguyên tố"},{"content":"Bài toán Nguồn: Codeforces Đọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\\sqrt{x}$ của nó phải là 1 số nguyên tố.\nNói cách khác, $x$ là t-prime nếu nó là bình phương của 1 số nguyên tố.\nTrong bài toán này, mình sẽ kiểm tra 1 dãy $n$ các số $x$ rằng $x_i$ có phải là t-prime hay không.\nVí dụ\nInput: 3 4 5 6 Output: YES NO NO Lời giải Đầu tiên, mình cần tìm tất cả các số nguyên tố từ 2 đến $\\sqrt{x}$ bằng sàng Eratosthene . X giới hạn đến $10^{12}$ nên $\\sqrt{x}$ lớn nhất sẽ là $10^6$.\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } Sau cùng, chỉ cần kiểm tra $\\sqrt{x}$ có phải là số nguyên (không phải số thập phân :v) và là số nguyên tố hay không. Đơn giản phải không nào? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/t-primes/","summary":"Bài toán Nguồn: Codeforces Đọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\\sqrt{x}$ của nó phải là 1 số nguyên tố.","title":"T-Primes"},{"content":"Bài toán: Nguồn: Codewars.com Đọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n$p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p Ví dụ:\nI = {12, 15}; //kết quả: \u0026#34;(2 12)(3 27)(5 15)\u0026#34; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:\nNếu số $i_j$ chia hết cho $p$ $sum$ += $i_j$ Lời giải Liệt kê các số nguyên tố Cách liệt kê nhanh nhất là dùng sàng Eratosthene . Chúng ta sẽ tìm tất cả các số nguyên tố nhỏ hơn giá trị tuyệt đối lớn nhất trong mảng (max). Vì vậy, việc đầu tiên cần làm sau khi nhập mảng là tìm max, lưu lại các số nguyên tố bé hơn max để dùng cho bước xử lí.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Bắt đầu xử lí for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Thế là xong! Ghép lại là có thể submit UwU.\nCảm ơn bạn vì đã đọc\n","permalink":"https://yurukute.github.io/Blog/post/sumbyfactors/","summary":"Bài toán: Nguồn: Codewars.com Đọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n$p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p Ví dụ:\nI = {12, 15}; //kết quả: \u0026#34;(2 12)(3 27)(5 15)\u0026#34; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:","title":"Sum by Factors"},{"content":"Bài toán: Nguồn: Codewars.com Cho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng. Nếu mảng chỉ có số âm, trả về $0$\nMột mảng rỗng sẽ được xem như có tổng lớn nhất là $0$. Lưu ý rằng mảng rỗng cũng là mảng con/đoạn con hợp lệ.\nLời giải Cách 1: Vét cạn Đây là cách dễ tiếp cận nhất với 2 bước:\nTìm tổng từng đoạn con {-2}, {1}, {-2, 1} \u0026hellip; So sánh các tổng để tìm ra kết quả lớn nhất. Tuy nhiên, với độ phức tạp là $O(n^3)$ cách này sẽ không giải quyết được vấn đề khi nó mang 3 nhược điểm rất lớn:\nLàm chậm quá trình xử lí do phải tính quá nhiều. Sẽ tồn tại những phép tính không cần thiết. Các hành động lặp đi lặp lại. Chính vì vậy, mình cần một giải pháp nhanh và tốt hơn!\nCách 2: mình gọi $f[i]$ là tổng $i$ phần tử đầu tiên, $f[i]$ được tính như sau: $f[0] = 0$ $f[i] = f[i-1] + a[i]$ Như vậy, tổng các phần tử từ $i$ đến $j$ là: $f[j] – f[i-1]$ Với cách này, mình sẽ tính được $f[i]$ mà không phải lặp lại việc tính toán vì mình đã tính trước ở $f[i-1]$ =\u0026gt; Không mắc nhược điểm thứ 3 của cách 1 (UwU). Vậy là giảm độ phức tạp xuống còn $O(n^2)$. Nhưng mà, bài toán này coàn có một cách giải với độ phức tạp $O(n)$ OwO)/\nCách 3: Với ý tưởng của cách 2, mình thêm một biến sum để lưu tổng đang tính. Khi duyệt mảng, mình sẽ đứng trước 2 lựa chọn: Thêm phần tử đang xét vào đoạn hay hắt đầu một đoạn con mới. Như vậy mình cần so sánh xem tổng hiện tại (sum) cộng thêm phần tử arr[i] đang xét liệu có lớn hơn phần tử đó hay không. Nói cách khác mình lấy max(sum + a[i], a[i]) -\u0026gt; Đây cũng chính là kết quả cần tìm.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Cảm ơn bạn vì đã đọc.\n","permalink":"https://yurukute.github.io/Blog/post/maxsubarraysum/","summary":"Bài toán: Nguồn: Codewars.com Cho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng.","title":"Đoạn Con Có Tổng Lớn Nhất"}]