[{"content":"Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \u0026quot;(2 12)(3 27)(5 15)\u0026quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:\n Nếu số $i_j$ chia hết cho $p$  $sum$ += $i_j$    Liệt kê các số nguyên tố Các liệt kê nhanh nhất là dùng sàng. Nhưng mà sàng đến bao nhiêu? Chính là sàng đến giá trị tuyệt đối lớn nhất trong số các phần tử của mảng I, gọi là max. Vì vậy, việc đầu tiến sau khi nhập mảng vào thì ta tìm max. Cách để sàng nguyên tố chắc ai cũng biết, không biết thì đây. Các số mình kiểm tra thì nhiều nhưng chỉ có vài trong số đó là số nguyên tố. Vì vậy, sau khi sàng xong, mình chỉ lưu lại những số nào là số nguyên tố thôi\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Bắt đầu xử lí for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Trong đoạn code trên, mình dùng một cái hàm to_string(). Đây là hàm mình tự viết. Bởi vì output ở dạng chuỗi nên mình cần phải chuyển p và sum về dạng chuỗi rồi gắn vào ans:\nstd::string to_string(int n){ std::string prefix = \u0026#34;\u0026#34;, s = \u0026#34;\u0026#34;; //Lưu lại dấu \u0026#34;-\u0026#34; nếu n là số âm  if(n \u0026lt; 0){ n *= -1; prefix = \u0026#34;-\u0026#34;; } while(n \u0026gt; 0){ int x = n % 10; n /= 10; //Đây là phép tách số từ sau ra trước. Vì vậy các số tách ra sau cần phải thêm vào hàng đầu.  s.insert(s.begin(), x+48); } return prefix+s; }; Thế là xong! Ghép lại là có thể submit UwU.\nTái bút Thật ra cái code này còn naive lắm. Submit xong sẽ thấy ngay nhiều solution code ngắn và sáng tạo. Mình thì bám váo cấu trúc của kata, tức là không import thêm thư viện nào vào, vì vậy mới phải viết thêm hàm to_string(). Nếu không có hàm đó thì code sẽ ngắn lại đáng kể đấy!\n","permalink":"https://yurukute.github.io/Blog/post/sumbyfactors/","summary":"Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026hellip; ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \u0026quot;(2 12)(3 27)(5 15)\u0026quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:","title":"Sum by Factors"},{"content":"Bài toán: Nguồn: Codewars.com\nCho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng. Nếu mảng chỉ có số âm, trả về $0$\nMột mảng rỗng sẽ được xem như có tổng lớn nhất là $0$. Lưu ý rằng mảng rỗng cũng là mảng con/đoạn con hợp lệ.\nLời giải Cách 1: Vét cạn Đây là cách dễ tiếp cận nhất với 2 bước:\n Tìm tổng từng đoạn con {-2}, {1}, {-2, 1} \u0026hellip; So sánh các tổng để tìm ra kết quả lớn nhất.  Tuy nhiên, với độ phức tạp là $O(n^3)$ cách này sẽ không giải quyết được vấn đề khi nó mang 3 nhược điểm rất lớn:\n Làm chậm quá trình xử lí do phải tính quá nhiều. Sẽ tồn tại những phép tính không cần thiết. Các hành động lặp đi lặp lại.  Chính vì vậy, ta cần một giải pháp nhanh và tốt hơn!\nCách 2:  Ta gọi $f[i]$ là tổng $i$ phần tử đầu tiên, $f[i]$ được tính như sau:  $f[0] = 0$ $f[i] = f[i-1] + a[i]$   Như vậy, tổng các phần tử từ $i$ đến $j$ là: $f[j] – f[i-1]$  Với cách này, ta sẽ tính được $f[i]$ mà không phải lặp lại việc tính toán vì ta đã tính trước ở $f[i-1]$ =\u0026gt; Không mắc nhược điểm thứ 3 của cách 1 (UwU). Vậy là giảm độ phức tạp xuống còn $O(n^2)$. Nhưng mà, bài toán này coàn có một cách giải với độ phức tạp $O(n)$ OwO)/\nCách 3: Với ý tưởng của cách 2, ta thêm một biến sum để lưu tổng đang tính. Khi duyệt mảng, ta sẽ đứng trước 2 lựa chọn: Thêm phần tử đang xét vào đoạn hay hắt đầu một đoạn con mới. Như vậy ta cần so sánh xem tổng hiện tại (sum) cộng thêm phần tử arr[i] đang xét liệu có lớn hơn phần tử đó hay không. Nói cách khác ta lấy max(sum + a[i], a[i]) -\u0026gt; Đây cũng chính là kết quả cần tìm.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Cảm ơn bạn vì đã đọc ","permalink":"https://yurukute.github.io/Blog/post/maxsubarraysum/","summary":"Bài toán: Nguồn: Codewars.com\nCho một dãy gồm n số nguyên $a_1, a_2,\u0026hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.\nInput: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng.","title":"Đoạn Con Có Tổng Lớn Nhất"},{"content":"","permalink":"https://yurukute.github.io/Blog/archive/","summary":"archive","title":"Lưu trữ"},{"content":"","permalink":"https://yurukute.github.io/Blog/search/","summary":"search","title":"Tìm kiếm"}]