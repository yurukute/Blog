<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Dynamic Programing on Noob&#39;s Blog</title>
    <link>https://yurukute.github.io/Blog/en/tags/dynamic-programing/</link>
    <description>Recent content in Dynamic Programing on Noob&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 09 Mar 2021 19:44:24 +0700</lastBuildDate><atom:link href="https://yurukute.github.io/Blog/en/tags/dynamic-programing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Longest increasing subsequence</title>
      <link>https://yurukute.github.io/Blog/en/post/lis/</link>
      <pubDate>Tue, 09 Mar 2021 19:44:24 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/lis/</guid>
      <description>Problem Source:
 Vietnamese:  Codeforces - Easy Can be solve with $O(n^2)$ solution Codeforces - Hard Need to be solved in $O(n\log n)$ solution   English:  Leetcode     Give an integer array nums. Return the length of the longest increasing subsequence.
An increasing subsequence is a subsequence $a_1,..,a_k$ that $$ \begin{align} &amp;amp;i_1 &amp;lt; i_2 &amp;lt; \dots &amp;lt; i_k,\\\ &amp;amp;nums[i_1] &amp;lt; nums[i_2] &amp;lt; \dots &amp;lt; nums[i_k] \end{align} $$ For example:</description>
    </item>
    
    <item>
      <title>Longest common subsequence</title>
      <link>https://yurukute.github.io/Blog/en/post/lcs/</link>
      <pubDate>Wed, 17 Feb 2021 20:36:47 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/lcs/</guid>
      <description>Problem Source: Codewars From Wikipedia  The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.
 Write a function lcs that accepts two strings and returns their longest common subsequence as a string. Performance matters.</description>
    </item>
    
    <item>
      <title>Explosive Sum</title>
      <link>https://yurukute.github.io/Blog/en/post/explosivesum/</link>
      <pubDate>Mon, 15 Feb 2021 18:49:58 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/explosivesum/</guid>
      <description>Problem Source: Codewars How many ways can you make the sum of a number?
From wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)#  In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. Example:
 Input: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Solution It would be very slow if you enumerate all the partitions when $n$ is large so i&amp;rsquo;ll use dynamic programing instead (Oω&amp;lt;)☆.</description>
    </item>
    
    <item>
      <title>Fibonacci</title>
      <link>https://yurukute.github.io/Blog/en/post/fibonacci/</link>
      <pubDate>Fri, 12 Feb 2021 04:39:49 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/fibonacci/</guid>
      <description>Problem Source: Codeforces Find the $n^th$ Fibonacci number modulo $10^9+7$. So, you need to find $F_n$ in the sequence defined as $$
\begin{aligned} F_0 &amp;amp; = 0\\ F_1 &amp;amp; = 1\\ F_i &amp;amp; = F_{i-1} + F_{i-2} (i &amp;gt;= 2) \end{aligned} $$ Example:
Input: 50 Output: 586268941 Solution Approach 1: Dynamic Programing Using fibonacci&amp;rsquo;s difference equation as a recurrence relation, i can write to a program like this:
int f0 = 0, f1 = 1, fn; for(int i = 2; i &amp;lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; This code&amp;rsquo;s complexity is $O(n)$ which is fine with $n &amp;lt;= 5.</description>
    </item>
    
    <item>
      <title>Total ways make change</title>
      <link>https://yurukute.github.io/Blog/en/post/countchange/</link>
      <pubDate>Tue, 09 Feb 2021 13:12:29 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/countchange/</guid>
      <description>Problem Source: Leetcode , Codewars You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.
For example:
Input: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We&amp;rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change.</description>
    </item>
    
    <item>
      <title>Fewest coins make change</title>
      <link>https://yurukute.github.io/Blog/en/post/coinchange/</link>
      <pubDate>Mon, 08 Feb 2021 15:29:18 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/coinchange/</guid>
      <description>Problem Source: Leetcode You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
You may assume that you have an infinite number of each kind of coin.
Examples:
Input: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11.</description>
    </item>
    
    <item>
      <title>Maximum subarray sum</title>
      <link>https://yurukute.github.io/Blog/en/post/maxsubarraysum/</link>
      <pubDate>Sun, 17 Jan 2021 20:45:26 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/maxsubarraysum/</guid>
      <description>Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:
maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</description>
    </item>
    
  </channel>
</rss>
