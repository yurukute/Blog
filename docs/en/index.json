[{"content":"Problem Source: Codewars Given an n x n array, return the array elements arranged from outermost elements to the middle element, traveling clockwise.\narray = [[1,2,3], [4,5,6], [7,8,9]] snail(array) #=\u0026gt; [1,2,3,6,9,8,7,4,5] For better understanding, please follow the numbers of the next array consecutively:\narray = [[1,2,3], [8,9,4], [7,6,5]] snail(array) #=\u0026gt; [1,2,3,4,5,6,7,8,9] This image will illustrate things more clearly:\nNOTE: The idea is not sort the elements from the lowest value to the highest; the idea is to traverse the 2-d array in a clockwise snailshell pattern.\nNOTE 2: The 0x0 (empty matrix) is represented as en empty array inside an array [[]].\nSolution This problem is simpler than its 4-kyuu label. To traverse in a snailshell pattern, I will traverse the 0th row, n-1th collumn, n-1th row, 1st collumn,.. respectively.\nFirst of all is to declare these variables:\nstd::vector\u0026lt;int\u0026gt; res; int row_start = 0; // Top-most row int col_start = 0; // Left-most collumn int row_end = snail_map.size(); // Bottom-most row int col_end = row_end; // Right-most collumn Start from the topmost row, increase the collumn index to traverse through it:\nfor (int i = col_start; i \u0026lt; col_end; i++) res.push_back(snail_map[row_start][i]); The same with the rightmost collumn, increase the row index to traverse. It should be noted that the top right element (snail_map[row_start][col_end-1]) has to be skipped since it has been read before.\nfor (int i = ++row_start; i \u0026lt; row_end; i++) res.push_back(snail_map[i][col_end-1]); Due to snailshell pattern, traversing the bottom-most row need to be done in backwards: decrease the collumn index instead of increasing. And because the bottom right element (snail_map[row_end-1][col_end-1]) has been read, the right most collumn will be skipped.\nfor (i = (--col_end)-1; i \u0026gt;= col_start; --i) res.push_back(snail_map[row_end-1][i]); Similarly, decrease the row index to traverse the left most collumn in backwards.\nfor (int i = (--row_end)-1; i \u0026gt;= row_start; --i) res.push_back(snail_map[i][col_start]); These operations will be looped until the given map is traversed, which means, row_start and row_end, or col_start and col_end, passed each others (_start $\\geq$ _end). Besides, an empty map case should be considered.\nif(snail_map.empty() || snail_map[0].empty()) return {}; With all that, the solution for this kata is completed.\n#include\u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; snail(const std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;snail_map){ if(snail_map.empty() || snail_map[0].empty()) return {}; std::vector\u0026lt;int\u0026gt; res; int row_start = 0; // Top-most row int col_start = 0; // Left-most collumn int row_end = snail_map.size(); // Bottom-most row int col_end = row_end; // Right-most collumn while (row_start \u0026lt;= row_end \u0026amp;\u0026amp; col_start \u0026lt;= col_end){ for (int i = col_start; i \u0026lt;= col_end; i++) res.push_back(snail_map[row_start][i]); for (int i = ++row_start; i \u0026lt;= row_end; i++) res.push_back(snail_map[i][col_end]); for (int i = --col_end; i \u0026gt;= col_start; i--) res.push_back(snail_map[row_end][i]); for (int i = row_end; i \u0026gt;= row_start; i--) res.push_back(snail_map[i][col_start]); col_start++; } return res; }; Also a solution If you are more familiar with while loop, here is how the solution could be rewritten:\nint row = 0, col = 0; while (row_start \u0026lt;= row_end \u0026amp;\u0026amp; col_start \u0026lt;= col_end) { while (col \u0026lt; col_end) res.push_back(snail_map[row][col++]); row_start++; while (row \u0026lt; row_end) res.push_back(snail_map[row++][col]); col_end--; while (col \u0026gt; col_start) res.push_back(snail_map[row][col--]); row_end--; while (row \u0026gt; row_start) res.push_back(snail_map[row--][col]); col_start++; } res.push_back(snail_map[row][col]); // Adding the last element Two variables row and col are used to mark the current row and collumn, the two variables only change from 0 to n-2. so that the next while could make use of current values of row and col without traverse through the same element twice, in other words, instead of skipping the read element, I will leave the last element of the current row/col. And because of this, it is a need to add the last element of the map after the while loop is done.\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/snail/","summary":"Problem Source: Codewars Given an n x n array, return the array elements arranged from outermost elements to the middle element, traveling clockwise.\narray = [[1,2,3], [4,5,6], [7,8,9]] snail(array) #=\u0026gt; [1,2,3,6,9,8,7,4,5] For better understanding, please follow the numbers of the next array consecutively:\narray = [[1,2,3], [8,9,4], [7,6,5]] snail(array) #=\u0026gt; [1,2,3,4,5,6,7,8,9] This image will illustrate things more clearly:\nNOTE: The idea is not sort the elements from the lowest value to the highest; the idea is to traverse the 2-d array in a clockwise snailshell pattern.","title":"Snail"},{"content":"Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:\nIn many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as \u0026lsquo;ice puzzle\u0026rsquo;:\nYou have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you\u0026rsquo;ll keep sliding in the direction you\u0026rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:\nYou will be given an M x N well-formed rectanglar ASCII map of the form:\nvar map = \u0026#39;\\ x \\n\\ # \\n\\ E \\n\\ # \\n\\ # \\n\\ S #\u0026#39;; /* Player starts at the start, and ends by reaching the end. legend: S: start (slippery, only 1 exists) E: end (non-slippery, only 1 exists) : slippery tile x: non-slippery tile #: obstacles (You can\u0026#39;t go past map edges, which serves as the walls of the puzzle.) */ Your solver should find the optimal solution (minimal number of moves, as in, the amount of times you make a step), and return an array of directions: 'u', 'd', 'l', 'r' for up/down/left/right respectively. So for the example map above, you should return ['u', 'r', 'd', 'l', 'u', 'r']. If there are multiple solutions with the same amount of steps, tiebreak by least distance traversed. If there are still ties, just return any one of them.\nAlso, you might be passed some maps which does not admit any solutions. In this case, return null.\nSolution The maze is read as a string, using graph hurts my brain as well as I\u0026rsquo;m too lazy to transform it into matrix so, let it be. As an example:\n\u0026#34; x \\n\u0026#34; \u0026#34; # \\n\u0026#34; \u0026#34; E \\n\u0026#34; \u0026#34; # \\n\u0026#34; \u0026#34; # \\n\u0026#34; \u0026#34;S #\u0026#34; Consider this maze as a matrix, it\u0026rsquo;s columns equal to position of '\\n' + 1 besides, this is a numbered matrix, starts from 0.\nConspicuously, if current cell is at position i, it\u0026rsquo;s 4 adjacent cells would be:\nUpper cell: i - col Lower cell: i + col Left cell: i - 1 Right cecll: i + 1 Thus, a while loop is used to find a move\u0026rsquo;s destination:\n#define UP 0 #define DOWN 1 #define LEFT 2 #define RIGHT 3 int next_tile(const std::string \u0026amp;map, int col, int curr, char dir) { int row = (map.length() + 1) / col; while (map[curr] != \u0026#39;E\u0026#39; \u0026amp;\u0026amp; is_valid(curr, dir, col, row)) { int next; switch (dir) { case UP: next = curr - col; break; case DOWN: next = curr + col; break; case LEFT: next = curr - 1; break; default: next = curr + 1; break; } if (map[next] == \u0026#39;#\u0026#39;) return curr; if (map[next] == \u0026#39;x\u0026#39;) return next; curr = next; } return curr; } is_valid function is responsible for ensuring the movement doesn\u0026rsquo;t go out of the maze\u0026rsquo;s walls\nbool is_valid(int pos, char dir, int col, int row) { switch (dir) { case UP: return pos \u0026gt;= col; case DOWN: return pos \u0026lt;= col * (row - 1) - 1; case LEFT: return pos % col != 0; } return (pos - col + 2) % col != 0; } The main algorithm for this kata is breadth first search (depth first search is possible, however, it can not take care of the bigger maze). When traverse a cell, calculate it\u0026rsquo;s destinations (next) for each of 4 directions, then push them to queue. There are 2 case would occur: There is another path which leads to next and there is none.\nIf another path exists, next would not be pushed to queue but its path would be updated so that the solution is an optimal one. Init precell array to store cells\u0026rsquo; previous cell, -1 as default, to supports tracing back a path from start to any cell.\nMoreover, pay attention to avoid adding start cell into queue, which causes infinite loop.\nstd::vector\u0026lt;char\u0026gt; ice_maze_solver(const std::string \u0026amp;map) { int col = map.find(\u0026#34;\\n\u0026#34;) + 1, start = map.find(\u0026#34;S\u0026#34;), end = map.find(\u0026#34;E\u0026#34;); bool solvable = false; std::vector\u0026lt;char\u0026gt; solution; std::vector\u0026lt;int\u0026gt; precell(map.length(), -1); std::queue\u0026lt;int\u0026gt; queue; queue.push(start); while (!queue.empty()) { int curr = queue.front(); queue.pop(); if(curr == end){ solvable = true; continue; } for (int i = 0; i \u0026lt; 4; i++) { int next = next_tile(map, col, curr, i); if (next != curr \u0026amp;\u0026amp; next != precell[curr]) { if(precell[next] != -1){ update_path(precell, col, curr, next); } else if (next != start){ precell[next] = curr; queue.push(next); } } } } if (solvable){ while (end != start) { char move; if ((precell[end] - end) % col == 0) move = (precell[end] \u0026gt; end) ? \u0026#39;u\u0026#39; : \u0026#39;d\u0026#39;; else move = (precell[end] \u0026gt; end) ? \u0026#39;l\u0026#39; : \u0026#39;r\u0026#39;; solution.insert(solution.begin(), move); end = precell[end]; } } return solution; } The path is updated through 2 factors:\nNumber of steps Total path length, where: The distance between 2 cells in the same horizontal row is $|i-j|$ If they\u0026rsquo;re in the same vertical row: $\\dfrac{|i-j|}{col}$ std::vector\u0026lt;int\u0026gt; get_length( std::vector\u0026lt;int\u0026gt; const \u0026amp;parent, const int col, int curr) { int length = 0; int step = 0; while (parent[curr] != -1) { step++; length += abs(parent[curr] - curr) / ((parent[curr] - curr) % col == 0 ? col : 1); curr = parent[curr]; } return {step, length}; } void update_path(std::vector\u0026lt;int\u0026gt; \u0026amp;parent, const int col, int curr, int next) { auto oldPath = get_length(parent, col, next); auto newPath = get_length(parent, col, curr); newPath[0] += 1; newPath[1] += abs(curr - next) / ((curr - next) % col == 0 ? col : 1); if (newPath \u0026lt; oldPath) { parent[next] = curr; } } Thank you for reading this amateur solution, I did this kata just because it is related to pokemon series, nothing else.\n","permalink":"https://yurukute.github.io/Blog/en/post/warningice/","summary":"Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:\nIn many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as \u0026lsquo;ice puzzle\u0026rsquo;:\nYou have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you\u0026rsquo;ll keep sliding in the direction you\u0026rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:","title":"ASCII Games: Warning: Ice!"},{"content":"Problem Source: Codewars We need to sum big numbers and we require your help.\nWrite a function that returns the sum of two numbers. The input numbers are strings and the function must return a string.\nExample\nadd(\u0026#34;123\u0026#34;, \u0026#34;321\u0026#34;); -\u0026gt; \u0026#34;444\u0026#34; add(\u0026#34;11\u0026#34;, \u0026#34;99\u0026#34;); -\u0026gt; \u0026#34;110\u0026#34; Notes\nThe input numbers are big. The input is a string of only digits The numbers are positives Solution In arithmetic, addition can be performed by aligning the addends vertically and add the colums, starting from the unit colum (on the right). $$ \\begin{aligned} 105 \\\\ +\\quad6\\\\ \\hline 111\\\\ \\end{aligned} $$ To simulate the steps, traverse two adden-strings from the last position, add their digits then append the sum to the result string. Because of the length difference and right alignment, the position is length - i for i in range 1 to length\nInitialize carry = 0 to store the extra digit if a column exceeds 9, this is then transferred to the next column or appended into the result string after calculated all the colums.\n#include \u0026lt;string\u0026gt; std::string add(const std::string\u0026amp; a, const std::string\u0026amp; b) { std::string res = \u0026#34;\u0026#34;; int len_a = a.length(), len_b = b.length(), n = std::max(len_a, len_b); int carry = 0; for(int i = 1; i \u0026lt;= n; i++){ if(i \u0026lt;= lenA) carry += a[lenA - i] - \u0026#39;0\u0026#39;; if(i \u0026lt;= lenB) carry += b[lenB - i] - \u0026#39;0\u0026#39;; res.insert(res.begin(), carry % 10 + \u0026#39;0\u0026#39;); carry /= 10; } res.insert(res.begin(), carry + \u0026#39;0\u0026#39;); while(res.length() \u0026gt; 1 \u0026amp;\u0026amp; res.front() == \u0026#39;0\u0026#39;) res.erase(res.begin()); return res; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/addingbignumbers/","summary":"Problem Source: Codewars We need to sum big numbers and we require your help.\nWrite a function that returns the sum of two numbers. The input numbers are strings and the function must return a string.\nExample\nadd(\u0026#34;123\u0026#34;, \u0026#34;321\u0026#34;); -\u0026gt; \u0026#34;444\u0026#34; add(\u0026#34;11\u0026#34;, \u0026#34;99\u0026#34;); -\u0026gt; \u0026#34;110\u0026#34; Notes\nThe input numbers are big. The input is a string of only digits The numbers are positives Solution In arithmetic, addition can be performed by aligning the addends vertically and add the colums, starting from the unit colum (on the right).","title":"Adding Big Numbers"},{"content":"Problem Source: Codewars Synopsis A multi-floor building has a Lift in it.\nPeople are queued on different floors waiting for the Lift.\nSome people want to go up. Some people want to go down.\nThe floor they want to go to is represented by a number (i.e. when they enter the Lift this is the button they will press)\nBEFORE (people waiting in queues) AFTER (people at their destinations) +--+ +--+ /----------------| |----------------\\ /----------------| |----------------\\ 10| | | 1,4,3,2 | 10| 10 | | | |----------------| |----------------| |----------------| |----------------| 9| | | 1,10,2 | 9| | | | |----------------| |----------------| |----------------| |----------------| 8| | | | 8| | | | |----------------| |----------------| |----------------| |----------------| 7| | | 3,6,4,5,6 | 7| | | | |----------------| |----------------| |----------------| |----------------| 6| | | | 6| 6,6,6 | | | |----------------| |----------------| |----------------| |----------------| 5| | | | 5| 5,5 | | | |----------------| |----------------| |----------------| |----------------| 4| | | 0,0,0 | 4| 4,4,4 | | | |----------------| |----------------| |----------------| |----------------| 3| | | | 3| 3,3 | | | |----------------| |----------------| |----------------| |----------------| 2| | | 4 | 2| 2,2,2 | | | |----------------| |----------------| |----------------| |----------------| 1| | | 6,5,2 | 1| 1,1 | | | |----------------| |----------------| |----------------| |----------------| G| | | | G| 0,0,0 | | | |====================================| |====================================| Rules Lift Rules The Lift only goes up or down!\nEach floor has both UP and DOWN Lift-call buttons (except top and ground floors which have only DOWN and UP respectively)\nThe Lift never changes direction until there are no more people wanting to get on/off in the direction it is already travelling\nWhen empty the Lift tries to be smart. For example,\nIf it was going up then it may continue up to collect the highest floor person wanting to go down If it was going down then it may continue down to collect the lowest floor person wanting to go up The Lift has a maximum capacity of people\nWhen called, the Lift will stop at a floor even if it is full, although unless somebody gets off nobody else can get on!\nIf the lift is empty, and no people are waiting, then it will return to the ground floor\nPeople Rules People are in \u0026ldquo;queues\u0026rdquo; that represent their order of arrival to wait for the Lift\nAll people can press the UP/DOWN Lift-call buttons\nOnly people going the same direction as the Lift may enter it\nEntry is according to the \u0026ldquo;queue\u0026rdquo; order, but those unable to enter do not block those behind them that can\nIf a person is unable to enter a full Lift, they will press the UP/DOWN Lift-call button again after it has departed without them\nKata Task Get all the people to the floors they want to go to while obeying the Lift rules and the People rules\nReturn a list of all floors that the Lift stopped at (in the order visited!)\nNOTE: The Lift always starts on the ground floor (and people waiting on the ground floor may enter immediately)\nI/O Input queues a list of queues of people for all floors of the building.\nThe height of the building varies\n0 = the ground floor\nNot all floors have queues\nQueue index [0] is the \u0026ldquo;head\u0026rdquo; of the queue\nNumbers indicate which floor the person wants go to\ncapacity: maximum number of people allowed in the lift\nParameter validation - All input parameters can be assumed OK. No need to check for things like:\nPeople wanting to go to floors that do not exist People wanting to take the Lift to the floor they are already on Buildings with \u0026lt; 2 floors Basements Output A list of all floors that the Lift stopped at (in the order visited!)\nExample Refer to the example test cases.\nqueues = { {}, {0}, {}, {}, {2}, {3}, {} }; result = {0, 5, 4, 3, 2, 1, 0}; Solution The lift is only stop when the lift is empty, and no people are waiting.Thus, until that moment, the lift will repeat these actions:\nGo up: Because The Lift always starts on the ground floor, the first thing it does is going up. Go down: Happens after the lift have reached the top floor. For each $i$ floor:\nRemove the people inside the lift if their wanted floor is $i$th bool remove_people(std::vector\u0026lt;int\u0026gt; *lift, int floor){ bool stop = false; for (auto person = lift-\u0026gt;begin(); person != lift-\u0026gt;end(); person++){ if (*person == floor){ lift-\u0026gt;erase(person--); stop = true; } } return stop; } Add all the people whose wanted floor is in the same direction to the lift until the lift is full. bool add_people(std::vector\u0026lt;int\u0026gt; *lift, std::vector\u0026lt;int\u0026gt; *people, int floor, int capacity, int direction){ bool stop = false; for(auto person = people-\u0026gt;begin(); person != people-\u0026gt;end(); person++){ if((*person \u0026gt; floor \u0026amp;\u0026amp; direction == UP) || (*person \u0026lt; floor \u0026amp;\u0026amp; direction == DOWN)){ stop = true; if(int(lift-\u0026gt;size()) \u0026lt; capacity){ lift-\u0026gt;push_back(*person); people-\u0026gt;erase(person--); } } } return stop; } If one of those action performed, store $i$ into result vector. #include \u0026lt;vector\u0026gt; #define UP 1 #define DOWN 0 bool remove_people(std::vector\u0026lt;int\u0026gt; *lift, int floor){...} bool add_people(std::vector\u0026lt;int\u0026gt; *lift, std::vector\u0026lt;int\u0026gt; *people, int floor, int capacity, int direction){...} std::vector\u0026lt;int\u0026gt; the_lift(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; queues, int capacity) { std::vector\u0026lt;int\u0026gt; res = {0}, lift; int top = queues.size(); bool unfinish = true; while(unfinish){ unfinish = false; for(int floor = 0; floor \u0026lt; top; floor++){ bool stop = remove_people(\u0026amp;lift, floor); stop = add_people(\u0026amp;lift, \u0026amp;queues[floor], floor, capacity, UP) || stop; if(!queues[floor].empty()) unfinish = true; if(stop \u0026amp;\u0026amp; res.back() != floor) res.push_back(floor); } for(int floor = top-1; floor \u0026gt;= 0; floor--){ bool stop = remove_people(\u0026amp;lift, floor); stop = add_people(\u0026amp;lift, \u0026amp;queues[floor], floor, capacity, DOWN) || stop; if(!queues[floor].empty()) unfinish = true; if(stop \u0026amp;\u0026amp; res.back() != floor) res.push_back(floor); } } if(res.back()) res.push_back(0); return res; } ","permalink":"https://yurukute.github.io/Blog/en/post/thelift/","summary":"Problem Source: Codewars Synopsis A multi-floor building has a Lift in it.\nPeople are queued on different floors waiting for the Lift.\nSome people want to go up. Some people want to go down.\nThe floor they want to go to is represented by a number (i.e. when they enter the Lift this is the button they will press)\nBEFORE (people waiting in queues) AFTER (people at their destinations) +--+ +--+ /----------------| |----------------\\ /----------------| |----------------\\ 10| | | 1,4,3,2 | 10| 10 | | | |----------------| |----------------| |----------------| |----------------| 9| | | 1,10,2 | 9| | | | |----------------| |----------------| |----------------| |----------------| 8| | | | 8| | | | |----------------| |----------------| |----------------| |----------------| 7| | | 3,6,4,5,6 | 7| | | | |----------------| |----------------| |----------------| |----------------| 6| | | | 6| 6,6,6 | | | |----------------| |----------------| |----------------| |----------------| 5| | | | 5| 5,5 | | | |----------------| |----------------| |----------------| |----------------| 4| | | 0,0,0 | 4| 4,4,4 | | | |----------------| |----------------| |----------------| |----------------| 3| | | | 3| 3,3 | | | |----------------| |----------------| |----------------| |----------------| 2| | | 4 | 2| 2,2,2 | | | |----------------| |----------------| |----------------| |----------------| 1| | | 6,5,2 | 1| 1,1 | | | |----------------| |----------------| |----------------| |----------------| G| | | | G| 0,0,0 | | | |====================================| |====================================| Rules Lift Rules The Lift only goes up or down!","title":"TheLift"},{"content":"Problem Source: Codewars A Hamming number is a positive integer of the form 2i3j5k, for some non-negative integers i, j, and k.\nWrite a function that computes the nth smallest Hamming number.\nSpecifically:\nThe first smallest Hamming number is 1 = 203050 The second smallest Hamming number is 2 = 213050 The third smallest Hamming number is 3 = 203150 The fourth smallest Hamming number is 4 = 223050 The fifth smallest Hamming number is 5 = 203051 The 20 smallest Hamming numbers are given in example test fixture.\nYour code should be able to compute all of the smallest 5,000 (Clojure: 2000, NASM: 13282) Hamming numbers without timing out.\nSolution Brute force The simplest method is to check wether a number from $2$ on is Hamming number or not, then increase counter until the nth Hamming number is found. To check if a number is a Hamming number relies on its traits:\nHamming number is the product of the exponents of 2, 3 and 5. 2, 3 and 5 are prime numbers. In other words, checking the number can be achieved by factoring it and the factoring process stopping only at 5, if the leftover is equal to 1, which means there\u0026rsquo;s no other factors, that\u0026rsquo;s a Hamming number.\n#include \u0026lt;cstdint\u0026gt; int isHamber(uint64_t n){ for(int i = 2; i \u0026lt;= 5; i++) while (n % i == 0) n /= i; return n == 1; } uint64_t hamber(int n){ uint64_t res = 0; int count = 0; while(count \u0026lt; n){ res++; if(isHamber(res)) count++; } return res; } However, this method is time consuming, especially when there\u0026rsquo;s specific requirement\nYour code should be able to compute all of the smallest 5,000 (Clojure: 2000, NASM: 13282) Hamming numbers without timing out.\nDynamic programing Because of being the product of the exponents of 2, 3 and 5, Hamming number can be decomposed into a smaller Hamming number and 2, 3 or 5. $$ 2^ỉ3^j5^k = \\Bigg[ \\begin{array}{1} 2^{i-1}3^j5^k \\times 2 \\\\ 2^i3^{j-1}5^k \\times 3 \\\\ 2^i3^j5^{k-1} \\times 5 \\\\ \\end{array} $$ Thus, Hamming seqsequence can be formed by this: $$ \\begin{cases} H_1 = 1 \\\\ H_x = min(H_i \\times 2, H_j \\times 3, H_k \\times 5) \\end{cases} $$ where $i, j, k$ are Hamming seqsequence\u0026rsquo;s indexes ($i, j, k \u0026lt; x$). They are counted from $1$ and increased only when the multiple of the Hamming number in the corresponding positions is added to the seqsequence. For example:\n$H_2 = min(H_1 \\times 2, H_1 \\times 3, H_1 \\times 5) = min(1 \\times 2, 1 \\times 3, 1 \\times 5) = 2$\n$\\Rightarrow$ $i$ is increased by one for $H_i \\times 2$ is chosen: $i = 2$.\n$H_3 = min(H_2 \\times 2, H_1 \\times 3, H_1 \\times 5) = min(2 \\times 2, 1 \\times 3, 1 \\times 5) = 3$\n$\\Rightarrow$ $j$ is increased by one.\n\u0026hellip;\n$H_6 = min(H_3 \\times 2, H_2 \\times 3, H_2 \\times 5) = min(3 \\times 2, 2 \\times 3, 2 \\times 5) = 6$\n$\\Rightarrow$ $i$ and $j$ are increased by one.\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;algorithm\u0026gt; uint64_t hamber(int n){ uint64_t hambers[13282], next2 = 2, next3 = 3, next5 = 5; int i = 0, j = 0, k = 0; hambers[0] = 1; for(int x = 1; x \u0026lt; n; x++){ hambers[x] = std::min(std::min(next2, next3), next5); if(hambers[x] == next2) next2 = hambers[++i]*2; if(hambers[x] == next3) next3 = hambers[++j]*3; if(hambers[x] == next5) next5 = hambers[++k]*5; } return hambers[n-1]; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/hammingnumber/","summary":"Problem Source: Codewars A Hamming number is a positive integer of the form 2i3j5k, for some non-negative integers i, j, and k.\nWrite a function that computes the nth smallest Hamming number.\nSpecifically:\nThe first smallest Hamming number is 1 = 203050 The second smallest Hamming number is 2 = 213050 The third smallest Hamming number is 3 = 203150 The fourth smallest Hamming number is 4 = 223050 The fifth smallest Hamming number is 5 = 203051 The 20 smallest Hamming numbers are given in example test fixture.","title":"Hamming Number"},{"content":"Problem If n is the numerator and d the denominator of a fraction, that fraction is defined a reduced fraction if and only if GCD(n,d)==1.\nFor example $\\displaystyle\\frac{5}{16}$ is a reduced fraction, while $\\displaystyle\\frac{5}{16}$ is not, as both 6 and 16 are divisible by 2, thus the fraction can be reduced to $\\displaystyle\\frac{3}{8}$.\nNow, if you consider a given number d, how many reduced fractions can be built using d as a denominator?\nFor example, let\u0026rsquo;s assume that d is 15: you can build a total of 8 different proper fractions between 0 and 1 with it: $$\\displaystyle\\frac{1}{15},\\frac{2}{15},\\frac{4}{15},\\frac{7}{15},\\frac{8}{15},\\frac{11}{15},\\frac{13}{15},\\frac{14}{15}$$\nYou are to build a function that computes how many proper fractions you can build with a given denominator:\nproperFractions(1) == 0 properFractions(2) == 1 properFractions(5) == 4 properFractions(15) == 8 properFractions(25) == 20 Be ready to handling big numbers.\n(Author used proper instead of reduced, which is improper, by mistake)\nSolution Brute force This problem can be solved with brute force method: For each $n \\leq d$, compute their GCD and increase counter by one if GCD = 1. GCD (Greatest common divisor) of two intergers is computed by Euclid\u0026rsquo;s algorithm.\nlong gcd(long a, long b) { while(b){ int t = a % b; a = b; b = t; } return a; } long properFractions(long d) { int count = 0; for(int n = 1; n \u0026lt; d; n++) if(gcd(n,d) == 1) count++; return count; } However, $d$ is mentioned to mightly be a big number so this approach can\u0026rsquo;t be used.\nEuler\u0026rsquo;s totient function Because this problem only consider proper fractions ($n \u0026lt; d$), the problem become Computing Euler's totient function of d.\nIn number theory, Euler\u0026rsquo;s totient function counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It is written using the Greek letter phi as $\\phi (n)$ or $\\varphi (n)$, and may also be called Euler\u0026rsquo;s phi function.\nWikipedia Euler\u0026rsquo;s product formula: $$\\begin{aligned} \\phi(n) \u0026amp;= n \\times (1 - \\frac{1}{p_1}) \\times (1 - \\frac{1}{p_2}) \\times\u0026hellip;\\times (1 - \\frac{1}{p_k})\\\\ \u0026amp;= n\\prod_{i=1}^k(1 - \\frac{1}{p_i}) \\end{aligned}$$\nwhere $p_i$ is the distinct prime numbers dividing $n$.\nHad combined prime factor decomposition of n algorithm with the formula above, I got solution for this:\nlong properFractions(long n) { if(n == 1) return 0; long res = n; for(long i = 2; i*i \u0026lt;= n; i++){ if(n % i == 0){ while (n % i == 0) n /= i; res -= res/i; } } if (n \u0026gt; 1) res -= res/n; return res; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/reducedfractions/","summary":"Problem If n is the numerator and d the denominator of a fraction, that fraction is defined a reduced fraction if and only if GCD(n,d)==1.\nFor example $\\displaystyle\\frac{5}{16}$ is a reduced fraction, while $\\displaystyle\\frac{5}{16}$ is not, as both 6 and 16 are divisible by 2, thus the fraction can be reduced to $\\displaystyle\\frac{3}{8}$.\nNow, if you consider a given number d, how many reduced fractions can be built using d as a denominator?","title":"Number of reduced fractions with denominator d"},{"content":"Problem Source: Codewars In number theory, the Carmichael function of a positive integer $n$, denoted $\\lambda(n)$, is defined as the smallest positive integer m such that $$a^m \\equiv 1 \\mod n$$ for every integer $a \\leq n$ that is coprime to $n$. The Carmichael function is also known as the reduced totient function (as it is linked to Euler Totient function) or the least universal exponent function. The Carmichael function is important in number theory.\nFor example let $n = 8$. The list of integer $a \\leq 8$, coprime to $8: 1, 3, 5, 7.$ $$ \\begin{aligned} 1^1 \\equiv 1 \\mod 8 \\\\ 3^1 \\equiv 3 \\mod 8 \\\\ \\end{aligned} $$ So $\\lambda(8) \u0026gt; 1.$ $$ \\begin{aligned} 1^2 \\equiv 1 \\mod 8 \\\\ 3^2 \\equiv 1 \\mod 8 \\\\ 5^2 \\equiv 1 \\mod 8 \\\\ 7^2 \\equiv 1 \\mod 8 \\\\ \\end{aligned} $$\nSo $\\lambda(8) = 2.$\nThere is generally two approach to this function:\nIteratively checking $a^m \\equiv 1 \\mod n$ for growing $m$ and every $a \\leq n$, coprime to $n$. This may not work for big numbers.\nUsing an exact formula like for Euler Totient. This is an explicit formula for calculating $\\lambda(n)$ depending on the prime decomposition of $n$.\nFor the second method the formula is deduced from the lcm formula for $\\lambda$ and the totient function (see the associated kata):\nlcm formula, where $p_1,\u0026hellip;,p_n$ are the prime factor of $n$, $w_1,\u0026hellip;,w_n$, the powers associated.: $$ \\begin{aligned} \\lambda(n) \u0026amp; = \\lambda(p_1^{w_1} \\times p_2^{w_2} \\times \u0026hellip; \\times p_n^{w_n}) \\\\ \\lambda(n) \u0026amp; = lcm(\\lambda(p_1^{w_1}), \\lambda(p_2^{w_2}),\u0026hellip;, \\lambda(p_n^{w_n})) \\\\ \\end{aligned} $$ Then for p prime, we have a link between $\\lambda(p^w)$ and $\\phi(p^w)$, the Euler Totient function: $$ \\begin{aligned} \\lambda(p^w) \u0026amp;= \\phi(p^w) \u0026amp; p \u0026amp;\u0026gt; 2\\\\ \\lambda(p^w) \u0026amp;= \\phi(p^w) \u0026amp; p \u0026amp;= 2, w \u0026lt; 3\\\\ \\lambda(p^w) \u0026amp;= \\frac{1}{2} \\phi(p^w)\t\u0026amp; p \u0026amp;= 2, w \\geq 3 \\end{aligned} $$ You have to code Carmichael function, that take an integer $1 ≤ n$ as input and return $\\lambda(n)$. You also have to check if $n$ is a number, integer and that $1 ≤ n$, if it is not the case, the function should return 0.\nInput range: $1 ≤ n ≤ 1e10$\nSolution Euler Totient function of $n = p_1^{w_1} \\times p_2^{w_2} \\times\u0026hellip;\\times p_k^{w_n}$ is calculated by formula: $$ \\phi(n) = n \\times (1 - \\frac{1}{p_1}) \\times (1 - \\frac{1}{p_2}) \\times\u0026hellip;\\times (1 - \\frac{1}{p_k}) $$\nGiven $n = p^w$, the fomula can be rewritten: $$ \\phi(n) = p^w \\times (1 - \\frac{1}{p}) = p^{w-1} \\times (p-1)$$\nAssociate prime factorization of n with finding their $\\lambda$ via $\\phi$ i have the code:\n#include \u0026lt;vector\u0026gt; #include \u0026lt;math.h\u0026gt; long long Carmichael(long long n){ if (n \u0026lt; 1) return 0; if (n == 1) return 1; std::vector\u0026lt;long long\u0026gt; factors; for(long long i = 2; i*i \u0026lt;= n; i += 2){ long long w = 0; while(n % i == 0){ w++; n /= i; } if (i == 2 \u0026amp;\u0026amp; w \u0026gt;= 3) factors.push_back((pow(i, w-1) * (i-1))/2); else if(i \u0026gt;= 2 \u0026amp;\u0026amp; w \u0026gt; 0) factors.push_back(pow(i, w-1) * (i-1)); if(i == 2) i--; } if(n != 1) factors.push_back(n-1); } I now have the result of $\\lambda(p_1^{w_1}), \\lambda(p_2^{w_2}),\u0026hellip;, \\lambda(p_n^{w_n})$. Last step is caculating their least common multipler. The simpliest method is divide their product by their greatest common divisor: $$ LCM(a, b) = \\frac{a \\times b}{GCD(a,b)} = a \\times \\frac{b}{GCD(a, b)} $$\nBy a represent needed result and b, the element $\\lambda(p_i^{w_i})$ in factors, I can operate a loop like this:\nlong long res = 1; for(auto i : factors) res *= i/gcd(res, i); return res; gcd function with Euclid algorithm long long gcd(int a, int b) { while(b){ long long t = a % b; a = b; b = t; } return a; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/carmichael/","summary":"Problem Source: Codewars In number theory, the Carmichael function of a positive integer $n$, denoted $\\lambda(n)$, is defined as the smallest positive integer m such that $$a^m \\equiv 1 \\mod n$$ for every integer $a \\leq n$ that is coprime to $n$. The Carmichael function is also known as the reduced totient function (as it is linked to Euler Totient function) or the least universal exponent function. The Carmichael function is important in number theory.","title":"Carmichael function"},{"content":"Problem Source: Codewars Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.\nIntervals Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.\nOverlapping Intervals List containing overlapping intervals:\n[ [1,4], [7, 10], [3, 5] ] The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.\nFor examples:\nsum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u0026gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u0026gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u0026gt; 19 Solution Notice that, if an interval\u0026rsquo;s left point is smaller than its preceding\u0026rsquo;s right point, they\u0026rsquo;re overlapping. There\u0026rsquo;re two cases:\nThis interval\u0026rsquo;s head is another\u0026rsquo;s tail. For example: [1, 4] \u0026amp; [3, 5] The second interval\u0026rsquo;s right point is greater than the first one\u0026rsquo;s The merged interval: [1, 5] This interval is included by another. For example: [1, 5] \u0026amp; [2, 4] The second interval\u0026rsquo;s right point is smaller than the first one\u0026rsquo;s The merged interval is the first one: [1, 5] First, i need to sort intervals ascending by left points for not missing any overlapping interval which leads to an unexpected result. Using merged array to save the merged intervals, merged.back() serves as the right point of the considering interval\u0026rsquo;s preceding. If the considering interval is overlapping with its preceding, update the preceding\u0026rsquo;s right point - merged.back() - accordingly. Otherwise, add the considering interval into merged.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;algorithm\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { int size = intervals.size(); std::sort(intervals.begin(), intervals.end()); std::vector\u0026lt;std::pair\u0026lt;int,int\u0026gt;\u0026gt; merged = {{intervals[0].first, inttervals[0].second}}; for(int i = 1; i \u0026lt; size; i++){ if(intervals[i].first \u0026lt;= merged.back().second) //Overlapping if (intervals[i].second \u0026gt;= merged.back().second) // Case (1) merged.back().second = intervals.second; else continue; // Case (2) else merged.push_back(intervals[i]); // Not overlapping } int res = 0; for(const auto \u0026amp;i : merged) res += i.second - i.first; return res; } Improving Call x the right point of considering interval\u0026rsquo;s preceding (means it has merged.back().second\u0026rsquo;s value). Still with two cases but change the order:\nIf the considering interval\u0026rsquo;s right point is greater than or equal to x: If its left point is smaller than x, they\u0026rsquo;re overlapping in case (1) If its left point is greater than x, they\u0026rsquo;re not overlapping Either they\u0026rsquo;re overlapping or not, x\u0026rsquo;s value will need to be updated to the considering\u0026rsquo;s right point Otherwise, if it\u0026rsquo;s smaller than x, they\u0026rsquo;re overlapping in case (2). Which means i can skip. In this method i only need an if and not using merged made the code looks more simple.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;algorithm\u0026gt; int sum_intervals(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; intervals) { std::sort(intervals.begin(), intervals.end()); int x = intervals[0].first, res = 0; for (auto \u0026amp;i : intervals){ if (i.second \u0026gt;= x){ res += i.second - (i.first \u0026gt; x ? i.first : x); x = i.second; } } return res; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/sumofintervals/","summary":"Problem Source: Codewars Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.\nIntervals Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.","title":"Sum of intervals"},{"content":"The problem Source: Codewars Create a RomanNumerals class that can convert a roman numeral to and from an integer value.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; class RomanHelper{ public: std::string to_roman(unsigned int n){ } int from_roman(std::string rn){ } } RomanNumerals; It should follow the API demonstrated in the examples below. Multiple roman numeral values will be tested for each helper method.\nModern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.\nFor example:\nRomanNumerals.toRoman(1000); // should return \u0026#39;M\u0026#39; RomanNumerals.fromRoman(\u0026#39;M\u0026#39;); // should return 1000 Help\nSymbol I V X L C D M Value 1 5 10 50 100 500 1000 Solution Convert integer to Roman Numeral Idea is to convert the thousands, hundreds, tens, units places of the given number separately. Suppose the number is greater than or equal to 1000, i will subtract 1000 from it and append the symbol M to the result string. Repeat untils it\u0026rsquo;s smaller than 1000 then move to hundreds place. There are total 13 cases since some numbers can be written exceptionally like 4 (IV) and 9 (IX)\nstd::string to_roman(unsigned int n){ std::string res = \u0026#34;\u0026#34;; std::string rnums[] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; int nums[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; for(int i = 0; i \u0026lt; 13; i ++){ while (n \u0026gt;= nums[i]){ res.append(rnums[i]); n -= nums[i]; } } return res; } Convert Roman Numeral to integer As we all know, each Roman symbol represents an integer. Thus, first of all, i covert the symbols to their integer value one by one.\nint from_roman(std::string rn){ int from_roman(std::string rn){ std::vector\u0026lt;int\u0026gt; a; for(char i : rn){ switch(i){ case \u0026#39;I\u0026#39;: a.push_back(1); break; case \u0026#39;V\u0026#39;: a.push_back(5); break; case \u0026#39;X\u0026#39;: a.push_back(10); break; case \u0026#39;L\u0026#39;: a.push_back(50); break; case \u0026#39;C\u0026#39;: a.push_back(100); break; case \u0026#39;D\u0026#39;: a.push_back(500); break; case \u0026#39;M\u0026#39;: a.push_back(1000); break; } } ... } The purpose of this is to facilitate the comparison. Noticed that if one symbol is greater than or equal to its following, the value is their combination, for example: VI = V + I = 6. Otherwise, if that one symbol is smaller, just subtract it. I will compare each pair of continous numbers in a and do the junior math above to find the final result. Because there is no value to compare with the last element so it will be added first.\nint from_roman(std::string rn){ ... int res = a.back(), size = a.size(); for(int i = 0; i \u0026lt; size-1; i++) if(a[i] \u0026gt;= a[i+1]) res += a[i]; else res -= a[i]; return res; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/romannumeral/","summary":"The problem Source: Codewars Create a RomanNumerals class that can convert a roman numeral to and from an integer value.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; class RomanHelper{ public: std::string to_roman(unsigned int n){ } int from_roman(std::string rn){ } } RomanNumerals; It should follow the API demonstrated in the examples below. Multiple roman numeral values will be tested for each helper method.\nModern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero.","title":"Roman Numerals Helper"},{"content":"Problem Source: CSES Your task is to count for $k=1,2,…,n$ the number of ways two knights can be placed on a $k \\times k$ chessboard so that they do not attack each other.\nFor example:\nInput: 8 Output: 0 6 28 96 252 550 1056 1848 Solution Idea The most reachable method is for each of the first knight\u0026rsquo;s position, i\u0026rsquo;m looking for pertinent positions to place the second knight and sum them all. It\u0026rsquo;s kinda reckless to create nested loops so i\u0026rsquo;ll need a smarter way 👀\nInstead of finding the answer directly, I can indirectly find it by subtract the number of ways two knights can be placed to attack each other from total ways to place two knights.\nThe total ways to place two knights is: $$C^2_{k^2} = \\frac{k^2!}{2!(k^2-2)!} = \\frac{k^2(k^2-1)(k^2-2)!}{2(k^2-2)!} = \\frac{k^2(k^2-1)}{2}$$ Noticed that, the knights can attack each other when they form a diagonal line of a $2 \\times 3$ (horizontal) or $3 \\times 2$ (vertical) rectangle. A chessboard is a square board so the number of $2 \\times 3$ are the same as $3 \\times 2$, so that i just have to count one kind of those two and duplicate the result.\nHere are the steps:\nStart from top left, imagine i\u0026rsquo;m having a $2 \\times 3$ rectangle there. Shift 1 square to right to find how many times i can shift it to the right. Because i\u0026rsquo;m not allowed to let 2 columns of the rectangle move out of the chessboard so i can shift it $k-2$ times. Similarly, shifting it to bottom and finding how many times i can shift it. There are $k-1$ times since i can\u0026rsquo;t let the last row move out of the chessboard. Finally, multiply them and duplicate the answer. $$2(k-1)(k-2)$$ Moreover, there are two diagonal lines in a rectangle, that means there are two ways the knights can attack each other in each case. Thus, number of ways two knights can be placed to attack each other is: $$4(k-1)(k-2)$$\nIn the end, the result of this problem is: $$\\frac{k^2(k^2-1)}{2} - 4(k-1)(k-2)$$\nCode #include\u0026lt;iostream\u0026gt; int main(){ int n; std::cin \u0026gt;\u0026gt; n; for(long long i = 1; i \u0026lt;= n; i++){ std::cout \u0026lt;\u0026lt; i*i*(i*i - 1)/2 - 4*(i-1)*(i-2) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } Thank you for reading 👀\n","permalink":"https://yurukute.github.io/Blog/en/post/2knights/","summary":"Problem Source: CSES Your task is to count for $k=1,2,…,n$ the number of ways two knights can be placed on a $k \\times k$ chessboard so that they do not attack each other.\nFor example:\nInput: 8 Output: 0 6 28 96 252 550 1056 1848 Solution Idea The most reachable method is for each of the first knight\u0026rsquo;s position, i\u0026rsquo;m looking for pertinent positions to place the second knight and sum them all.","title":"Two Knights"},{"content":"Problem Source:\nVietnamese: Codeforces - Easy Can be solve with $O(n^2)$ solution Codeforces - Hard Need to be solved in $O(n\\log n)$ solution English: Leetcode Give an integer array nums. Return the length of the longest increasing subsequence.\nAn increasing subsequence is a subsequence $a_1,..,a_k$ that $$ \\begin{align} \u0026amp;i_1 \u0026lt; i_2 \u0026lt; \\dots \u0026lt; i_k,\\\\\\ \u0026amp;nums[i_1] \u0026lt; nums[i_2] \u0026lt; \\dots \u0026lt; nums[i_k] \\end{align} $$ For example:\nInput: {0,1,0,3,2,3} Output: 4 //{0,1,2,3} Solution Brute Force This method is the simplest solution can approach: We can enumerate all subsets of the original array and then test them for the increasing property then find the longest. This is too expensive with $O(2^n)$ complexity while $n$ can be a large number\nDynamic programing $O(n^2)$ To solve this, I at first divide the problem into subproblems and find the answer for each. For nums = {0,1,0,3,2,3}, the subproblems I need to answer are: Find the length of the longest increasing subsequence:\n[0-0] {0}\n[0-1] {0, 1}\n[0-2] {0, 1, 0}\n[0-3] {0, 1, 0, 3}\n[0-4] {0, 1, 0, 3, 2}\n[0-5] {0, 1, 0, 3, 2, 3} $\\Rightarrow$ Original problem\nSo, my dynamic programing table d would have 5 cells, each cell store the answer of a subproblem. Assume that I\u0026rsquo;ve found the answer for cell 0, 1, 2 and I\u0026rsquo;m fiding the answer for cell 3, then, I need to ask myself 3 questions:\nCan I extend $nums[3]$ into subsequence i\u0026rsquo;ve found in cell $d[0]$? Can I extend $nums[3]$ into subsequence i\u0026rsquo;ve found in cell $d[1]$? Can I extend $nums[3]$ into subsequence i\u0026rsquo;ve found in cell $d[2]$? And if i can (that means $nums[3] \u0026gt; nums[i]$), should I extend it or keep the current answer at that cell.\nGenerally, $$d[i] = \\max_{\\substack{j = 0 \\dots i-1 \\\\\\ nums[j] \u0026lt; nums[i]}} \\left(d[j] + 1\\right)$$\nThe automatic / default answer for d would be 1 because if the array has only 1 element, the array is the longest subsequence itself. My job is increasing that default value while processing.\ni 0 1 2 3 4 5 $nums$ 0 1 0 3 2 3 $d$ 1 1 1 1 1 1 Then, the fomular become $$d[i] = \\max\\left(1, \\max_{\\substack{j = 0 \\dots i-1 \\\\\\ nums[j] \u0026lt; nums[i]}} \\left(d[j] + 1\\right)\\right)$$\nFinally, the answer is cell $d[i]$ that contain the largest value.\nint lis(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(), max = 1; std::vector\u0026lt;int\u0026gt; lis(n,1); for(int i = 1; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; i; j++) if(nums[j] \u0026lt; nums[i] \u0026amp;\u0026amp; lis[i] \u0026lt; lis[j]+1) lis[i] = lis[j] + 1; if(lis[i] \u0026gt; max) max = lis[i]; } return max; } i 0 1 2 3 4 5 $nums$ 0 1 0 3 2 3 $d$ 1 2 1 3 3 4 $\\Rightarrow$ result DP and Binary search $O(n\\log n)$ I keep the dynamic programing table d but to store the element at which a subsequence of length $i$ terminates.\nInitially we assume $d[0] = -\\infty$ and for all other elements $d[i] = \\infty$.\nthe length of the desired subsequence is the largest $l$ with $d[l] \u0026lt; \\infty$.\nint lis(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), max = 1; const int INF = 1e9; std::vector\u0026lt;int\u0026gt; d(n+1, INF); d[0] = -INF; for (int i = 0; i \u0026lt; n; i++) for (int j = 1; j \u0026lt;= n; j++) { if (d[j-1] \u0026lt; nums[i] \u0026amp;\u0026amp; nums[i] \u0026lt; d[j]) d[j] = nums[i]; } for (int i = 0; i \u0026lt;= n; i++) if (d[i] \u0026lt; INF) max = i; return max; } i 0 1 2 3 4 5 $nums$ 0 1 0 3 2 3 $d$ $-\\infty$ 0 1 2 3 $\\infty$ I noticed that:\nd is always sorted $nums[i]$ would update at most one value $d[j]$ Thus, I can find this element in the d using Binary search in O(logn). In fact I\u0026rsquo;m simply looking in d for the first number that is strictly greater than $a[i]$, and trying to update this element in the same way as the above implementation.\nint lis(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), max = 1; const int INF = 1e9; std::vector\u0026lt;int\u0026gt; d(n+1, INF); d[0] = -INF; for (int i = 0; i \u0026lt; n; i++){ int j = upper_bound(d.begin(), d.end(), a[i]) - d.begin(); if (d[j-1] \u0026lt; nums[i] \u0026amp;\u0026amp; nums[i] \u0026lt; d[j]) d[j] = nums[i]; } for (int i = 0; i \u0026lt;= n; i++) if (d[i] \u0026lt; INF) max = i; return max; Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/lis/","summary":"Problem Source:\nVietnamese: Codeforces - Easy Can be solve with $O(n^2)$ solution Codeforces - Hard Need to be solved in $O(n\\log n)$ solution English: Leetcode Give an integer array nums. Return the length of the longest increasing subsequence.\nAn increasing subsequence is a subsequence $a_1,..,a_k$ that $$ \\begin{align} \u0026amp;i_1 \u0026lt; i_2 \u0026lt; \\dots \u0026lt; i_k,\\\\\\ \u0026amp;nums[i_1] \u0026lt; nums[i_2] \u0026lt; \\dots \u0026lt; nums[i_k] \\end{align} $$ For example:\nInput: {0,1,0,3,2,3} Output: 4 //{0,1,2,3} Solution Brute Force This method is the simplest solution can approach: We can enumerate all subsets of the original array and then test them for the increasing property then find the longest.","title":"Longest increasing subsequence"},{"content":"Problem Source: Codewars From Wikipedia The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.\nWrite a function lcs that accepts two strings and returns their longest common subsequence as a string. Performance matters.\nFor example\nInput: \u0026#34;ab\u0026#34; \u0026#34;azb\u0026#34; Output: \u0026#34;ab\u0026#34; Solution I solved this kata in 2 steps:\nFind subsequence\u0026rsquo;s length by dynamic programing. Using backtracking on dynamic programing table to find the subsequence. Step 1: Give lcs(\u0026quot;aab\u0026quot;, \u0026quot;azb\u0026quot;) as a function to find the longest common subsequence. Its process can be understood as:\nConsidering the last characters from 2 strings, they\u0026rsquo;re the same: Lengthening the subsequence by 1. The problem become lcs(\u0026quot;aa\u0026quot;, \u0026quot;az\u0026quot;). Considering the new strings, their last characters are different: One by one, remove the last character from each string and find its longest common subsequence. max(lcs(\u0026quot;a\u0026quot;, \u0026quot;az\u0026quot;), lcs(\u0026quot;aa\u0026quot;, \u0026quot;a\u0026quot;) graph TD; A(\"lcs(aab, azb)\")--\u003eB((1)) A--\u003eC(\"lcs(aa, az)\") C--\u003eD(\"max(lcs(a, az), lcs(aa, a)\") D--\u003eE(\"lcs(a,az)\") D--\u003eF(\"lcs(aa, a)\") E--\u003eG(\"max(lcs(a, a), lcs(``, az)\") F--\u003eH((1)) F--\u003eI(\"lcs(a, ``)\") G--\u003eJ(\"lcs(a, a)\")--\u003eL((1)) G--\u003eK(\"lcs(``, az)\")--\u003eM((0)) I--\u003eN((0)) For dp[i][j] is the length of the longest common subsequence from $i$ fist characters of string $x$ $x$ and $j$ first characters of string $y$, that means: $$dp[i][j]= \\begin{cases} 1 + dp[i-1][j-1] \u0026amp; x[i] = y[j]\\\\ max(dp[i-1][j],\\ dp[i][j-1]) \u0026amp; x[i] \\ne y[j] \\end{cases} $$\nint n = x.length(), m = y.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1, vector(m+1, 0)); for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) if(x[i-1] == y[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; else dp[i][j] = (dp[i-1][j] \u0026gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]); My dynamic programing will look like this:\n\u0026quot;\u0026quot; a z b \u0026quot;\u0026quot; 0 0 0 0 a 0 1 1 1 a 0 1 1 1 b 0 1 1 2 Step 2: Noticed that, at the cell which has the upper cell and the left cell contain the smaller value, that cell\u0026rsquo;s row (or column) is represent for the common character. To find the subsequence, i\u0026rsquo;ll start at the last cell (dp[n][m]), go back to the upper row (or left column) until i meet the cell like i mentioned above, store the common character, then go to the cell on its left and up (dp[i-1][j-1]) to continue.\nstring res = \u0026#34;\u0026#34;; while(dp[n][m] != 0){ while(dp[n][m] == dp[n-1][m]){ n--; } while(dp[n][m] == dp[n][m-1]){ m--; } res.insert(res.begin(), x[n-1]); n--; m--; } return res; Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/lcs/","summary":"Problem Source: Codewars From Wikipedia The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.\nWrite a function lcs that accepts two strings and returns their longest common subsequence as a string. Performance matters.\nFor example","title":"Longest common subsequence"},{"content":"Problem Source: Codewars How many ways can you make the sum of a number?\nFrom wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)# In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. Example:\nInput: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Solution It would be very slow if you enumerate all the partitions when $n$ is large so i\u0026rsquo;ll use dynamic programing instead (Oω\u0026lt;)☆.\nI have a dynamic table here (ways):\n0 1 2 3 4 0 1 2 3 4 So, ways[i][j] is Total ways to write j as a sum of positive numbers which $\\leq i$.\nPartition of number $j$ can be divided into 2 types\nNot include $i$\nThe problem now become Total ways to write j as a sum of positive numbers which $\u0026lt; i$, in other words, $\\leq i - 1$\nInclude $i$\nThen, if i remove $i$, i\u0026rsquo;ll have ways to partition number $j - i$\nObviously, the partition can only be type #1 if $i \u0026gt; j$. In contrast, total ways is the sum of 2 types above. Therefore, $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; i \u0026gt; j \\\\ ways[i-1][j] + ways[i][j-i], \u0026amp; i \\leq j \\end{cases} $$\nTo calculate ways[i][j] i need to find ways[i-1][j] and ways[i][j-i], so at first, i\u0026rsquo;ll fill the zero row. Because there is only one way to partition 0 so ways[0][0] = 1, others would be 0. After using recurrence relation to find all the cells, ways[n][n] would be the result that we need.\n#include\u0026lt;vector\u0026gt; using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vector\u0026lt;std::vector\u0026lt;ull\u0026gt;\u0026gt; ways(n+1, std::vector\u0026lt;ull\u0026gt; (n+1, 0)); ways[0][0] = 1; for(unsigned int i = 1; i \u0026lt;= n; i++){ for(unsigned int j = i; j \u0026lt;= n; j++){ ways[i][j] = ways[i-1][j]; if(i \u0026lt;= j) ways[i][j] += ways[i][j-i]; } } return ways[n][n]; } 0 1 2 3 4 0 1 0 0 0 0 1 1 1 1 1 1 2 1 1 2 2 3 3 1 1 2 3 4 4 1 1 2 3 5 Improvement As you can see, there is no need to store from row $1^{st}$ to $n^th-1$ because we only need row $n^{th}$ to calculate row $n^{th}+1$. That\u0026rsquo;s why i\u0026rsquo;ll use 1 dimmension array to store the values and calculate itself.\n#include\u0026lt;vector\u0026gt; using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vector\u0026lt;ull\u0026gt; ways(n+1, 0); ways[0] = 1; for(unsigned int i = 1; i \u0026lt;= n; i++){ for(unsigned int j = i; j \u0026lt;= n; j++){ ways[j] += ways[j - i]; } } return ways[n]; } 0 1 2 3 4 1 1 2 3 5 Thank you for reading.\nRelated post Total ways to make change ","permalink":"https://yurukute.github.io/Blog/en/post/explosivesum/","summary":"Problem Source: Codewars How many ways can you make the sum of a number?\nFrom wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)# In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. Example:\nInput: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Solution It would be very slow if you enumerate all the partitions when $n$ is large so i\u0026rsquo;ll use dynamic programing instead (Oω\u0026lt;)☆.","title":"Explosive Sum"},{"content":"Problem Source: Codeforces Find the $n^th$ Fibonacci number modulo $10^9+7$. So, you need to find $F_n$ in the sequence defined as $$\n\\begin{aligned} F_0 \u0026amp; = 0\\\\ F_1 \u0026amp; = 1\\\\ F_i \u0026amp; = F_{i-1} + F_{i-2} (i \u0026gt;= 2) \\end{aligned} $$ Example:\nInput: 50 Output: 586268941 Solution Approach 1: Dynamic Programing Using fibonacci\u0026rsquo;s difference equation as a recurrence relation, i can write to a program like this:\nint f0 = 0, f1 = 1, fn; for(int i = 2; i \u0026lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; This code\u0026rsquo;s complexity is $O(n)$ which is fine with $n \u0026lt;= 5. 10^6$. However, $n$ is up to $10^{18}$ in this problem so i need a better way, must be at least $O(log^2 n)$ complexity.\nApproach 2: Matrix exponentiation I can rewrite its different equation as $$ \\begin{aligned} F_{n+1} \u0026amp; = 1\\ F_n + 1\\ F_{n-1}\\\\ F_{n} \u0026amp; = 1\\ F_n + 0\\ F_{n-1}\\\\ \\\\ =\u0026gt; \\begin{bmatrix} F_{n+1} \\\\ F_n \\end{bmatrix} \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} F_n \\\\ F_{n-1} \\end{bmatrix} \\\\\\\\ \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}^n \\begin{bmatrix} F_1 \\\\ F_0 \\end{bmatrix} \\end{aligned} $$ As you can see, F_n is equal to $2^{nd}$ row $\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix}^n$ multiply by $\\begin{bmatrix} F_1 \\\\ F_0 \\end{bmatrix}$. Also, $F_1 = 1, F_0 = 0$ so $F_n$ is now a value at $2^{nd}$ row and $1^{st}$ column of $\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix}^n$.\nLarge n power I\u0026rsquo;ll calculate power with large $n$ by square the base and halve the exponent rather than multiply the base $n$ times as definition. For example, instead of calculate $2^6 = 2\\times2\\times2\\times2\\times2\\times2,$ i\u0026rsquo;ll do $2^6 = 4^4 = 8^2$\nIn other words, i\u0026rsquo;ll try to replace multiplying a small many times to multiplying 2 or 3 times large numbers. By this, i can reduce the complexity to $O(logn)$\nint res = 1; while (b \u0026gt; 0){ if(b % 2) res = res * a; a = a * a; b \u0026gt;\u0026gt;= 1 } Now, the base is not a number but a $2 \\times 2$ matrix so i need to declare a struct, so does the funtions for calculating and storing:\nconst unsigned long long mod = 1e9 + 7; struct matrix{ unsigned long long a, b, c, d; }; matrix multiply(matrix A, matrix B){ matrix C; C.a = (A.a*B.a + A.b*B.c) % mod; C.b = (A.a*B.b + A.b*B.d) % mod; C.c = (A.c*B.a + A.d*B.c) % mod; C.d = (A.c*B.b + A.d*B.d) % mod; return C; } matrix power(matrix a, long long b){ matrix res; //res is an identity matrix res.a = res.d = 1; res.b = res.c = 0; while (b \u0026gt; 0){ if(b % 2) res = multiply(res, a); a = multiply(a, a); b \u0026gt;\u0026gt;= 1; } return res; } Finally, for $F = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}$, the final result is power(F,n).c.\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/fibonacci/","summary":"Problem Source: Codeforces Find the $n^th$ Fibonacci number modulo $10^9+7$. So, you need to find $F_n$ in the sequence defined as $$\n\\begin{aligned} F_0 \u0026amp; = 0\\\\ F_1 \u0026amp; = 1\\\\ F_i \u0026amp; = F_{i-1} + F_{i-2} (i \u0026gt;= 2) \\end{aligned} $$ Example:\nInput: 50 Output: 586268941 Solution Approach 1: Dynamic Programing Using fibonacci\u0026rsquo;s difference equation as a recurrence relation, i can write to a program like this:\nint f0 = 0, f1 = 1, fn; for(int i = 2; i \u0026lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; This code\u0026rsquo;s complexity is $O(n)$ which is fine with $n \u0026lt;= 5.","title":"Fibonacci"},{"content":"Problem Source: Leetcode , Codewars You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nFor example:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We\u0026rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change. Look at the dynamic programing table (ways) now:\n0 1 2 3 4 5 {} {1} {1,2} {1,2,5} Each cell on the table is a subproblem and they are all related to eachother. Let\u0026rsquo;s imagine i\u0026rsquo;m at the cell $ways[1][1]$, then i\u0026rsquo;ll have to find the answer for total ways make change amount $1$ with no coin; if i\u0026rsquo;m at the cell $ways[1][1]$, i\u0026rsquo;ll have to find the answer for total ways make change amount $3$ with coins {1,2}. So does value at cell $ways[i][j]$ would be the answer for total ways make change amount $j$ with coins at row $i$.\nAnd notice, every row represents the addition of another coin (shown in bold). Thus, row $i$ will answer the question: Will i use the $i^th$ coin?\nObviously, i won\u0026rsquo;t use the $i^th$ coin if $coins[i-1] \u0026gt; j$, on the contracy, i can. Therefore: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; coins[i-1] \u0026gt; j \\\\ ways[i-1][j] + ways[i][j-coins[i-1]], \u0026amp; coins[i-1] \\leq j \\end{cases} $$ Let me explain a bit about the formula above. When i don\u0026rsquo;t use the coin, the subproblem become the same with the subproblem at the previous row, the row that don\u0026rsquo;t contain $coins[i-1]$ then i\u0026rsquo;ll go back that cell and use its value. But if i use the coin, the amount we have is only $j - coins[i-1]$ so i\u0026rsquo;ll comeback the cell $ways[i][j-coins[i-1]]$ to get its value plus the case [don\u0026rsquo;t use that coin]\nFill the base To begin, i have to fill the zero row and zero column. Zero row means we don\u0026rsquo;t have anycoin so we can\u0026rsquo;t make change, the value here would be 0. The zero column means we use the coins to make change\u0026hellip; zero amount, so that those cell\u0026rsquo;s value would be 1 because the only way is do nothing.\nFor convenience, i\u0026rsquo;ll create a 2 dimmension vector with all value are 0. Then, i just have to fill the zero column.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ways(coins.size() +1, vector\u0026lt;int\u0026gt; (amount + 1, 0)); for(int i = 0; i \u0026lt;= coins.size(); i++) ways[i][0] = 1; 0 1 2 3 4 5 {} 1 0 0 0 0 0 {1} 1 0 0 0 0 0 {1,2} 1 0 0 0 0 0 {1,2,5} 1 0 0 0 0 0 The next thing to do is fill the remain cells. The final cell is the answer for this problem.\nfor(int i = 1; i \u0026lt;= coins.size(); i++) for(int j = 1; j \u0026lt;= amount; j++) ways[i][j] = ways[i-1][j]; if(j \u0026gt;= coins[i-1]) ways[i][j] += ways[i][j - coins[i-1]]; return ways[coins.size()][amount]; 0 1 2 3 4 5 {} 1 0 0 0 0 0 {1} 1 1 1 1 1 1 {1,2} 1 1 2 2 3 3 {1,2,5} 1 1 2 2 3 4 Improvement The solution above has a weakness. After we calculated the $n^{th}$ row, we don\u0026rsquo;t need to store the value from the $1^{st}$ row to the $(n-1)^{th}$ row because we only need $n^th$ to calculated the next row. Therefore, i\u0026rsquo;ll change from 2 dimmensions array to 1 dimmension to store and calculate itself.\nvector\u0026lt;int\u0026gt; ways(amount + 1); ways[0] = 1; for(auto coin : coins) for(int i = 1; i \u0026lt;= amount; i++) if(i \u0026gt;= coin) ways[i] += ways[i - coin]; return ways[amount]; 0 1 2 3 4 5 1 1 2 2 3 4 Thank you for reading.\nRelated post Explosive sum ","permalink":"https://yurukute.github.io/Blog/en/post/countchange/","summary":"Problem Source: Leetcode , Codewars You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nFor example:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We\u0026rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change.","title":"Total ways make change"},{"content":"Problem Source: Leetcode You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExamples:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11. Let\u0026rsquo;s image 5 is the last used coin then the fewest coins we need will be the fewest coins to make change whatever is left plus 1. In other words, $$coinChange(11) = coinChange(11 - 5) + 1$$ Meanwhile, the problem become fewest coins make change whatever is left. This is a subproblem. Same as coin 1 and 2, those subproblem can be showed as a diagram like this: graph TD; A((11))--\u003eB((10)) A--\u003eC((9)) A--\u003eD((6)) B--\u003eE((9)) B--\u003eF((8)) B--\u003eG((5)) C--\u003eH((8)) C--\u003eI((7)) C--\u003eJ((4)) D--\u003eK((5)) D--\u003eL((4)) D--\u003eM((1)) I just draw a part of the diagram but as you can see, if we consider those subproblems one by one, we will have to recalculate some similar subproblems (number 9, number 8,\u0026hellip; are calculated twice). Thus, we need a better way, that is dynamic programing.\nApproach 2: Dynamic programing By the idea above, this time i have an array like this, called dp\n0 1 2 3 4 5 6 7 8 9 10 11 Each cell is a subproblem: Fewest coins make change the amount $i$. So, the answer at $11^th$ cell is the answer that we\u0026rsquo;re looking for this problem. And because it\u0026rsquo;s calculated by the cells on its left, so we can reused the answer of the subprolem and avoid duplicating them.\nTo begin, i\u0026rsquo;ll fill the array like this:\n0 1 2 3 4 5 6 7 8 9 10 11 0 12 12 12 12 12 12 12 12 12 12 12 For each cell, i\u0026rsquo;ll consider each coin whether it is greater than the amount at that cell. If not, which means we can use that coin, the value for that cell would be $$dp[i] = min(dp[i-coin] + 1,dp[i])$$ If $i = 1$ then $dp[1] = min(0+1, 12)$. Just like that, at the end, the array will be filled as:\n0 1 2 3 4 5 6 7 8 9 10 11 0 1 1 2 2 1 2 2 3 3 2 3 $11^th$ cell\u0026rsquo;s value is 3, that is the answer for the example test. From there, i have a code like this:\nvector\u0026lt;int\u0026gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) for(int coin : coins) if(coin \u0026lt;= i \u0026amp;\u0026amp; dp[i - coin] + 1 \u0026lt; dp[i]) dp[i] = dp[i - coin] + 1; return dp[amount]; That\u0026rsquo;s is the idea. But in reality, this code would recieve wrong answer instantly after submit, because of the careless when we read the problem. They said:\nIf that amount of money cannot be made up by any combination of the coins, return -1. So we need to edit return line for that case to get passed UwU.\nreturn (dp[amount] \u0026lt;= amount ? dp[amount] : -1); Thank you for reading.\nRelated topics Total ways to make change ","permalink":"https://yurukute.github.io/Blog/en/post/coinchange/","summary":"Problem Source: Leetcode You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExamples:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11.","title":"Fewest coins make change"},{"content":"Summary Name Operator Description AND \u0026amp; Both bits are 1, return 1. Otherwise, return 0. OR \\ One of both bit is 1, return 1. Otherwise, return 0. XOR ^ Two bits are different return 1. Otherwise, return 0. NOT ~ Flip bit, 0 becomes 1, 1 becomes 0 Shift left \u0026lt;\u0026lt; Shifts all the bits to the left Right left \u0026gt;\u0026gt; Shifts all the bits to the right Application Integer Change bit //Set nth bit x |= (1 \u0026lt;\u0026lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Set the right-most 1 bit to 0 x \u0026amp;= (x-1); //Toggle nth bit x ^= (1 \u0026lt;\u0026lt; n); //Get the mth bit of n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Swap Adjacent bits ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Multiplication / Division x by $2^n$ x \u0026lt;\u0026lt; n //multiplication x \u0026gt;\u0026gt; n //division Round up to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Round down to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //the same with the code above but added this line Floor x x \u0026gt;\u0026gt; 0; 6.723 \u0026gt;\u0026gt; 0; //6 Flip the sign x = ~x + 1; // or x = (x ^ -1) + 1; // x = -x Absolute value of x int abs = (x ^ (x \u0026gt;\u0026gt; 31)) - (x \u0026gt;\u0026gt; 31); The greatest power of 2 that divides x x \u0026amp; (-x); Get the minimum / maximum integer (and long) int minInt = 1 \u0026lt;\u0026lt; 31; int minInt = 1 \u0026lt;\u0026lt; -1; int maxInt = ~(1 \u0026lt;\u0026lt; 31); int maxInt = (1 \u0026lt;\u0026lt; 31) - 1; int maxInt = (1 \u0026lt;\u0026lt; -1) - 1; int maxInt = -1u \u0026gt;\u0026gt; 1; int maxLong = ((long)1 \u0026lt;\u0026lt; 127) -1; The min / max of two values //First way int min = a \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); int max = b \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); //Second way int min = (b ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); int max = (a ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); Average int avg = (x + y) \u0026gt;\u0026gt; 1; int avg = ((x ^ y) \u0026gt;\u0026gt; 1) + (x \u0026amp; y); Swap 2 variables //First way a ^= b; b ^= a; a ^= b; //Second way a = a ^ b ^ (b = a) Quick conditional assignment In some cases. you may require some conditional assignment such as\nif(x == a) x = b; //hoặc if(x == b) x = a; You can use bitwise XOR operator for these type of assignment.\nx ^= a ^ b; Check if\u0026hellip; nth bit is set x \u0026amp; (1 \u0026lt;\u0026lt; n) x is an odd number (x \u0026amp; 1) == 1; x is a power of 2 x \u0026gt; 0 \u0026amp;\u0026amp; (x \u0026amp; (x - 1)) == 0; a = b (35% faster in Javascript)\n(a ^ b) == 0; both number have the same sign (a ^ b) \u0026gt;= 0; String Convert letter to lowercase or uppercase c \u0026amp; \u0026#39;_\u0026#39; If the converting letter is uppercase, nothing change. Eg:\nchar c; c = \u0026#39;a\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; c = \u0026#39;A\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; Convert letter to an uppercase or lowercase c | \u0026#39; \u0026#39; If the converting letter is a lowercase, nothing change. Eg:\nchar c; c = \u0026#39;A\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; Invert letter\u0026rsquo;s case c ^ \u0026#39; \u0026#39; For example:\nchar c; c = \u0026#39;A\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;A\u0026#39; Letter\u0026rsquo;s position in alphabet //For lowercase only c ^ \u0026#39;`\u0026#39; //For uppercase only c ^ \u0026#39;@\u0026#39; //Letter case is not important c \u0026amp; \u0026#34;\\x1F\u0026#34; Miscellaneous Use XOR for basic encryption and decryption #include\u0026lt;iostream\u0026gt; #define key 5 int main(){ std::string s; std::cin \u0026gt;\u0026gt; s; //Mã hóa for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; //Giải mã for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; } Input: Hello Output: M`iij Hello Fast color conversion from R5G5B5 to R8G8B8 pixel format using shifts R8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) G8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) B8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) I\u0026rsquo;m gonna lose my mind after finished this post, thanks for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/bitwise/","summary":"Summary Name Operator Description AND \u0026amp; Both bits are 1, return 1. Otherwise, return 0. OR \\ One of both bit is 1, return 1. Otherwise, return 0. XOR ^ Two bits are different return 1. Otherwise, return 0. NOT ~ Flip bit, 0 becomes 1, 1 becomes 0 Shift left \u0026lt;\u0026lt; Shifts all the bits to the left Right left \u0026gt;\u0026gt; Shifts all the bits to the right Application Integer Change bit //Set nth bit x |= (1 \u0026lt;\u0026lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Set the right-most 1 bit to 0 x \u0026amp;= (x-1); //Toggle nth bit x ^= (1 \u0026lt;\u0026lt; n); //Get the mth bit of n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Swap Adjacent bits ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Multiplication / Division x by $2^n$ x \u0026lt;\u0026lt; n //multiplication x \u0026gt;\u0026gt; n //division Round up to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Round down to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //the same with the code above but added this line Floor x x \u0026gt;\u0026gt; 0; 6.","title":"Bitwise operators' application"},{"content":"Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12$$\nThus, decomp $n!$ also means decomp each factors of $n!$ then multiply them. For example, $n = 12$, we can decomp each factor as the table below:\n12! 2 3 4 5 6 7 8 9 10 11 12 decomp $2$ $3$ $2^2$ $5$ $2\\times3$ $7$ $2^3$ $3^2$ $2\\times5$ $11$ $2^2\\times3$ After we multiply them, the final result is the prime factor decomposition of a $n!$ which we need to find $$2\\times3\\times2^2\\times5\\times2\\times3\\times7\\times2^3\\times3^2\\times2\\times5\\times11\\times2^2\\times3 = 2^{10}\\times3^5\\times5^2\\times7\\times11$$\nProgram First of all, we initialize 2 arrays to save the factors and their primality\nbool prime[n+1]; int value[n+1]; prime[0] = prime[1] = false; for(int i = 2; i \u0026lt;= n; i++){ prime[i] = true; value[i] = i; } Generally, we use Eratosthene to find the prime numbers, now, with some changes, we can decomp all composite numbers which are multiples of found prime.\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ //In this line, j = i+i not i*i f[j].prime = false; while(f[j].value % i == 0){ f[j].value /= i; power++; } } } } Finally, we add some code for output\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ res += (\u0026#34; * \u0026#34; + std::to_string(i)); int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ prime[j] = false; while(value[j] % i == 0){ value[j] /= i; power++; } } if(power \u0026gt; 1) res += (\u0026#34;^\u0026#34; + std::to_string(power)); } } res.erase(res.begin(), res.begin()+3); return res; And done! UwU)/\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/factorialdecomp/","summary":"Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12!","title":"Factorial decomposition"},{"content":"Problem Codewars Given a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\na**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1. Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor. We\u0026rsquo;ll repeat the steps until reaching 1.\nFor example: n = 160\nN I 160 2 80 2 40 2 20 2 10 2 5 5 1 The idea give us code like this:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } } In coding, we don\u0026rsquo;t need to find those prime factors before. Just a for loop from 2 to $\\sqrt{n}$ would be enough. Because we repeat the division until the quotient is not divisible, that means, we divided the composite numbers UwU. After the loop finished, lst, the remain factor, would be either 1 or a prime number. Thus, add it to the result string if it is not 1.\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Thank you for reading.\nRelated post Factorial decomp ","permalink":"https://yurukute.github.io/Blog/en/post/primesinnumbers/","summary":"Problem Codewars Given a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\na**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1. Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor.","title":"Primes in numbers"},{"content":"Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$. We\u0026rsquo;ll use SoE to do that because we\u0026rsquo;ve known the $x$\u0026rsquo;s limit is $10^{12}$, therefore, the maximum value of $\\sqrt{x}$ is $10^{6}$\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } The last step is checking whether $\\sqrt{x}$ is an integer and a prime number or not. It\u0026rsquo;s simple, isn\u0026rsquo;t it? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/t-primes/","summary":"Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$.","title":"T-Primes"},{"content":"The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\nExample:\nI = {12, 15}; // result = \u0026#34;(2 12)(3 27)(5 15)\u0026#34; To solve this problem, we need to find prime numbers, from smallest to largest, for each found prime number, we\u0026rsquo;ve got:\nIf $i_j$ divisible by $p$ $sum$ += $i_j$ Solution Enumerate prime numbers The fastest way to list them out is using SoE . We use this to find all prime numbers that are smaller than the largest absolute value of members in $I$ (i\u0026rsquo;ll call it max). So, after input the array, we first find max and then sieve. After sieving, we\u0026rsquo;ll save them into a vector to use them in process.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Processing for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Well done, with all the code above, we can submit and pass this kata UwU.\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/sumbyfactors/","summary":"The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.","title":"Sum by Factors"},{"content":"Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.\nEmpty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray.\nSolution Approach 1: Brute Force This is the most accessible way to solve this promblem. It has 2 step:\nFind each sum of each subarray {-2}, {1}, {-2, 1},\u0026hellip; Compare them to each other to find the largest Beside its complexity is $O(n^3)$, however, this way has 3 weaknesses:\nBottlernecks Unnessary works Duplicate works Therefore, we\u0026rsquo;ll need a more efficient solution for this kata.\nApproach 2: We call $f[i]$ is a sum of $i$ first elements, we have $f[i]$ calculated: $f[0] = 0$ $f[i] = f[i-1] + arr[i]$ So, the sum from $i$th to $j$th element is $f[j] – f[i-1]$ With this, we can find $f[i]$ without duplicate works because we found $f[i-1]$ =\u0026gt; We avoided the first approach\u0026rsquo;s 3rd weakness (UwU). The complexity now is $O(n^2)$. But, this kata can also be solved with an $O(n)$ solution: Kadane\u0026rsquo;s solution OwO)/\nApproach 3: With second approach\u0026rsquo;s idea, we use a variable sum to save the calculating sum. We\u0026rsquo;ll have 2 choices to ask ourself while calculating: Do we add this number to sum OR we start a new subarray/new sum at this number? So that, we have to compare the [present sum plus arr[i]] with the arr[i] itself. In other words, we find max(sum + a[i], a[i]) aka the result.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/maxsubarraysum/","summary":"Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.","title":"Maximum subarray sum"}]