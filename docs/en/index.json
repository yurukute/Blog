[{"content":"Problem Source: CSES Your task is to count for $k=1,2,â€¦,n$ the number of ways two knights can be placed on a $k \\times k$ chessboard so that they do not attack each other.\nFor example:\nInput: 8 Output: 0 6 28 96 252 550 1056 1848 Solution Idea The most reachable method is for each of the first knight\u0026rsquo;s position, i\u0026rsquo;m looking for pertinent positions to place the second knight and sum them all. It\u0026rsquo;s kinda reckless to create nested loops so i\u0026rsquo;ll need a smarter way ðŸ‘€\nInstead of finding the answer directly, I can indirectly find it by subtract the number of ways two knights can be placed to attack each other from total ways to place two knights.\nThe total ways to place two knights is: $$C^2_{k^2} = \\frac{k^2!}{2!(k^2-2)!} = \\frac{k^2(k^2-1)(k^2-2)!}{2(k^2-2)!} = \\frac{k^2(k^2-1)}{2}$$ Noticed that, the knights can attack each other when they form a diagonal line of a $2 \\times 3$ (horizontal) or $3 \\times 2$ (vertical) rectangle. A chessboard is a square board so the number of $2 \\times 3$ are the same as $3 \\times 2$, so that i just have to count one kind of those two and duplicate the result.\nHere are the steps:\n Start from top left, imagine i\u0026rsquo;m having a $2 \\times 3$ rectangle there. Shift 1 square to right to find how many times i can shift it to the right. Because i\u0026rsquo;m not allowed to let 2 columns of the rectangle move out of the chessboard so i can shift it $k-2$ times. Similarly, shifting it to bottom and finding how many times i can shift it. There are $k-1$ times since i can\u0026rsquo;t let the last row move out of the chessboard. Finally, multiply them and duplicate the answer. $$2(k-1)(k-2)$$  Moreover, there are two diagonal lines in a rectangle, that means there are two ways the knights can attack each other in each case. Thus, number of ways two knights can be placed to attack each other is: $$4(k-1)(k-2)$$\nIn the end, the result of this problem is: $$\\frac{k^2(k^2-1)}{2} - 4(k-1)(k-2)$$\nCode #include\u0026lt;iostream\u0026gt; int main(){ int n; std::cin \u0026gt;\u0026gt; n; for(long long i = 1; i \u0026lt;= n; i++){ std::cout \u0026lt;\u0026lt; i*i*(i*i - 1)/2 - 4*(i-1)*(i-2) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } Thank you for reading ðŸ‘€\n","permalink":"https://yurukute.github.io/Blog/en/post/2knights/","summary":"Problem Source: CSES Your task is to count for $k=1,2,â€¦,n$ the number of ways two knights can be placed on a $k \\times k$ chessboard so that they do not attack each other.\nFor example:\nInput: 8 Output: 0 6 28 96 252 550 1056 1848 Solution Idea The most reachable method is for each of the first knight\u0026rsquo;s position, i\u0026rsquo;m looking for pertinent positions to place the second knight and sum them all.","title":"Two Knights"},{"content":"Problem Source:\n Vietnamese:  Codeforces - Easy Can be solve with $O(n^2)$ solution Codeforces - Hard Need to be solved in $O(n\\log n)$ solution   English:  Leetcode     Give an integer array nums. Return the length of the longest increasing subsequence.\nAn increasing subsequence is a subsequence $a_1,..,a_k$ that $$ \\begin{align} \u0026amp;i_1 \u0026lt; i_2 \u0026lt; \\dots \u0026lt; i_k,\\\\\\\n\u0026amp;nums[i_1] \u0026lt; nums[i_2] \u0026lt; \\dots \u0026lt; nums[i_k] \\end{align} $$ For example:\nInput: {0,1,0,3,2,3} Output: 4 //{0,1,2,3} Solution Brute Force This method is the simplest solution can approach: We can enumerate all subsets of the original array and then test them for the increasing property then find the longest. This is too expensive with $O(2^n)$ complexity while $n$ can be a large number\nDynamic programing $O(n^2)$ To solve this, I at first divide the problem into subproblems and find the answer for each. For nums = {0,1,0,3,2,3}, the subproblems I need to answer are: Find the length of the longest increasing subsequence:\n[0-0]Â {0}\n[0-1]Â {0, 1}\n[0-2]Â {0, 1, 0}\n[0-3]Â {0, 1, 0, 3}\n[0-4]Â {0, 1, 0, 3, 2}\n[0-5]Â {0, 1, 0, 3, 2, 3} $\\Rightarrow$ Original problem\nSo, my dynamic programing table d would have 5 cells, each cell store the answer of a subproblem. Assume that I\u0026rsquo;ve found the answer for cell 0, 1, 2 and I\u0026rsquo;m fiding the answer for cell 3, then, I need to ask myself 3 questions:\n Can I extend $nums[3]$ into subsequence i\u0026rsquo;ve found in cell $d[0]$? Can I extend $nums[3]$ into subsequence i\u0026rsquo;ve found in cell $d[1]$? Can I extend $nums[3]$ into subsequence i\u0026rsquo;ve found in cell $d[2]$?  And if i can (that means $nums[3] \u0026gt; nums[i]$), should I extend it or keep the current answer at that cell.\nGenerally, $$d[i] = \\max_{\\substack{j = 0 \\dots i-1 \\\\\\ nums[j] \u0026lt; nums[i]}} \\left(d[j] + 1\\right)$$\nThe automatic / default answer for d would be 1 because if the array has only 1 element, the array is the longest subsequence itself. My job is increasing that default value while processing.\n   i 0 1 2 3 4 5     $nums$ 0 1 0 3 2 3   $d$ 1 1 1 1 1 1    Then, the fomular become $$d[i] = \\max\\left(1, \\max_{\\substack{j = 0 \\dots i-1 \\\\\\ nums[j] \u0026lt; nums[i]}} \\left(d[j] + 1\\right)\\right)$$\nFinally, the answer is cell $d[i]$ that contain the largest value.\nint lis(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(), max = 1; std::vector\u0026lt;int\u0026gt; lis(n,1); for(int i = 1; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; i; j++) if(nums[j] \u0026lt; nums[i] \u0026amp;\u0026amp; lis[i] \u0026lt; lis[j]+1) lis[i] = lis[j] + 1; if(lis[i] \u0026gt; max) max = lis[i]; } return max; }    i 0 1 2 3 4 5     $nums$ 0 1 0 3 2 3   $d$ 1 2 1 3 3 4 $\\Rightarrow$ result    DP and Binary search $O(n\\log n)$ I keep the dynamic programing table d but to store the element at which a subsequence of length $i$ terminates.\nInitially we assume $d[0] = -\\infty$ and for all other elements $d[i] = \\infty$.\nthe length of the desired subsequence is the largest $l$ with $d[l] \u0026lt; \\infty$.\nint lis(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), max = 1; const int INF = 1e9; std::vector\u0026lt;int\u0026gt; d(n+1, INF); d[0] = -INF; for (int i = 0; i \u0026lt; n; i++) for (int j = 1; j \u0026lt;= n; j++) { if (d[j-1] \u0026lt; nums[i] \u0026amp;\u0026amp; nums[i] \u0026lt; d[j]) d[j] = nums[i]; } for (int i = 0; i \u0026lt;= n; i++) if (d[i] \u0026lt; INF) max = i; return max; }    i 0 1 2 3 4 5     $nums$ 0 1 0 3 2 3   $d$ $-\\infty$ 0 1 2 3 $\\infty$    I noticed that:\n d is always sorted $nums[i]$ would update at most one value $d[j]$  Thus, I can find this element in the d using Binary search in O(logn). In fact I\u0026rsquo;m simply looking in d for the first number that is strictly greater than $a[i]$, and trying to update this element in the same way as the above implementation.\nint lis(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), max = 1; const int INF = 1e9; std::vector\u0026lt;int\u0026gt; d(n+1, INF); d[0] = -INF; for (int i = 0; i \u0026lt; n; i++){ int j = upper_bound(d.begin(), d.end(), a[i]) - d.begin(); if (d[j-1] \u0026lt; nums[i] \u0026amp;\u0026amp; nums[i] \u0026lt; d[j]) d[j] = nums[i]; } for (int i = 0; i \u0026lt;= n; i++) if (d[i] \u0026lt; INF) max = i; return max; Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/lis/","summary":"Problem Source:\n Vietnamese:  Codeforces - Easy Can be solve with $O(n^2)$ solution Codeforces - Hard Need to be solved in $O(n\\log n)$ solution   English:  Leetcode     Give an integer array nums. Return the length of the longest increasing subsequence.\nAn increasing subsequence is a subsequence $a_1,..,a_k$ that $$ \\begin{align} \u0026amp;i_1 \u0026lt; i_2 \u0026lt; \\dots \u0026lt; i_k,\\\\\\\n\u0026amp;nums[i_1] \u0026lt; nums[i_2] \u0026lt; \\dots \u0026lt; nums[i_k] \\end{align} $$ For example:","title":"Longest increasing subsequence"},{"content":"Problem Source: Codewars From Wikipedia  The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.\n Write a function lcs that accepts two strings and returns their longest common subsequence as a string. Performance matters.\nFor example\nInput: \u0026#34;ab\u0026#34; \u0026#34;azb\u0026#34; Output: \u0026#34;ab\u0026#34; Solution I solved this kata in 2 steps:\n Find subsequence\u0026rsquo;s length by dynamic programing. Using backtracking on dynamic programing table to find the subsequence.  Step 1: Give lcs(\u0026quot;aab\u0026quot;, \u0026quot;azb\u0026quot;) as a function to find the longest common subsequence. Its process can be understood as:\n Considering the last characters from 2 strings, they\u0026rsquo;re the same:  Lengthening the subsequence by 1. The problem become lcs(\u0026quot;aa\u0026quot;, \u0026quot;az\u0026quot;).   Considering the new strings, their last characters are different:  One by one, remove the last character from each string and find its longest common subsequence. max(lcs(\u0026quot;a\u0026quot;, \u0026quot;az\u0026quot;), lcs(\u0026quot;aa\u0026quot;, \u0026quot;a\u0026quot;)    graph TD; A(\"lcs(aab, azb)\")--B((1)) A--C(\"lcs(aa, az)\") C--D(\"max(lcs(a, az), lcs(aa, a)\") D--E(\"lcs(a,az)\") D--F(\"lcs(aa, a)\") E--G(\"max(lcs(a, a), lcs(``, az)\") F--H((1)) F--I(\"lcs(a, ``)\") G--J(\"lcs(a, a)\")--L((1)) G--K(\"lcs(``, az)\")--M((0)) I--N((0))  For dp[i][j] is the length of the longest common subsequence from $i$ fist characters of string $x$ $x$ and $j$ first characters of string $y$, that means: $$dp[i][j]= \\begin{cases} 1 + dp[i-1][j-1] \u0026amp; x[i] = y[j]\\\\\nmax(dp[i-1][j],\\ dp[i][j-1]) \u0026amp; x[i] \\ne y[j] \\end{cases} $$\nint n = x.length(), m = y.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+1, vector(m+1, 0)); for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) if(x[i-1] == y[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; else dp[i][j] = (dp[i-1][j] \u0026gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]); My dynamic programing will look like this:\n    \u0026quot;\u0026quot; a z b     \u0026quot;\u0026quot; 0 0 0 0   a 0 1 1 1   a 0 1 1 1   b 0 1 1 2    Step 2: Noticed that, at the cell which has the upper cell and the left cell contain the smaller value, that cell\u0026rsquo;s row (or column) is represent for the common character. To find the subsequence, i\u0026rsquo;ll start at the last cell (dp[n][m]), go back to the upper row (or left column) until i meet the cell like i mentioned above, store the common character, then go to the cell on its left and up (dp[i-1][j-1]) to continue.\nstring res = \u0026#34;\u0026#34;; while(dp[n][m] != 0){ while(dp[n][m] == dp[n-1][m]){ n--; } while(dp[n][m] == dp[n][m-1]){ m--; } res.insert(res.begin(), x[n-1]); n--; m--; } return res; Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/lcs/","summary":"Problem Source: Codewars From Wikipedia  The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.\n Write a function lcs that accepts two strings and returns their longest common subsequence as a string. Performance matters.","title":"Longest common subsequence"},{"content":"Problem Source: Codewars How many ways can you make the sum of a number?\nFrom wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)#  In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. Example:\n Input: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Solution It would be very slow if you enumerate all the partitions when $n$ is large so i\u0026rsquo;ll use dynamic programing instead (OÏ‰\u0026lt;)â˜†.\nI have a dynamic table here (ways):\n    0 1 2 3 4     0        1        2        3        4         So, ways[i][j] is Total ways to write j as a sum of positive numbers which $\\leq i$.\nPartition of number $j$ can be divided into 2 types\n  Not include $i$\nThe problem now become Total ways to write j as a sum of positive numbers which $\u0026lt; i$, in other words, $\\leq i - 1$\n  Include $i$\nThen, if i remove $i$, i\u0026rsquo;ll have ways to partition number $j - i$\n  Obviously, the partition can only be type #1 if $i \u0026gt; j$. In contrast, total ways is the sum of 2 types above. Therefore, $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; i \u0026gt; j \\\\\nways[i-1][j] + ways[i][j-i], \u0026amp; i \\leq j \\end{cases} $$\nTo calculate ways[i][j] i need to find ways[i-1][j] and ways[i][j-i], so at first, i\u0026rsquo;ll fill the zero row. Because there is only one way to partition 0 so ways[0][0] = 1, others would be 0. After using recurrence relation to find all the cells, ways[n][n] would be the result that we need.\n#include\u0026lt;vector\u0026gt; using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vector\u0026lt;std::vector\u0026lt;ull\u0026gt;\u0026gt; ways(n+1, std::vector\u0026lt;ull\u0026gt; (n+1, 0)); ways[0][0] = 1; for(unsigned int i = 1; i \u0026lt;= n; i++){ for(unsigned int j = i; j \u0026lt;= n; j++){ ways[i][j] = ways[i-1][j]; if(i \u0026lt;= j) ways[i][j] += ways[i][j-i]; } } return ways[n][n]; }     0 1 2 3 4     0 1 0 0 0 0   1 1 1 1 1 1   2 1 1 2 2 3   3 1 1 2 3 4   4 1 1 2 3 5    Improvement As you can see, there is no need to store from row $1^{st}$ to $n^th-1$ because we only need row $n^{th}$ to calculate row $n^{th}+1$. That\u0026rsquo;s why i\u0026rsquo;ll use 1 dimmension array to store the values and calculate itself.\n#include\u0026lt;vector\u0026gt; using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vector\u0026lt;ull\u0026gt; ways(n+1, 0); ways[0] = 1; for(unsigned int i = 1; i \u0026lt;= n; i++){ for(unsigned int j = i; j \u0026lt;= n; j++){ ways[j] += ways[j - i]; } } return ways[n]; }    0 1 2 3 4     1 1 2 3 5    Thank you for reading.\nRelated post Total ways to make change ","permalink":"https://yurukute.github.io/Blog/en/post/explosivesum/","summary":"Problem Source: Codewars How many ways can you make the sum of a number?\nFrom wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)#  In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. Example:\n Input: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Solution It would be very slow if you enumerate all the partitions when $n$ is large so i\u0026rsquo;ll use dynamic programing instead (OÏ‰\u0026lt;)â˜†.","title":"Explosive Sum"},{"content":"Problem Source: Codeforces Find the $n^th$ Fibonacci number modulo $10^9+7$. So, you need to find $F_n$ in the sequence defined as $$\n\\begin{aligned} F_0 \u0026amp; = 0\\\\\nF_1 \u0026amp; = 1\\\\\nF_i \u0026amp; = F_{i-1} + F_{i-2} (i \u0026gt;= 2) \\end{aligned} $$ Example:\nInput: 50 Output: 586268941 Solution Approach 1: Dynamic Programing Using fibonacci\u0026rsquo;s difference equation as a recurrence relation, i can write to a program like this:\nint f0 = 0, f1 = 1, fn; for(int i = 2; i \u0026lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; This code\u0026rsquo;s complexity is $O(n)$ which is fine with $n \u0026lt;= 5. 10^6$. However, $n$ is up to $10^{18}$ in this problem so i need a better way, must be at least $O(log^2 n)$ complexity.\nApproach 2: Matrix exponentiation I can rewrite its different equation as $$ \\begin{aligned} F_{n+1} \u0026amp; = 1\\ F_n + 1\\ F_{n-1}\\\\\nF_{n} \u0026amp; = 1\\ F_n + 0\\ F_{n-1}\\\\\n\\\\\n=\u0026gt; \\begin{bmatrix} F_{n+1} \\\\ F_n \\end{bmatrix} \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} F_n \\\\ F_{n-1} \\end{bmatrix} \\\\\\\\ \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}^n \\begin{bmatrix} F_1 \\\\ F_0 \\end{bmatrix} \\end{aligned} $$ As you can see, F_n is equal to $2^{nd}$ row $\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix}^n$ multiply by $\\begin{bmatrix} F_1 \\\\ F_0 \\end{bmatrix}$. Also, $F_1 = 1, F_0 = 0$ so $F_n$ is now a value at $2^{nd}$ row and $1^{st}$ column of $\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix}^n$.\nLarge n power I\u0026rsquo;ll calculate power with large $n$ by square the base and halve the exponent rather than multiply the base $n$ times as definition. For example, instead of calculate $2^6 = 2\\times2\\times2\\times2\\times2\\times2,$ i\u0026rsquo;ll do $2^6 = 4^4 = 8^2$\nIn other words, i\u0026rsquo;ll try to replace multiplying a small many times to multiplying 2 or 3 times large numbers. By this, i can reduce the complexity to $O(logn)$\nint res = 1; while (b \u0026gt; 0){ if(b % 2) res = res * a; a = a * a; b \u0026gt;\u0026gt;= 1 } Now, the base is not a number but a $2 \\times 2$ matrix so i need to declare a struct, so does the funtions for calculating and storing:\nconst unsigned long long mod = 1e9 + 7; struct matrix{ unsigned long long a, b, c, d; }; matrix multiply(matrix A, matrix B){ matrix C; C.a = (A.a*B.a + A.b*B.c) % mod; C.b = (A.a*B.b + A.b*B.d) % mod; C.c = (A.c*B.a + A.d*B.c) % mod; C.d = (A.c*B.b + A.d*B.d) % mod; return C; } matrix power(matrix a, long long b){ matrix res; //res is an identity matrix  res.a = res.d = 1; res.b = res.c = 0; while (b \u0026gt; 0){ if(b % 2) res = multiply(res, a); a = multiply(a, a); b \u0026gt;\u0026gt;= 1; } return res; } Finally, for $F = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}$, the final result is power(F,n).c.\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/fibonacci/","summary":"Problem Source: Codeforces Find the $n^th$ Fibonacci number modulo $10^9+7$. So, you need to find $F_n$ in the sequence defined as $$\n\\begin{aligned} F_0 \u0026amp; = 0\\\\\nF_1 \u0026amp; = 1\\\\\nF_i \u0026amp; = F_{i-1} + F_{i-2} (i \u0026gt;= 2) \\end{aligned} $$ Example:\nInput: 50 Output: 586268941 Solution Approach 1: Dynamic Programing Using fibonacci\u0026rsquo;s difference equation as a recurrence relation, i can write to a program like this:\nint f0 = 0, f1 = 1, fn; for(int i = 2; i \u0026lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; This code\u0026rsquo;s complexity is $O(n)$ which is fine with $n \u0026lt;= 5.","title":"Fibonacci"},{"content":"Problem Source: Leetcode , Codewars You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nFor example:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We\u0026rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change. Look at the dynamic programing table (ways) now:\n    0 1 2 3 4 5     {}         {1}         {1,2}         {1,2,5}          Each cell on the table is a subproblem and they are all related to eachother. Let\u0026rsquo;s imagine i\u0026rsquo;m at the cell $ways[1][1]$, then i\u0026rsquo;ll have to find the answer for total ways make change amount $1$ with no coin; if i\u0026rsquo;m at the cell $ways[1][1]$, i\u0026rsquo;ll have to find the answer for total ways make change amount $3$ with coins {1,2}. So does value at cell $ways[i][j]$ would be the answer for total ways make change amount $j$ with coins at row $i$.\nAnd notice, every row represents the addition of another coin (shown in bold). Thus, row $i$ will answer the question: Will i use the $i^th$ coin?\nObviously, i won\u0026rsquo;t use the $i^th$ coin if $coins[i-1] \u0026gt; j$, on the contracy, i can. Therefore: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; coins[i-1] \u0026gt; j \\\\\nways[i-1][j] + ways[i][j-coins[i-1]], \u0026amp; coins[i-1] \\leq j \\end{cases} $$ Let me explain a bit about the formula above. When i don\u0026rsquo;t use the coin, the subproblem become the same with the subproblem at the previous row, the row that don\u0026rsquo;t contain $coins[i-1]$ then i\u0026rsquo;ll go back that cell and use its value. But if i use the coin, the amount we have is only $j - coins[i-1]$ so i\u0026rsquo;ll comeback the cell $ways[i][j-coins[i-1]]$ to get its value plus the case [don\u0026rsquo;t use that coin]\nFill the base To begin, i have to fill the zero row and zero column. Zero row means we don\u0026rsquo;t have anycoin so we can\u0026rsquo;t make change, the value here would be 0. The zero column means we use the coins to make change\u0026hellip; zero amount, so that those cell\u0026rsquo;s value would be 1 because the only way is do nothing.\nFor convenience, i\u0026rsquo;ll create a 2 dimmension vector with all value are 0. Then, i just have to fill the zero column.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ways(coins.size() +1, vector\u0026lt;int\u0026gt; (amount + 1, 0)); for(int i = 0; i \u0026lt;= coins.size(); i++) ways[i][0] = 1;     0 1 2 3 4 5     {} 1 0 0 0 0 0   {1} 1 0 0 0 0 0   {1,2} 1 0 0 0 0 0   {1,2,5} 1 0 0 0 0 0    The next thing to do is fill the remain cells. The final cell is the answer for this problem.\nfor(int i = 1; i \u0026lt;= coins.size(); i++) for(int j = 1; j \u0026lt;= amount; j++) ways[i][j] = ways[i-1][j]; if(j \u0026gt;= coins[i-1]) ways[i][j] += ways[i][j - coins[i-1]]; return ways[coins.size()][amount];     0 1 2 3 4 5     {} 1 0 0 0 0 0   {1} 1 1 1 1 1 1   {1,2} 1 1 2 2 3 3   {1,2,5} 1 1 2 2 3 4    Improvement The solution above has a weakness. After we calculated the $n^{th}$ row, we don\u0026rsquo;t need to store the value from the $1^{st}$ row to the $(n-1)^{th}$ row because we only need $n^th$ to calculated the next row. Therefore, i\u0026rsquo;ll change from 2 dimmensions array to 1 dimmension to store and calculate itself.\nvector\u0026lt;int\u0026gt; ways(amount + 1); ways[0] = 1; for(auto coin : coins) for(int i = 1; i \u0026lt;= amount; i++) if(i \u0026gt;= coin) ways[i] += ways[i - coin]; return ways[amount];    0 1 2 3 4 5     1 1 2 2 3 4    Thank you for reading.\nRelated post Explosive sum ","permalink":"https://yurukute.github.io/Blog/en/post/countchange/","summary":"Problem Source: Leetcode , Codewars You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nFor example:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We\u0026rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change.","title":"Total ways make change"},{"content":"Problem Source: Leetcode You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExamples:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 Ä‘á»“ng 5 vÃ  1 Ä‘á»“ng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11. Let\u0026rsquo;s image 5 is the last used coin then the fewest coins we need will be the fewest coins to make change whatever is left plus 1. In other words, $$coinChange(11) = coinChange(11 - 5) + 1$$ Meanwhile, the problem become fewest coins make change whatever is left. This is a subproblem. Same as coin 1 and 2, those subproblem can be showed as a diagram like this: graph TD; A((11))--B((10)) A--C((9)) A--D((6)) B--E((9)) B--F((8)) B--G((5)) C--H((8)) C--I((7)) C--J((4)) D--K((5)) D--L((4)) D--M((1))  I just draw a part of the diagram but as you can see, if we consider those subproblems one by one, we will have to recalculate some similar subproblems (number 9, number 8,\u0026hellip; are calculated twice). Thus, we need a better way, that is dynamic programing.\nApproach 2: Dynamic programing By the idea above, this time i have an array like this, called dp\n   0 1 2 3 4 5 6 7 8 9 10 11                    Each cell is a subproblem: Fewest coins make change the amount $i$. So, the answer at $11^th$ cell is the answer that we\u0026rsquo;re looking for this problem. And because it\u0026rsquo;s calculated by the cells on its left, so we can reused the answer of the subprolem and avoid duplicating them.\nTo begin, i\u0026rsquo;ll fill the array like this:\n   0 1 2 3 4 5 6 7 8 9 10 11     0 12 12 12 12 12 12 12 12 12 12 12    For each cell, i\u0026rsquo;ll consider each coin whether it is greater than the amount at that cell. If not, which means we can use that coin, the value for that cell would be $$dp[i] = min(dp[i-coin] + 1,dp[i])$$ If $i = 1$ then $dp[1] = min(0+1, 12)$. Just like that, at the end, the array will be filled as:\n   0 1 2 3 4 5 6 7 8 9 10 11     0 1 1 2 2 1 2 2 3 3 2 3    $11^th$ cell\u0026rsquo;s value is 3, that is the answer for the example test. From there, i have a code like this:\nvector\u0026lt;int\u0026gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) for(int coin : coins) if(coin \u0026lt;= i \u0026amp;\u0026amp; dp[i - coin] + 1 \u0026lt; dp[i]) dp[i] = dp[i - coin] + 1; return dp[amount]; That\u0026rsquo;s is the idea. But in reality, this code would recieve wrong answer instantly after submit, because of the careless when we read the problem. They said:\n If that amount of money cannot be made up by any combination of the coins, return -1. So we need to edit return line for that case to get passed UwU.\n return (dp[amount] \u0026lt;= amount ? dp[amount] : -1); Thank you for reading.\nRelated topics Total ways to make change ","permalink":"https://yurukute.github.io/Blog/en/post/coinchange/","summary":"Problem Source: Leetcode You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExamples:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 Ä‘á»“ng 5 vÃ  1 Ä‘á»“ng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11.","title":"Fewest coins make change"},{"content":"Summary    Name Operator Description      AND \u0026amp; Both bits are 1, return 1. Otherwise, return 0.   OR \\ One of both bit is 1, return 1. Otherwise, return 0.   XOR ^ Two bits are different return 1. Otherwise, return 0.   NOT ~ Flip bit, 0 becomes 1, 1 becomes 0    Shift left \u0026lt;\u0026lt; Shifts all the bits to the left    Right left \u0026gt;\u0026gt; Shifts all the bits to the right     Application Integer Change bit //Set nth bit x |= (1 \u0026lt;\u0026lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Set the right-most 1 bit to 0 x \u0026amp;= (x-1); //Toggle nth bit x ^= (1 \u0026lt;\u0026lt; n); //Get the mth bit of n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Swap Adjacent bits ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Multiplication / Division x by $2^n$ x \u0026lt;\u0026lt; n //multiplication x \u0026gt;\u0026gt; n //division Round up to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Round down to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //the same with the code above but added this line Floor x x \u0026gt;\u0026gt; 0; 6.723 \u0026gt;\u0026gt; 0; //6 Flip the sign x = ~x + 1; // or x = (x ^ -1) + 1; // x = -x Absolute value of x int abs = (x ^ (x \u0026gt;\u0026gt; 31)) - (x \u0026gt;\u0026gt; 31); The greatest power of 2 that divides x x \u0026amp; (-x); Get the minimum / maximum integer (and long) int minInt = 1 \u0026lt;\u0026lt; 31; int minInt = 1 \u0026lt;\u0026lt; -1; int maxInt = ~(1 \u0026lt;\u0026lt; 31); int maxInt = (1 \u0026lt;\u0026lt; 31) - 1; int maxInt = (1 \u0026lt;\u0026lt; -1) - 1; int maxInt = -1u \u0026gt;\u0026gt; 1; int maxLong = ((long)1 \u0026lt;\u0026lt; 127) -1; The min / max of two values //First way int min = a \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); int max = b \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); //Second way int min = (b ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); int max = (a ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); Average int avg = (x + y) \u0026gt;\u0026gt; 1; int avg = ((x ^ y) \u0026gt;\u0026gt; 1) + (x \u0026amp; y); Swap 2 variables //First way a ^= b; b ^= a; a ^= b; //Second way a = a ^ b ^ (b = a) Quick conditional assignment In some cases. you may require some conditional assignment such as\nif(x == a) x = b; //hoáº·c if(x == b) x = a; You can use bitwise XOR operator for these type of assignment.\nx ^= a ^ b; Check if\u0026hellip;   nth bit is set   x \u0026amp; (1 \u0026lt;\u0026lt; n)   x is an odd number   (x \u0026amp; 1) == 1;   x is a power of 2   x \u0026gt; 0 \u0026amp;\u0026amp; (x \u0026amp; (x - 1)) == 0;   a = b   (35% faster in Javascript)\n(a ^ b) == 0;   both number have the same sign   (a ^ b) \u0026gt;= 0; String Convert letter to lowercase or uppercase c \u0026amp; \u0026#39;_\u0026#39; If the converting letter is uppercase, nothing change. Eg:\nchar c; c = \u0026#39;a\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; c = \u0026#39;A\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; Convert letter to an uppercase or lowercase c | \u0026#39; \u0026#39; If the converting letter is a lowercase, nothing change. Eg:\nchar c; c = \u0026#39;A\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; Invert letter\u0026rsquo;s case c ^ \u0026#39; \u0026#39; For example:\nchar c; c = \u0026#39;A\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;A\u0026#39; Letter\u0026rsquo;s position in alphabet //For lowercase only c ^ \u0026#39;`\u0026#39; //For uppercase only c ^ \u0026#39;@\u0026#39; //Letter case is not important c \u0026amp; \u0026#34;\\x1F\u0026#34; Miscellaneous Use XOR for basic encryption and decryption #include\u0026lt;iostream\u0026gt;#define key 5  int main(){ std::string s; std::cin \u0026gt;\u0026gt; s; //MÃ£ hÃ³a  for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; //Giáº£i mÃ£  for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; } Input: Hello Output: M`iij Hello Fast color conversion from R5G5B5 to R8G8B8 pixel format using shifts R8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) G8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) B8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) I\u0026rsquo;m gonna lose my mind after finished this post, thanks for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/bitwise/","summary":"Summary    Name Operator Description      AND \u0026amp; Both bits are 1, return 1. Otherwise, return 0.   OR \\ One of both bit is 1, return 1. Otherwise, return 0.   XOR ^ Two bits are different return 1. Otherwise, return 0.   NOT ~ Flip bit, 0 becomes 1, 1 becomes 0    Shift left \u0026lt;\u0026lt; Shifts all the bits to the left    Right left \u0026gt;\u0026gt; Shifts all the bits to the right     Application Integer Change bit //Set nth bit x |= (1 \u0026lt;\u0026lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Set the right-most 1 bit to 0 x \u0026amp;= (x-1); //Toggle nth bit x ^= (1 \u0026lt;\u0026lt; n); //Get the mth bit of n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Swap Adjacent bits ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Multiplication / Division x by $2^n$ x \u0026lt;\u0026lt; n //multiplication x \u0026gt;\u0026gt; n //division Round up to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Round down to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //the same with the code above but added this line Floor x x \u0026gt;\u0026gt; 0; 6.","title":"Bitwise operators' application"},{"content":"Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits âˆ‘(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12$$\nThus, decomp $n!$ also means decomp each factors of $n!$ then multiply them. For example, $n = 12$, we can decomp each factor as the table below:\n   12! 2 3 4 5 6 7 8 9 10 11 12     decomp $2$ $3$ $2^2$ $5$ $2\\times3$ $7$ $2^3$ $3^2$ $2\\times5$ $11$ $2^2\\times3$    After we multiply them, the final result is the prime factor decomposition of a $n!$ which we need to find $$2\\times3\\times2^2\\times5\\times2\\times3\\times7\\times2^3\\times3^2\\times2\\times5\\times11\\times2^2\\times3 = 2^{10}\\times3^5\\times5^2\\times7\\times11$$\nProgram First of all, we initialize 2 arrays to save the factors and their primality\nbool prime[n+1]; int value[n+1]; prime[0] = prime[1] = false; for(int i = 2; i \u0026lt;= n; i++){ prime[i] = true; value[i] = i; } Generally, we use Eratosthene to find the prime numbers, now, with some changes, we can decomp all composite numbers which are multiples of found prime.\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ //In this line, j = i+i not i*i  f[j].prime = false; while(f[j].value % i == 0){ f[j].value /= i; power++; } } } } Finally, we add some code for output\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ res += (\u0026#34; * \u0026#34; + std::to_string(i)); int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ prime[j] = false; while(value[j] % i == 0){ value[j] /= i; power++; } } if(power \u0026gt; 1) res += (\u0026#34;^\u0026#34; + std::to_string(power)); } } res.erase(res.begin(), res.begin()+3); return res; And done! UwU)/\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/factorialdecomp/","summary":"Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits âˆ‘(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12!","title":"Factorial decomposition"},{"content":"Problem Codewars Given a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\n a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor. We\u0026rsquo;ll repeat the steps until reaching 1.\nFor example: n = 160\n   N I     160 2   80 2   40 2   20 2   10 2   5 5   1     The idea give us code like this:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } In coding, we don\u0026rsquo;t need to find those prime factors before. Just a for loop from 2 to $\\sqrt{n}$ would be enough. Because we repeat the division until the quotient is not divisible, that means. we divided the composite numbers UwU. Now, edit the code a little bit for output\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Thank you for reading.\nRelated post Factorial decomp ","permalink":"https://yurukute.github.io/Blog/en/post/primesinnumbers/","summary":"Problem Codewars Given a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\n a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor.","title":"Primes in numbers"},{"content":"Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Ð¢-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Ð¢-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$. We\u0026rsquo;ll use SoE to do that because we\u0026rsquo;ve known the $x$\u0026rsquo;s limit is $10^{12}$, therefore, the maximum value of $\\sqrt{x}$ is $10^{6}$\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } The last step is checking whether $\\sqrt{x}$ is an integer and a prime number or not. It\u0026rsquo;s simple, isn\u0026rsquo;t it? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/t-primes/","summary":"Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Ð¢-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Ð¢-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$.","title":"T-Primes"},{"content":"The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\nExample:\nI = {12, 15}; // result = \u0026quot;(2 12)(3 27)(5 15)\u0026quot; To solve this problem, we need to find prime numbers, from smallest to largest, for each found prime number, we\u0026rsquo;ve got:\n If $i_j$ divisible by $p$  $sum$ += $i_j$    Solution Enumerate prime numbers The fastest way to list them out is using SoE . We use this to find all prime numbers that are smaller than the largest absolute value of members in $I$ (i\u0026rsquo;ll call it max). So, after input the array, we first find max and then sieve. After sieving, we\u0026rsquo;ll save them into a vector to use them in process.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Processing for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Well done, with all the code above, we can submit and pass this kata UwU.\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/sumbyfactors/","summary":"The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.","title":"Sum by Factors"},{"content":"Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.\nEmpty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray.\nSolution Approach 1: Brute Force This is the most accessible way to solve this promblem. It has 2 step:\n Find each sum of each subarray {-2}, {1}, {-2, 1},\u0026hellip; Compare them to each other to find the largest  Beside its complexity is $O(n^3)$, however, this way has 3 weaknesses:\n Bottlernecks Unnessary works Duplicate works  Therefore, we\u0026rsquo;ll need a more efficient solution for this kata.\nApproach 2:  We call $f[i]$ is a sum of $i$ first elements, we have $f[i]$ calculated:  $f[0] = 0$ $f[i] = f[i-1] + arr[i]$   So, the sum from $i$th to $j$th element is $f[j] â€“ f[i-1]$  With this, we can find $f[i]$ without duplicate works because we found $f[i-1]$ =\u0026gt; We avoided the first approach\u0026rsquo;s 3rd weakness (UwU). The complexity now is $O(n^2)$. But, this kata can also be solved with an $O(n)$ solution: Kadane\u0026rsquo;s solution OwO)/\nApproach 3: With second approach\u0026rsquo;s idea, we use a variable sum to save the calculating sum. We\u0026rsquo;ll have 2 choices to ask ourself while calculating: Do we add this number to sum OR we start a new subarray/new sum at this number? So that, we have to compare the [present sum plus arr[i]] with the arr[i] itself. In other words, we find max(sum + a[i], a[i]) aka the result.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/maxsubarraysum/","summary":"Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.","title":"Maximum subarray sum"}]