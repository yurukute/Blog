[{"content":"Promblem Source: Codeforces\nWe know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$. We\u0026rsquo;ll use SoE to do that because we\u0026rsquo;ve known the $x$\u0026rsquo;s limit is $10^{12}$, therefore, the maximum value of $\\sqrt{x}$ is $10^{6}$\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } The last step is checking whether $\\sqrt{x}$ is an integer and a prime number or not. It\u0026rsquo;s simple, isn\u0026rsquo;t it? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } ","permalink":"https://yurukute.github.io/Blog/en/post/t-primes/","summary":"Promblem Source: Codeforces\nWe know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$.","title":"T-Primes"},{"content":"The problem: Source: codewars\nGiven an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\nExample:\nI = {12, 15}; // result = \u0026quot;(2 12)(3 27)(5 15)\u0026quot; To solve this problem, we need to find prime numbers, from smallest to largest, for each found prime number, we\u0026rsquo;ve got:\n If $i_j$ divisible by $p$  $sum$ += $i_j$    Enumerate prime numbers The fastest way to list them out is using SoE. We use this to find all prime numbers that are smaller than the largest absolute value of members in $I$ (i\u0026rsquo;ll call it max). So, after input the array, we first find max and then sieve. After sieving, we\u0026rsquo;ll save them into a vector to use them in process.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Processing for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } In the code above, I use a self-write function to_string. Because the output format is a string so we need to convert p and the calculated sum into string so that we can add them to ans. Here\u0026rsquo;s the code for to_string:\nstd::string to_string(int n){ std::string prefix = \u0026#34;\u0026#34;, s = \u0026#34;\u0026#34;; //if n is negative, we\u0026#39;ll keep its \u0026#34;-\u0026#34;  if(n \u0026lt; 0){ n *= -1; prefix = \u0026#34;-\u0026#34;; } while(n \u0026gt; 0){ int x = n % 10; n /= 10; //We detach the number from behind so the latest digist need to be put at the front  s.insert(s.begin(), x+48); } return prefix+s; }; Well done, with all the code above, we can submit and pass this kata UwU.\nPostscript My code is still naive. After submit, you\u0026rsquo;ll find out there are many solutions which are short and creative. I followed the kata\u0026rsquo;s structure, which means i don\u0026rsquo;t import anymore libary in, that\u0026rsquo;s why i have to write to_string function. If not, the code would be short and clean!\n","permalink":"https://yurukute.github.io/Blog/en/post/sumbyfactors/","summary":"The problem: Source: codewars\nGiven an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.","title":"Sum by Factors"},{"content":"Problem: Source: Codewars.com\nThe maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.\nEmpty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray.\nSolution Approach 1: Brute Force This is the most accessible way to solve this promblem. It has 2 step:\n Find each sum of each subarray {-2}, {1}, {-2, 1},\u0026hellip; Compare them to each other to find the largest  Beside its complexity is $O(n^3)$, however, this way has 3 weaknesses:\n Bottlernecks Unnessary works Duplicate works  Therefore, we\u0026rsquo;ll need a more efficient solution for this kata.\nApproach 2:  We call $f[i]$ is a sum of $i$ first elements, we have $f[i]$ calculated:  $f[0] = 0$ $f[i] = f[i-1] + arr[i]$   So, the sum from $i$th to $j$th element is $f[j] – f[i-1]$  With this, we can find $f[i]$ without duplicate works because we found $f[i-1]$ =\u0026gt; We avoided the first approach\u0026rsquo;s 3rd weakness (UwU). The complexity now is $O(n^2)$. But, this kata can also be solved with an $O(n)$ solution: Kadane\u0026rsquo;s solution OwO)/\nApproach 3: With second approach\u0026rsquo;s idea, we use a variable sum to save the calculating sum. We\u0026rsquo;ll have 2 choices to ask ourself while calculating: Do we add this number to sum OR we start a new subarray/new sum at this number? So that, we have to compare the [present sum plus arr[i]] with the arr[i] itself. In other words, we find max(sum + a[i], a[i]) aka the result.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Thanks for reading ","permalink":"https://yurukute.github.io/Blog/en/post/maxsubarraysum/","summary":"Problem: Source: Codewars.com\nThe maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.","title":"Maximum subarray sum"},{"content":"","permalink":"https://yurukute.github.io/Blog/en/archive/","summary":"","title":"Archives"},{"content":"","permalink":"https://yurukute.github.io/Blog/en/search/","summary":"search","title":"Search"}]