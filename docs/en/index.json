[{"content":"Problem Source: Leetcode, Codewars\nYou are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nFor example:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We\u0026rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change. Look at the dynamic programing table (ways) now:\n    0 1 2 3 4 5     {}         {1}         {1,2}         {1,2,5}          Each cell on the table is a subproblem and they are all related to eachother. Let\u0026rsquo;s imagine i\u0026rsquo;m at the cell $ways[1][1]$, then i\u0026rsquo;ll have to find the answer for total ways make change amount $1$ with no coin; if i\u0026rsquo;m at the cell $ways[1][1]$, i\u0026rsquo;ll have to find the answer for total ways make change amount $3$ with coins {1,2}. So does value at cell $ways[i][j]$ would be the answer for total ways make change amount $j$ with coins at row $i$.\nAnd notice, every row represents the addition of another coin (shown in bold). Thus, row $i$ will answer the question: Will i use the $i^th$ coin?\nObviously, i won\u0026rsquo;t use the $i^th$ coin if $coins[i-1] \u0026gt; j$, on the contracy, i can. Therefore: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026amp; coins[i-1] \u0026gt; j \\\\\nways[i-1][j] + ways[i][j-coins[i-1]], \u0026amp; coins[i-1] \u0026lt;= j \\end{cases} $$ Let me explain a bit about the formula above. When i don\u0026rsquo;t use the coin, the subproblem become the same with the subproblem at the previous row, the row that don\u0026rsquo;t contain $coins[i-1]$ then i\u0026rsquo;ll go back that cell and use its value. But if i use the coin, the amount we have is only $j - coins[i-1]$ so i\u0026rsquo;ll comeback the cell $ways[i][j-coins[i-1]]$ to get its value plus the case [don\u0026rsquo;t use that coin]\nFill the base To begin, i have to fill the zero row and zero column. Zero row means we don\u0026rsquo;t have anycoin so we can\u0026rsquo;t make change, the value here would be 0. The zero column means we use the coins to make change\u0026hellip; zero amount, so that those cell\u0026rsquo;s value would be 1 because the only way is do nothing.\nFor convenience, i\u0026rsquo;ll create a 2 dimmension vector with all value are 0. Then, i just have to fill the zero column.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ways(coins.size() +1, vector\u0026lt;int\u0026gt; (amount + 1, 0)); for(int i = 0; i \u0026lt;= coins.size(); i++) ways[i][0] = 1;     0 1 2 3 4 5     {} 1 0 0 0 0 0   {1} 1 0 0 0 0 0   {1,2} 1 0 0 0 0 0   {1,2,5} 1 0 0 0 0 0    The next thing to do is fill the remain cells. The final cell is the answer for this problem.\nfor(int i = 1; i \u0026lt;= coins.size(); i++) for(int j = 1; j \u0026lt;= amount; j++) ways[i][j] = ways[i-1][j]; if(j \u0026gt;= coins[i-1]) ways[i][j] += ways[i][j - coins[i-1]]; return ways[coins.size()][amount];     0 1 2 3 4 5     {} 1 0 0 0 0 0   {1} 1 1 1 1 1 1   {1,2} 1 1 2 2 3 3   {1,2,5} 1 1 2 2 3 4    Improvement The solution above has a weakness. After we calculated the $n^th$ row, we don\u0026rsquo;t need to store the value from the $1^st$ row to the $(n-1)^th$ row because we only need $n^th$ to calculated the next row. Therefore, i\u0026rsquo;ll change from 2 dimmensions array to 1 dimmension to store and calculate itself.\nvector\u0026lt;int\u0026gt; ways(amount + 1); ways[0] = 1; for(auto coin : coins) for(int i = 1; i \u0026lt;= amount; i++) if(i \u0026gt;= coin) ways[i] += ways[i - coin]; return ways[amount];    0 1 2 3 4 5     1 1 2 2 3 4    Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/countchange/","summary":"Problem Source: Leetcode, Codewars\nYou are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nFor example:\nInput: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We\u0026rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change.","title":"Total ways make change"},{"content":"Problem Source: Leetcode\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExamples:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11. Let\u0026rsquo;s image 5 is the last used coin then the fewest coins we need will be the fewest coins to make change whatever is left plus 1. In other words, $$coinChange(11) = coinChange(11 - 5) + 1$$ Meanwhile, the problem become fewest coins make change whatever is left. This is a subproblem. Same as coin 1 and 2, those subproblem can be showed as a diagram like this: graph TD; A((11))--B((10)) A--C((9)) A--D((6)) B--E((9)) B--F((8)) B--G((5)) C--H((8)) C--I((7)) C--J((4)) D--K((5)) D--L((4)) D--M((1))  I just draw a part of the diagram but as you can see, if we consider those subproblems one by one, we will have to recalculate some similar subproblems (number 9, number 8,\u0026hellip; are calculated twice). Thus, we need a better way, that is dynamic programing.\nApproach 2: Dynamic programing By the idea above, this time i have an array like this, called dp\n   0 1 2 3 4 5 6 7 8 9 10 11                    Each cell is a subproblem: Fewest coins make change the amount $i$. So, the answer at $11^th$ cell is the answer that we\u0026rsquo;re looking for this problem. And because it\u0026rsquo;s calculated by the cells on its left, so we can reused the answer of the subprolem and avoid duplicating them.\nTo begin, i\u0026rsquo;ll fill the array like this:\n   0 1 2 3 4 5 6 7 8 9 10 11     0 12 12 12 12 12 12 12 12 12 12 12    For each cell, i\u0026rsquo;ll consider each coin whether it is greater than the amount at that cell. If not, which means we can use that coin, the value for that cell would be $$dp[i] = min(dp[i-coin] + 1,dp[i])$$ If $i = 1$ then $dp[1] = min(0+1, 12)$. Just like that, at the end, the array will be filled as:\n   0 1 2 3 4 5 6 7 8 9 10 11     0 1 1 2 2 1 2 2 3 3 2 3    $11^th$ cell\u0026rsquo;s value is 3, that is the answer for the example test. From there, i have a code like this:\nvector\u0026lt;int\u0026gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i \u0026lt;= amount; i++) for(int coin : coins) if(coin \u0026lt;= i \u0026amp;\u0026amp; dp[i - coin] + 1 \u0026lt; dp[i]) dp[i] = dp[i - coin] + 1; return dp[amount]; That\u0026rsquo;s is the idea. But in reality, this code would recieve wrong answer instantly after submit, because of the careless when we read the problem. They said:\n If that amount of money cannot be made up by any combination of the coins, return -1. So we need to edit return line for that case to get passed UwU.\n return (dp[amount] \u0026lt;= amount ? dp[amount] : -1); Thank you for reading.\nRelated topics Total ways to make change\n","permalink":"https://yurukute.github.io/Blog/en/post/coinchange/","summary":"Problem Source: Leetcode\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExamples:\nInput: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11.","title":"Fewest coins make change"},{"content":"Summary    Name Operator Description      AND \u0026amp; Both bits are 1, return 1. Otherwise, return 0.   OR \\ One of both bit is 1, return 1. Otherwise, return 0.   XOR ^ Two bits are different return 1. Otherwise, return 0.   NOT ~ Flip bit, 0 becomes 1, 1 becomes 0    Shift left \u0026lt;\u0026lt; Shifts all the bits to the left    Right left \u0026gt;\u0026gt; Shifts all the bits to the right     Application Integer Change bit //Set nth bit x |= (1 \u0026lt;\u0026lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Set the right-most 1 bit to 0 x \u0026amp;= (x-1); //Toggle nth bit x ^= (1 \u0026lt;\u0026lt; n); //Get the mth bit of n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Swap Adjacent bits ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Multiplication / Division x by $2^n$ x \u0026lt;\u0026lt; n //multiplication x \u0026gt;\u0026gt; n //division Round up to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Round down to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //the same with the code above but added this line Floor x x \u0026gt;\u0026gt; 0; 6.723 \u0026gt;\u0026gt; 0; //6 Flip the sign x = ~x + 1; // or x = (x ^ -1) + 1; // x = -x Absolute value of x int abs = (x ^ (x \u0026gt;\u0026gt; 31)) - (x \u0026gt;\u0026gt; 31); The greatest power of 2 that divides x x \u0026amp; (-x); Get the minimum / maximum integer (and long) int minInt = 1 \u0026lt;\u0026lt; 31; int minInt = 1 \u0026lt;\u0026lt; -1; int maxInt = ~(1 \u0026lt;\u0026lt; 31); int maxInt = (1 \u0026lt;\u0026lt; 31) - 1; int maxInt = (1 \u0026lt;\u0026lt; -1) - 1; int maxInt = -1u \u0026gt;\u0026gt; 1; int maxLong = ((long)1 \u0026lt;\u0026lt; 127) -1; The min / max of two values //First way int min = a \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); int max = b \u0026amp; ((a-b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a-b) \u0026gt;\u0026gt; 31); //Second way int min = (b ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); int max = (a ^ (a ^ b) \u0026amp; -(a \u0026lt; b)); Average int avg = (x + y) \u0026gt;\u0026gt; 1; int avg = ((x ^ y) \u0026gt;\u0026gt; 1) + (x \u0026amp; y); Swap 2 variables //First way a ^= b; b ^= a; a ^= b; //Second way a = a ^ b ^ (b = a) Quick conditional assignment In some cases. you may require some conditional assignment such as\nif(x == a) x = b; //hoặc if(x == b) x = a; You can use bitwise XOR operator for these type of assignment.\nx ^= a ^ b; Check if\u0026hellip;   nth bit is set   x \u0026amp; (1 \u0026lt;\u0026lt; n)   x is an odd number   (x \u0026amp; 1) == 1;   x is a power of 2   x \u0026gt; 0 \u0026amp;\u0026amp; (x \u0026amp; (x - 1)) == 0;   a = b   (35% faster in Javascript)\n(a ^ b) == 0;   both number have the same sign   (a ^ b) \u0026gt;= 0; String Convert letter to lowercase or uppercase c \u0026amp; \u0026#39;_\u0026#39; If the converting letter is uppercase, nothing change. Eg:\nchar c; c = \u0026#39;a\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; c = \u0026#39;A\u0026#39; \u0026amp; \u0026#39;_\u0026#39;; //c = \u0026#39;A\u0026#39; Convert letter to an uppercase or lowercase c | \u0026#39; \u0026#39; If the converting letter is a lowercase, nothing change. Eg:\nchar c; c = \u0026#39;A\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; | \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; Invert letter\u0026rsquo;s case c ^ \u0026#39; \u0026#39; For example:\nchar c; c = \u0026#39;A\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;a\u0026#39; c = \u0026#39;a\u0026#39; ^ \u0026#39; \u0026#39;; //c = \u0026#39;A\u0026#39; Letter\u0026rsquo;s position in alphabet //For lowercase only c ^ \u0026#39;`\u0026#39; //For uppercase only c ^ \u0026#39;@\u0026#39; //Letter case is not important c \u0026amp; \u0026#34;\\x1F\u0026#34; Miscellaneous Use XOR for basic encryption and decryption #include\u0026lt;iostream\u0026gt;#define key 5  int main(){ std::string s; std::cin \u0026gt;\u0026gt; s; //Mã hóa  for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; //Giải mã  for(char \u0026amp;i : s){ i ^= key; } std::cout \u0026lt;\u0026lt; s + \u0026#34;\\n\u0026#34;; } Input: Hello Output: M`iij Hello Fast color conversion from R5G5B5 to R8G8B8 pixel format using shifts R8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) G8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) B8 = (R5 \u0026lt;\u0026lt; 3) | (R5 \u0026gt;\u0026gt; 2) I\u0026rsquo;m gonna lose my mind after finished this post, thanks for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/bitwise/","summary":"Summary    Name Operator Description      AND \u0026amp; Both bits are 1, return 1. Otherwise, return 0.   OR \\ One of both bit is 1, return 1. Otherwise, return 0.   XOR ^ Two bits are different return 1. Otherwise, return 0.   NOT ~ Flip bit, 0 becomes 1, 1 becomes 0    Shift left \u0026lt;\u0026lt; Shifts all the bits to the left    Right left \u0026gt;\u0026gt; Shifts all the bits to the right     Application Integer Change bit //Set nth bit x |= (1 \u0026lt;\u0026lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x \u0026amp;= ~(1 \u0026lt;\u0026lt; n); //Set the right-most 1 bit to 0 x \u0026amp;= (x-1); //Toggle nth bit x ^= (1 \u0026lt;\u0026lt; n); //Get the mth bit of n (x \u0026gt;\u0026gt; n) \u0026amp; 1; //Swap Adjacent bits ((x \u0026amp; 10101010) \u0026gt;\u0026gt; 1) | ((x \u0026amp; 01010101) \u0026lt;\u0026lt; 1); Multiplication / Division x by $2^n$ x \u0026lt;\u0026lt; n //multiplication x \u0026gt;\u0026gt; n //division Round up to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; Round down to the next power of two x--; x |= x \u0026gt;\u0026gt; 1; x |= x \u0026gt;\u0026gt; 2; x |= x \u0026gt;\u0026gt; 4; x |= x \u0026gt;\u0026gt; 8; x |= x \u0026gt;\u0026gt; 16; x++; x = x \u0026gt;\u0026gt; 1; //the same with the code above but added this line Floor x x \u0026gt;\u0026gt; 0; 6.","title":"Bitwise operators' application"},{"content":"Problem Source: Codewars\nThe aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12$$\nThus, decomp $n!$ also means decomp each factors of $n!$ then multiply them. For example, $n = 12$, we can decomp each factor as the table below:\n   12! 2 3 4 5 6 7 8 9 10 11 12     decomp $2$ $3$ $2^2$ $5$ $2\\times3$ $7$ $2^3$ $3^2$ $2\\times5$ $11$ $2^2\\times3$    After we multiply them, the final result is the prime factor decomposition of a $n!$ which we need to find $$2\\times3\\times2^2\\times5\\times2\\times3\\times7\\times2^3\\times3^2\\times2\\times5\\times11\\times2^2\\times3 = 2^{10}\\times3^5\\times5^2\\times7\\times11$$\nProgram First of all, we initialize 2 arrays to save the factors and their primality\nbool prime[n+1]; int value[n+1]; prime[0] = prime[1] = false; for(int i = 2; i \u0026lt;= n; i++){ prime[i] = true; value[i] = i; } Generally, we use Eratosthene to find the prime numbers, now, with some changes, we can decomp all composite numbers which are multiples of found prime.\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ //In this line, j = i+i not i*i  f[j].prime = false; while(f[j].value % i == 0){ f[j].value /= i; power++; } } } } Finally, we add some code for output\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ res += (\u0026#34; * \u0026#34; + std::to_string(i)); int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ prime[j] = false; while(value[j] % i == 0){ value[j] /= i; power++; } } if(power \u0026gt; 1) res += (\u0026#34;^\u0026#34; + std::to_string(power)); } } res.erase(res.begin(), res.begin()+3); return res; And done! UwU)/\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/factorialdecomp/","summary":"Problem Source: Codewars\nThe aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12!","title":"Factorial decomposition"},{"content":"Problem Codewars\nGiven a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\n a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor. We\u0026rsquo;ll repeat the steps until reaching 1.\nFor example: n = 160\n   N I     160 2   80 2   40 2   20 2   10 2   5 5   1     The idea give us code like this:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } In coding, we don\u0026rsquo;t need to find those prime factors before. Just a for loop from 2 to $\\sqrt{n}$ would be enough. Because we repeat the division until the quotient is not divisible, that means. we divided the composite numbers UwU. Now, edit the code a little bit for output\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Thank you for reading.\nRelated post Factorial decomp\n","permalink":"https://yurukute.github.io/Blog/en/post/primesinnumbers/","summary":"Problem Codewars\nGiven a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\n a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor.","title":"Primes in numbers"},{"content":"Promblem Source: Codeforces\nWe know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$. We\u0026rsquo;ll use SoE to do that because we\u0026rsquo;ve known the $x$\u0026rsquo;s limit is $10^{12}$, therefore, the maximum value of $\\sqrt{x}$ is $10^{6}$\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } The last step is checking whether $\\sqrt{x}$ is an integer and a prime number or not. It\u0026rsquo;s simple, isn\u0026rsquo;t it? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/t-primes/","summary":"Promblem Source: Codeforces\nWe know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$.","title":"T-Primes"},{"content":"The problem: Source: codewars\nGiven an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\nExample:\nI = {12, 15}; // result = \u0026quot;(2 12)(3 27)(5 15)\u0026quot; To solve this problem, we need to find prime numbers, from smallest to largest, for each found prime number, we\u0026rsquo;ve got:\n If $i_j$ divisible by $p$  $sum$ += $i_j$    Solution Enumerate prime numbers The fastest way to list them out is using SoE. We use this to find all prime numbers that are smaller than the largest absolute value of members in $I$ (i\u0026rsquo;ll call it max). So, after input the array, we first find max and then sieve. After sieving, we\u0026rsquo;ll save them into a vector to use them in process.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Processing for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Well done, with all the code above, we can submit and pass this kata UwU.\nThank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/sumbyfactors/","summary":"The problem: Source: codewars\nGiven an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.","title":"Sum by Factors"},{"content":"Problem: Source: Codewars.com\nThe maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.\nEmpty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray.\nSolution Approach 1: Brute Force This is the most accessible way to solve this promblem. It has 2 step:\n Find each sum of each subarray {-2}, {1}, {-2, 1},\u0026hellip; Compare them to each other to find the largest  Beside its complexity is $O(n^3)$, however, this way has 3 weaknesses:\n Bottlernecks Unnessary works Duplicate works  Therefore, we\u0026rsquo;ll need a more efficient solution for this kata.\nApproach 2:  We call $f[i]$ is a sum of $i$ first elements, we have $f[i]$ calculated:  $f[0] = 0$ $f[i] = f[i-1] + arr[i]$   So, the sum from $i$th to $j$th element is $f[j] – f[i-1]$  With this, we can find $f[i]$ without duplicate works because we found $f[i-1]$ =\u0026gt; We avoided the first approach\u0026rsquo;s 3rd weakness (UwU). The complexity now is $O(n^2)$. But, this kata can also be solved with an $O(n)$ solution: Kadane\u0026rsquo;s solution OwO)/\nApproach 3: With second approach\u0026rsquo;s idea, we use a variable sum to save the calculating sum. We\u0026rsquo;ll have 2 choices to ask ourself while calculating: Do we add this number to sum OR we start a new subarray/new sum at this number? So that, we have to compare the [present sum plus arr[i]] with the arr[i] itself. In other words, we find max(sum + a[i], a[i]) aka the result.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Thank you for reading.\n","permalink":"https://yurukute.github.io/Blog/en/post/maxsubarraysum/","summary":"Problem: Source: Codewars.com\nThe maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.","title":"Maximum subarray sum"}]