[{"content":"Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12$$\nThus, decomp $n!$ also means decomp each factors of $n!$ then multiply them. For example, $n = 12$, we can decomp each factor as the table below:\n   12! 2 3 4 5 6 7 8 9 10 11 12     decomp $2$ $3$ $2^2$ $5$ $2\\times3$ $7$ $2^3$ $3^2$ $2\\times5$ $11$ $2^2\\times3$    After we multiply them, the final result is the prime factor decomposition of a $n!$ which we need to find $$2\\times3\\times2^2\\times5\\times2\\times3\\times7\\times2^3\\times3^2\\times2\\times5\\times11\\times2^2\\times3 = 2^{10}\\times3^5\\times5^2\\times7\\times11$$\nProgram First of all, we initialize 2 arrays to save the factors and their primality\nbool prime[n+1]; int value[n+1]; prime[0] = prime[1] = false; for(int i = 2; i \u0026lt;= n; i++){ prime[i] = true; value[i] = i; } Generally, we use Eratosthene to find the prime numbers, now, with some changes, we can decomp all composite numbers which are multiples of found prime.\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ //In this line, j = i+i not i*i  f[j].prime = false; while(f[j].value % i == 0){ f[j].value /= i; power++; } } } } Finally, we add some code for output\nfor(int i = 2; i \u0026lt;= n; i ++){ if(f[i].prime){ res += (\u0026#34; * \u0026#34; + std::to_string(i)); int power = 1; for(int j = i+i; j \u0026lt;= n; j += i){ prime[j] = false; while(value[j] % i == 0){ value[j] /= i; power++; } } if(power \u0026gt; 1) res += (\u0026#34;^\u0026#34; + std::to_string(power)); } } res.erase(res.begin(), res.begin()+3); return res; And done! UwU)/\nThank you for reading. ","permalink":"https://yurukute.github.io/Blog/en/post/factorialdecomp/","summary":"Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:\nInput: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)\nSolution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12!","title":"Factorial decomposition"},{"content":"Problem Codewars Given a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\n a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor. We\u0026rsquo;ll repeat the steps until reaching 1.\nFor example: n = 160\n   N I     160 2   80 2   40 2   20 2   10 2   5 5   1     The idea give us code like this:\nstd::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } In coding, we don\u0026rsquo;t need to find those prime factors before. Just a for loop from 2 to $\\sqrt{n}$ would be enough. Because we repeat the division until the quotient is not divisible, that means. we divided the composite numbers UwU. Now, edit the code a little bit for output\nstd::string res = \u0026#34;\u0026#34;; std::vector\u0026lt;int\u0026gt; fact; int power = 0; for(int i = 2; i*i \u0026lt; lst; i++){ while(lst % i == 0){ power++; lst /= i; } if(power == 0) continue; res += \u0026#34;(\u0026#34; + std::to_string(i) + (power == 1 ? \u0026#34;\u0026#34; : (\u0026#34;**\u0026#34; + std::to_string(power))) + \u0026#34;)\u0026#34;; power = 0; } if(lst != 1) res += \u0026#34;(\u0026#34; + std::to_string(lst) + \u0026#34;)\u0026#34;; return res; Thank you for reading. Related post Factorial decomp ","permalink":"https://yurukute.github.io/Blog/en/post/primesinnumbers/","summary":"Problem Codewars Given a positive number n \u0026gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:\n($p_1$**$n_1$)($p_2$**$n_2$)\u0026hellip;($p_k$**$n_k$)\nwhere\n a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:\nInput: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor.","title":"Primes in numbers"},{"content":"Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$. We\u0026rsquo;ll use SoE to do that because we\u0026rsquo;ve known the $x$\u0026rsquo;s limit is $10^{12}$, therefore, the maximum value of $\\sqrt{x}$ is $10^{6}$\nint limit = 1000001 std::vector\u0026lt;bool\u0026gt; isprime(limit, true); isprime[0] = isprime[1] = false; for(int i = 2; i \u0026lt; limit; i++) isprime[i] = true; for(int i = 2; i*i \u0026lt; limit; i++){ if(isprime[i]) for(long long j = i * i; j \u0026lt; limit; j += i) isprime[j] = false; } The last step is checking whether $\\sqrt{x}$ is an integer and a prime number or not. It\u0026rsquo;s simple, isn\u0026rsquo;t it? OwO)/\nwhile (n--){ long long x; cin \u0026gt;\u0026gt; x; long long q = sqrt(x); cout \u0026lt;\u0026lt; (isprime[q] \u0026amp;\u0026amp; q*q == x ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Thank you for reading. ","permalink":"https://yurukute.github.io/Blog/en/post/t-primes/","summary":"Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we\u0026rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.\nYou are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.\nExamples\nInput: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\\sqrt{x}$.","title":"T-Primes"},{"content":"The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\nExample:\nI = {12, 15}; // result = \u0026quot;(2 12)(3 27)(5 15)\u0026quot; To solve this problem, we need to find prime numbers, from smallest to largest, for each found prime number, we\u0026rsquo;ve got:\n If $i_j$ divisible by $p$  $sum$ += $i_j$    Solution Enumerate prime numbers The fastest way to list them out is using SoE . We use this to find all prime numbers that are smaller than the largest absolute value of members in $I$ (i\u0026rsquo;ll call it max). So, after input the array, we first find max and then sieve. After sieving, we\u0026rsquo;ll save them into a vector to use them in process.\nstd::vector\u0026lt;int\u0026gt; sieve(int n){ std::vector\u0026lt;bool\u0026gt; isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i \u0026lt;= n; i++) if(isprime[i]==1) for(int j = i*i; j \u0026lt;= n; j += i) isprime[j]=0; std::vector\u0026lt;int\u0026gt; res; for(int i = 0; i \u0026lt; n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Processing for(auto i : primes){ ans += \u0026#39;(\u0026#39;; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + \u0026#39; \u0026#39; + to_string(sum); else{ ans.pop_back(); continue; } ans += \u0026#39;)\u0026#39;; } Well done, with all the code above, we can submit and pass this kata UwU.\nThank you for reading. ","permalink":"https://yurukute.github.io/Blog/en/post/sumbyfactors/","summary":"The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] \u0026hellip;]\nP will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.","title":"Sum by Factors"},{"content":"Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.\nEmpty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray.\nSolution Approach 1: Brute Force This is the most accessible way to solve this promblem. It has 2 step:\n Find each sum of each subarray {-2}, {1}, {-2, 1},\u0026hellip; Compare them to each other to find the largest  Beside its complexity is $O(n^3)$, however, this way has 3 weaknesses:\n Bottlernecks Unnessary works Duplicate works  Therefore, we\u0026rsquo;ll need a more efficient solution for this kata.\nApproach 2:  We call $f[i]$ is a sum of $i$ first elements, we have $f[i]$ calculated:  $f[0] = 0$ $f[i] = f[i-1] + arr[i]$   So, the sum from $i$th to $j$th element is $f[j] – f[i-1]$  With this, we can find $f[i]$ without duplicate works because we found $f[i-1]$ =\u0026gt; We avoided the first approach\u0026rsquo;s 3rd weakness (UwU). The complexity now is $O(n^2)$. But, this kata can also be solved with an $O(n)$ solution: Kadane\u0026rsquo;s solution OwO)/\nApproach 3: With second approach\u0026rsquo;s idea, we use a variable sum to save the calculating sum. We\u0026rsquo;ll have 2 choices to ask ourself while calculating: Do we add this number to sum OR we start a new subarray/new sum at this number? So that, we have to compare the [present sum plus arr[i]] with the arr[i] itself. In other words, we find max(sum + a[i], a[i]) aka the result.\n#include \u0026lt;vector\u0026gt; using namespace std; int maxSequence(const vector\u0026lt;int\u0026gt;\u0026amp; arr){ int max=0, sum=0, size=arr.size(); for(int i=0; i\u0026lt;size; i++){ sum+=arr[i]; if(arr[i]\u0026gt;sum) sum=arr[i]; if(sum\u0026gt;max) max=sum; } return max; } Thank you for reading. ","permalink":"https://yurukute.github.io/Blog/en/post/maxsubarraysum/","summary":"Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\nmaxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.","title":"Maximum subarray sum"},{"content":"","permalink":"https://yurukute.github.io/Blog/en/archive/","summary":"","title":"Archives"},{"content":"","permalink":"https://yurukute.github.io/Blog/en/search/","summary":"search","title":"Search"}]