<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Noob&#39;s Blog</title>
    <link>https://yurukute.github.io/Blog/en/post/</link>
    <description>Recent content in Posts on Noob&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© 2021 Noob</copyright>
    <lastBuildDate>Tue, 05 Mar 2024 20:26:11 +0000</lastBuildDate>
    <atom:link href="https://yurukute.github.io/Blog/en/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Snail</title>
      <link>https://yurukute.github.io/Blog/en/post/snail/</link>
      <pubDate>Tue, 05 Mar 2024 20:26:11 +0000</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/snail/</guid>
      <description>Problem Source: Codewars Given an n x n array, return the array elements arranged from outermost elements to the middle element, traveling clockwise.
array = [[1,2,3], [4,5,6], [7,8,9]] snail(array) #=&amp;gt; [1,2,3,6,9,8,7,4,5] For better understanding, please follow the numbers of the next array consecutively:
array = [[1,2,3], [8,9,4], [7,6,5]] snail(array) #=&amp;gt; [1,2,3,4,5,6,7,8,9] This image will illustrate things more clearly:
NOTE: The idea is not sort the elements from the lowest value to the highest; the idea is to traverse the 2-d array in a clockwise snailshell pattern.</description>
    </item>
    <item>
      <title>ASCII Games: Warning: Ice!</title>
      <link>https://yurukute.github.io/Blog/en/post/warningice/</link>
      <pubDate>Wed, 18 Jan 2023 01:34:32 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/warningice/</guid>
      <description>Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:
In many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as &amp;lsquo;ice puzzle&amp;rsquo;:
You have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you&amp;rsquo;ll keep sliding in the direction you&amp;rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:</description>
    </item>
    <item>
      <title>Adding Big Numbers</title>
      <link>https://yurukute.github.io/Blog/en/post/addingbignumbers/</link>
      <pubDate>Tue, 07 Jun 2022 20:43:38 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/addingbignumbers/</guid>
      <description>Problem Source: Codewars We need to sum big numbers and we require your help.
Write a function that returns the sum of two numbers. The input numbers are strings and the function must return a string.
Example
add(&amp;#34;123&amp;#34;, &amp;#34;321&amp;#34;); -&amp;gt; &amp;#34;444&amp;#34; add(&amp;#34;11&amp;#34;, &amp;#34;99&amp;#34;); -&amp;gt; &amp;#34;110&amp;#34; Notes
The input numbers are big. The input is a string of only digits The numbers are positives Solution In arithmetic, addition can be performed by aligning the addends vertically and add the colums, starting from the unit colum (on the right).</description>
    </item>
    <item>
      <title>TheLift</title>
      <link>https://yurukute.github.io/Blog/en/post/thelift/</link>
      <pubDate>Mon, 06 Jun 2022 00:45:12 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/thelift/</guid>
      <description>Problem Source: Codewars Synopsis A multi-floor building has a Lift in it.
People are queued on different floors waiting for the Lift.
Some people want to go up. Some people want to go down.
The floor they want to go to is represented by a number (i.e. when they enter the Lift this is the button they will press)
BEFORE (people waiting in queues) AFTER (people at their destinations) +--+ +--+ /----------------| |----------------\ /----------------| |----------------\ 10| | | 1,4,3,2 | 10| 10 | | | |----------------| |----------------| |----------------| |----------------| 9| | | 1,10,2 | 9| | | | |----------------| |----------------| |----------------| |----------------| 8| | | | 8| | | | |----------------| |----------------| |----------------| |----------------| 7| | | 3,6,4,5,6 | 7| | | | |----------------| |----------------| |----------------| |----------------| 6| | | | 6| 6,6,6 | | | |----------------| |----------------| |----------------| |----------------| 5| | | | 5| 5,5 | | | |----------------| |----------------| |----------------| |----------------| 4| | | 0,0,0 | 4| 4,4,4 | | | |----------------| |----------------| |----------------| |----------------| 3| | | | 3| 3,3 | | | |----------------| |----------------| |----------------| |----------------| 2| | | 4 | 2| 2,2,2 | | | |----------------| |----------------| |----------------| |----------------| 1| | | 6,5,2 | 1| 1,1 | | | |----------------| |----------------| |----------------| |----------------| G| | | | G| 0,0,0 | | | |====================================| |====================================| Rules Lift Rules The Lift only goes up or down!</description>
    </item>
    <item>
      <title>Hamming Number</title>
      <link>https://yurukute.github.io/Blog/en/post/hammingnumber/</link>
      <pubDate>Mon, 23 May 2022 17:37:36 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/hammingnumber/</guid>
      <description>Problem Source: Codewars A Hamming number is a positive integer of the form 2i3j5k, for some non-negative integers i, j, and k.
Write a function that computes the nth smallest Hamming number.
Specifically:
The first smallest Hamming number is 1 = 203050 The second smallest Hamming number is 2 = 213050 The third smallest Hamming number is 3 = 203150 The fourth smallest Hamming number is 4 = 223050 The fifth smallest Hamming number is 5 = 203051 The 20 smallest Hamming numbers are given in example test fixture.</description>
    </item>
    <item>
      <title>Number of reduced fractions with denominator d</title>
      <link>https://yurukute.github.io/Blog/en/post/reducedfractions/</link>
      <pubDate>Wed, 08 Dec 2021 17:49:22 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/reducedfractions/</guid>
      <description>Problem If n is the numerator and d the denominator of a fraction, that fraction is defined a reduced fraction if and only if GCD(n,d)==1.
For example $\displaystyle\frac{5}{16}$ is a reduced fraction, while $\displaystyle\frac{5}{16}$ is not, as both 6 and 16 are divisible by 2, thus the fraction can be reduced to $\displaystyle\frac{3}{8}$.
Now, if you consider a given number d, how many reduced fractions can be built using d as a denominator?</description>
    </item>
    <item>
      <title>Carmichael function</title>
      <link>https://yurukute.github.io/Blog/en/post/carmichael/</link>
      <pubDate>Sat, 04 Sep 2021 05:23:34 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/carmichael/</guid>
      <description>Problem Source: Codewars In number theory, the Carmichael function of a positive integer $n$, denoted $\lambda(n)$, is defined as the smallest positive integer m such that $$a^m \equiv 1 \mod n$$ for every integer $a \leq n$ that is coprime to $n$. The Carmichael function is also known as the reduced totient function (as it is linked to Euler Totient function) or the least universal exponent function. The Carmichael function is important in number theory.</description>
    </item>
    <item>
      <title>Sum of intervals</title>
      <link>https://yurukute.github.io/Blog/en/post/sumofintervals/</link>
      <pubDate>Tue, 27 Jul 2021 09:40:22 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/sumofintervals/</guid>
      <description>Problem Source: Codewars Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.
Intervals Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.</description>
    </item>
    <item>
      <title>Roman Numerals Helper</title>
      <link>https://yurukute.github.io/Blog/en/post/romannumeral/</link>
      <pubDate>Sun, 25 Jul 2021 18:51:10 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/romannumeral/</guid>
      <description>The problem Source: Codewars Create a RomanNumerals class that can convert a roman numeral to and from an integer value.
#include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; class RomanHelper{ public: std::string to_roman(unsigned int n){ } int from_roman(std::string rn){ } } RomanNumerals; It should follow the API demonstrated in the examples below. Multiple roman numeral values will be tested for each helper method.
Modern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero.</description>
    </item>
    <item>
      <title>Two Knights</title>
      <link>https://yurukute.github.io/Blog/en/post/2knights/</link>
      <pubDate>Thu, 27 May 2021 20:37:44 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/2knights/</guid>
      <description>Problem Source: CSES Your task is to count for $k=1,2,…,n$ the number of ways two knights can be placed on a $k \times k$ chessboard so that they do not attack each other.
For example:
Input: 8 Output: 0 6 28 96 252 550 1056 1848 Solution Idea The most reachable method is for each of the first knight&amp;rsquo;s position, i&amp;rsquo;m looking for pertinent positions to place the second knight and sum them all.</description>
    </item>
    <item>
      <title>Longest increasing subsequence</title>
      <link>https://yurukute.github.io/Blog/en/post/lis/</link>
      <pubDate>Tue, 09 Mar 2021 19:44:24 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/lis/</guid>
      <description>Problem Source:
Vietnamese: Codeforces - Easy Can be solve with $O(n^2)$ solution Codeforces - Hard Need to be solved in $O(n\log n)$ solution English: Leetcode Give an integer array nums. Return the length of the longest increasing subsequence.
An increasing subsequence is a subsequence $a_1,..,a_k$ that $$ \begin{align} &amp;amp;i_1 &amp;lt; i_2 &amp;lt; \dots &amp;lt; i_k,\\\ &amp;amp;nums[i_1] &amp;lt; nums[i_2] &amp;lt; \dots &amp;lt; nums[i_k] \end{align} $$ For example:
Input: {0,1,0,3,2,3} Output: 4 //{0,1,2,3} Solution Brute Force This method is the simplest solution can approach: We can enumerate all subsets of the original array and then test them for the increasing property then find the longest.</description>
    </item>
    <item>
      <title>Longest common subsequence</title>
      <link>https://yurukute.github.io/Blog/en/post/lcs/</link>
      <pubDate>Wed, 17 Feb 2021 20:36:47 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/lcs/</guid>
      <description>Problem Source: Codewars From Wikipedia The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences. It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.
Write a function lcs that accepts two strings and returns their longest common subsequence as a string. Performance matters.
For example</description>
    </item>
    <item>
      <title>Explosive Sum</title>
      <link>https://yurukute.github.io/Blog/en/post/explosivesum/</link>
      <pubDate>Mon, 15 Feb 2021 18:49:58 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/explosivesum/</guid>
      <description>Problem Source: Codewars How many ways can you make the sum of a number?
From wikipedia: https://en.wikipedia.org/wiki/Partition_(number_theory)# In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. Example:
Input: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Solution It would be very slow if you enumerate all the partitions when $n$ is large so i&amp;rsquo;ll use dynamic programing instead (Oω&amp;lt;)☆.</description>
    </item>
    <item>
      <title>Fibonacci</title>
      <link>https://yurukute.github.io/Blog/en/post/fibonacci/</link>
      <pubDate>Fri, 12 Feb 2021 04:39:49 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/fibonacci/</guid>
      <description>Problem Source: Codeforces Find the $n^th$ Fibonacci number modulo $10^9+7$. So, you need to find $F_n$ in the sequence defined as $$
\begin{aligned} F_0 &amp;amp; = 0\\ F_1 &amp;amp; = 1\\ F_i &amp;amp; = F_{i-1} + F_{i-2} (i &amp;gt;= 2) \end{aligned} $$ Example:
Input: 50 Output: 586268941 Solution Approach 1: Dynamic Programing Using fibonacci&amp;rsquo;s difference equation as a recurrence relation, i can write to a program like this:
int f0 = 0, f1 = 1, fn; for(int i = 2; i &amp;lt;= n; i++){ fn = f0 + f1; f0 = f1; f1 = fn; } return fn; This code&amp;rsquo;s complexity is $O(n)$ which is fine with $n &amp;lt;= 5.</description>
    </item>
    <item>
      <title>Total ways make change</title>
      <link>https://yurukute.github.io/Blog/en/post/countchange/</link>
      <pubDate>Tue, 09 Feb 2021 13:12:29 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/countchange/</guid>
      <description>Problem Source: Leetcode , Codewars You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.
For example:
Input: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Solution We&amp;rsquo;ll go through at each stage to considera certain coin and see how it changes the total amount of ways that can make change.</description>
    </item>
    <item>
      <title>Fewest coins make change</title>
      <link>https://yurukute.github.io/Blog/en/post/coinchange/</link>
      <pubDate>Mon, 08 Feb 2021 15:29:18 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/coinchange/</guid>
      <description>Problem Source: Leetcode You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
You may assume that you have an infinite number of each kind of coin.
Examples:
Input: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Solution Approach 1: Brute force By above example, amount = 11.</description>
    </item>
    <item>
      <title>Bitwise operators&#39; application</title>
      <link>https://yurukute.github.io/Blog/en/post/bitwise/</link>
      <pubDate>Fri, 29 Jan 2021 20:52:33 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/bitwise/</guid>
      <description>Summary Name Operator Description AND &amp;amp; Both bits are 1, return 1. Otherwise, return 0. OR \ One of both bit is 1, return 1. Otherwise, return 0. XOR ^ Two bits are different return 1. Otherwise, return 0. NOT ~ Flip bit, 0 becomes 1, 1 becomes 0 Shift left &amp;lt;&amp;lt; Shifts all the bits to the left Right left &amp;gt;&amp;gt; Shifts all the bits to the right Application Integer Change bit //Set nth bit x |= (1 &amp;lt;&amp;lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x &amp;amp;= ~(1 &amp;lt;&amp;lt; n); //Set the right-most 1 bit to 0 x &amp;amp;= (x-1); //Toggle nth bit x ^= (1 &amp;lt;&amp;lt; n); //Get the mth bit of n (x &amp;gt;&amp;gt; n) &amp;amp; 1; //Swap Adjacent bits ((x &amp;amp; 10101010) &amp;gt;&amp;gt; 1) | ((x &amp;amp; 01010101) &amp;lt;&amp;lt; 1); Multiplication / Division x by $2^n$ x &amp;lt;&amp;lt; n //multiplication x &amp;gt;&amp;gt; n //division Round up to the next power of two x--; x |= x &amp;gt;&amp;gt; 1; x |= x &amp;gt;&amp;gt; 2; x |= x &amp;gt;&amp;gt; 4; x |= x &amp;gt;&amp;gt; 8; x |= x &amp;gt;&amp;gt; 16; x++; Round down to the next power of two x--; x |= x &amp;gt;&amp;gt; 1; x |= x &amp;gt;&amp;gt; 2; x |= x &amp;gt;&amp;gt; 4; x |= x &amp;gt;&amp;gt; 8; x |= x &amp;gt;&amp;gt; 16; x++; x = x &amp;gt;&amp;gt; 1; //the same with the code above but added this line Floor x x &amp;gt;&amp;gt; 0; 6.</description>
    </item>
    <item>
      <title>Factorial decomposition</title>
      <link>https://yurukute.github.io/Blog/en/post/factorialdecomp/</link>
      <pubDate>Tue, 26 Jan 2021 00:08:20 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/factorialdecomp/</guid>
      <description>Problem Source: Codewars The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:
Input: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)
Solution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12!</description>
    </item>
    <item>
      <title>Primes in numbers</title>
      <link>https://yurukute.github.io/Blog/en/post/primesinnumbers/</link>
      <pubDate>Sat, 23 Jan 2021 20:46:09 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/primesinnumbers/</guid>
      <description>Problem Codewars Given a positive number n &amp;gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:
($p_1$**$n_1$)($p_2$**$n_2$)&amp;hellip;($p_k$**$n_k$)
where
a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1. Example:
Input: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor.</description>
    </item>
    <item>
      <title>T-Primes</title>
      <link>https://yurukute.github.io/Blog/en/post/t-primes/</link>
      <pubDate>Fri, 22 Jan 2021 15:39:07 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/t-primes/</guid>
      <description>Promblem Source: Codeforces We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we&amp;rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.
You are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.
Examples
Input: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\sqrt{x}$.</description>
    </item>
    <item>
      <title>Sum by Factors</title>
      <link>https://yurukute.github.io/Blog/en/post/sumbyfactors/</link>
      <pubDate>Mon, 18 Jan 2021 16:50:30 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/sumbyfactors/</guid>
      <description>The problem: Source: codewars Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] &amp;hellip;]
P will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.</description>
    </item>
    <item>
      <title>Maximum subarray sum</title>
      <link>https://yurukute.github.io/Blog/en/post/maxsubarraysum/</link>
      <pubDate>Sun, 17 Jan 2021 20:45:26 +0700</pubDate>
      <guid>https://yurukute.github.io/Blog/en/post/maxsubarraysum/</guid>
      <description>Problem: Source: Codewars.com The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:
maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</description>
    </item>
  </channel>
</rss>
