<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Noob&#39;s Blog</title>
    <link>https://yurukute.github.io/Blog/en/post/</link>
    <description>Recent content in Posts on Noob&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 29 Jan 2021 20:52:33 +0700</lastBuildDate><atom:link href="https://yurukute.github.io/Blog/en/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bitwise operators&#39; application</title>
      <link>https://yurukute.github.io/Blog/en/post/bitwise/</link>
      <pubDate>Fri, 29 Jan 2021 20:52:33 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/bitwise/</guid>
      <description>Summary    Name Operator Description      AND &amp;amp; Both bits are 1, return 1. Otherwise, return 0.   OR \ One of both bit is 1, return 1. Otherwise, return 0.   XOR ^ Two bits are different return 1. Otherwise, return 0.   NOT ~ Flip bit, 0 becomes 1, 1 becomes 0    Shift left &amp;lt;&amp;lt; Shifts all the bits to the left    Right left &amp;gt;&amp;gt; Shifts all the bits to the right     Application Integer Change bit //Set nth bit x |= (1 &amp;lt;&amp;lt; n); //Set the right-most 0 bit to 1 x |= (x+1); //Unset nth bit x &amp;amp;= ~(1 &amp;lt;&amp;lt; n); //Set the right-most 1 bit to 0 x &amp;amp;= (x-1); //Toggle nth bit x ^= (1 &amp;lt;&amp;lt; n); //Get the mth bit of n (x &amp;gt;&amp;gt; n) &amp;amp; 1; //Swap Adjacent bits ((x &amp;amp; 10101010) &amp;gt;&amp;gt; 1) | ((x &amp;amp; 01010101) &amp;lt;&amp;lt; 1); Multiplication / Division x by $2^n$ x &amp;lt;&amp;lt; n //multiplication x &amp;gt;&amp;gt; n //division Round up to the next power of two x--; x |= x &amp;gt;&amp;gt; 1; x |= x &amp;gt;&amp;gt; 2; x |= x &amp;gt;&amp;gt; 4; x |= x &amp;gt;&amp;gt; 8; x |= x &amp;gt;&amp;gt; 16; x++; Round down to the next power of two x--; x |= x &amp;gt;&amp;gt; 1; x |= x &amp;gt;&amp;gt; 2; x |= x &amp;gt;&amp;gt; 4; x |= x &amp;gt;&amp;gt; 8; x |= x &amp;gt;&amp;gt; 16; x++; x = x &amp;gt;&amp;gt; 1; //the same with the code above but added this line Floor x x &amp;gt;&amp;gt; 0; 6.</description>
    </item>
    
    <item>
      <title>Factorial decomposition</title>
      <link>https://yurukute.github.io/Blog/en/post/factorialdecomp/</link>
      <pubDate>Tue, 26 Jan 2021 00:08:20 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/factorialdecomp/</guid>
      <description>Problem Source: Codewars
The aim of the kata is to decompose $n!$(factorial n) into its prime factors. For example:
Input: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Note that $n$ can reach 4000 and, of course, 4000! would be very big with more than 12000 digits ∑(O_O;)
Solution Idea By definition, the factorial of a positive integer $n$, denoted by $n!$, is the product of all positive integers less than or equal to $n$: $$12!</description>
    </item>
    
    <item>
      <title>Primes in numbers</title>
      <link>https://yurukute.github.io/Blog/en/post/primesinnumbers/</link>
      <pubDate>Sat, 23 Jan 2021 20:46:09 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/primesinnumbers/</guid>
      <description>Problem Codewars
Given a positive number n &amp;gt; 1 find the prime factor decomposition of n. The result will be a string with the following form:
($p_1$**$n_1$)($p_2$**$n_2$)&amp;hellip;($p_k$**$n_k$)
where
 a**b means $a^b$ $p_i$ in increasing order $n_i$ empty if n(i) is 1.  Example:
Input: n = 86240 Output: (2**5)(5)(7**2)(11) Solution Generally, in order to calculate all of the prime factors of a number, you have to go about dividing the original number by its smallest prime factor.</description>
    </item>
    
    <item>
      <title>T-Primes</title>
      <link>https://yurukute.github.io/Blog/en/post/t-primes/</link>
      <pubDate>Fri, 22 Jan 2021 15:39:07 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/t-primes/</guid>
      <description>Promblem Source: Codeforces
We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we&amp;rsquo;ll call a positive integer $t$ Т-prime, if $t$ has exactly three distinct positive divisors.
You are given an array of $n$ positive integers. For each of them determine whether it is Т-prime or not.
Examples
Input: 3 4 5 6 Output: YES NO NO Solution First, we need to find all prime numbers from 2 to $\sqrt{x}$.</description>
    </item>
    
    <item>
      <title>Sum by Factors</title>
      <link>https://yurukute.github.io/Blog/en/post/sumbyfactors/</link>
      <pubDate>Mon, 18 Jan 2021 16:50:30 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/sumbyfactors/</guid>
      <description>The problem: Source: codewars
Given an array of positive or negative integers $I = [i_1, .., i_n]$ , you have to produce a sorted array P of the form [ [$p$, sum of all $i_j$ of $I$ for which $p$ is a prime factor ($p$ positive) of $i_j$] &amp;hellip;]
P will be sorted by increasing order of the prime numbers. The final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.</description>
    </item>
    
    <item>
      <title>Maximum subarray sum</title>
      <link>https://yurukute.github.io/Blog/en/post/maxsubarraysum/</link>
      <pubDate>Sun, 17 Jan 2021 20:45:26 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/en/post/maxsubarraysum/</guid>
      <description>Problem: Source: Codewars.com
The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:
maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4}); //should be 6: {4, -1, 2, 1} Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</description>
    </item>
    
  </channel>
</rss>
