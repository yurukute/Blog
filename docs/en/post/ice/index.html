<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ASCII Games: Warning: Ice! | Noob&#39;s Blog</title>
<meta name="keywords" content="Breadth first search, ASCII Games">
<meta name="description" content="Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:
In many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as &lsquo;ice puzzle&rsquo;:
You have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you&rsquo;ll keep sliding in the direction you&rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:">
<meta name="author" content="">
<link rel="canonical" href="https://yurukute.github.io/Blog/en/post/ice/">
<link crossorigin="anonymous" href="/Blog/assets/css/stylesheet.3a36963197fc897d45495276fdaa217c7ea47f1a28726c0dcf09e09aa944037a.css" integrity="sha256-OjaWMZf8iX1FSVJ2/aohfH6kfxoocmwNzwngmqlEA3o=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/Blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://yurukute.github.io/Blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yurukute.github.io/Blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yurukute.github.io/Blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yurukute.github.io/Blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://yurukute.github.io/Blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="vi" href="https://yurukute.github.io/Blog/post/ice/">
<link rel="alternate" hreflang="en" href="https://yurukute.github.io/Blog/en/post/ice/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });

  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<meta property="og:title" content="ASCII Games: Warning: Ice!" />
<meta property="og:description" content="Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:
In many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as &lsquo;ice puzzle&rsquo;:
You have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you&rsquo;ll keep sliding in the direction you&rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yurukute.github.io/Blog/en/post/ice/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-01-18T01:34:32+07:00" />
<meta property="article:modified_time" content="2023-01-18T01:34:32+07:00" /><meta property="og:site_name" content="Noob&#39;s Blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ASCII Games: Warning: Ice!"/>
<meta name="twitter:description" content="Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:
In many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as &lsquo;ice puzzle&rsquo;:
You have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you&rsquo;ll keep sliding in the direction you&rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yurukute.github.io/Blog/en/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ASCII Games: Warning: Ice!",
      "item": "https://yurukute.github.io/Blog/en/post/ice/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ASCII Games: Warning: Ice!",
  "name": "ASCII Games: Warning: Ice!",
  "description": "Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:\nIn many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as \u0026lsquo;ice puzzle\u0026rsquo;:\nYou have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you\u0026rsquo;ll keep sliding in the direction you\u0026rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:",
  "keywords": [
    "Breadth first search", "ASCII Games"
  ],
  "articleBody": "Problem Source: Codewars Any youngster Joeys should probably know what this image means, and why it is traumatic:\nIn many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as ‘ice puzzle’:\nYou have to traverse from point A to point B You can move towards one of the 4 orthogonal directions, 1 tile at a time Some of the floors are slippery; if you walk onto a slippery tile, you’ll keep sliding in the direction you’re going until you land on a non-slippery tile, or you collide with an obstacle/wall For example, the top-left part of the above puzzle has such a solution:\nYou will be given an M x N well-formed rectanglar ASCII map of the form:\nvar map = '\\ x \\n\\ # \\n\\ E \\n\\ # \\n\\ # \\n\\ S #'; /* Player starts at the start, and ends by reaching the end. legend: S: start (slippery, only 1 exists) E: end (non-slippery, only 1 exists) : slippery tile x: non-slippery tile #: obstacles (You can't go past map edges, which serves as the walls of the puzzle.) */ Your solver should find the optimal solution (minimal number of moves, as in, the amount of times you make a step), and return an array of directions: 'u', 'd', 'l', 'r' for up/down/left/right respectively. So for the example map above, you should return ['u', 'r', 'd', 'l', 'u', 'r']. If there are multiple solutions with the same amount of steps, tiebreak by least distance traversed. If there are still ties, just return any one of them.\nAlso, you might be passed some maps which does not admit any solutions. In this case, return null.\nSolution The maze is read as a string, using graph hurts my brain as well as I’m too lazy to transform it into matrix so, let it be. As an example:\n\" x \\n\" \" # \\n\" \" E \\n\" \" # \\n\" \" # \\n\" \"S #\" Consider this maze as a matrix, it’s columns equal to position of '\\n' + 1 besides, this is a numbered matrix, starts from 0.\nConspicuously, if current cell is at position i, it’s 4 adjacent cells would be:\nUpper cell: i - col Lower cell: i + col Left cell: i - 1 Right cecll: i + 1 Thus, a while loop is used to find a move’s destination:\n#define UP 0 #define DOWN 1 #define LEFT 2 #define RIGHT 3 int next_tile(const std::string \u0026map, int col, int curr, char dir) { int row = (map.length() + 1) / col; while (map[curr] != 'E' \u0026\u0026 is_valid(curr, dir, col, row)) { int next; switch (dir) { case UP: next = curr - col; break; case DOWN: next = curr + col; break; case LEFT: next = curr - 1; break; default: next = curr + 1; break; } if (map[next] == '#') return curr; if (map[next] == 'x') return next; curr = next; } return curr; } is_valid function is responsible for ensuring the movement doesn’t go out of the maze’s walls\nbool is_valid(int pos, char dir, int col, int row) { switch (dir) { case UP: return pos \u003e= col; case DOWN: return pos \u003c= col * (row - 1) - 1; case LEFT: return pos % col != 0; } return (pos - col + 2) % col != 0; } The main algorithm for this kata is breadth first search (depth first search is possible, however, it can not take care of the bigger maze). When traverse a cell, calculate it’s destinations (next) for each of 4 directions, then push them to queue. There are 2 case would occur: There is another path which leads to next and there is none.\nIf another path exists, next would not be pushed to queue but its path would be updated so that the solution is an optimal one. Init precell array to store cells’ previous cell, -1 as default, to supports tracing back a path from start to any cell.\nMoreover, pay attention to avoid adding start cell into queue, which causes infinite loop.\nstd::vector\u003cchar\u003e ice_maze_solver(const std::string \u0026map) { int col = map.find(\"\\n\") + 1, start = map.find(\"S\"), end = map.find(\"E\"); bool solvable = false; std::vector\u003cchar\u003e solution; std::vector\u003cint\u003e precell(map.length(), -1); std::queue\u003cint\u003e queue; queue.push(start); while (!queue.empty()) { int curr = queue.front(); queue.pop(); if(curr == end){ solvable = true; continue; } for (int i = 0; i \u003c 4; i++) { int next = next_tile(map, col, curr, i); if (next != curr \u0026\u0026 next != precell[curr]) { if(precell[next] != -1){ update_path(precell, col, curr, next); } else if (next != start){ precell[next] = curr; queue.push(next); } } } } if (solvable){ while (end != start) { char move; if ((precell[end] - end) % col == 0) move = (precell[end] \u003e end) ? 'u' : 'd'; else move = (precell[end] \u003e end) ? 'l' : 'r'; solution.insert(solution.begin(), move); end = precell[end]; } } return solution; } The path is updated through 2 factors:\nNumber of steps Total path length, where: The distance between 2 cells in the same horizontal row is $|i-j|$ If they’re in the same vertical row: $\\dfrac{|i-j|}{col}$ std::vector\u003cint\u003e get_length( std::vector\u003cint\u003e const \u0026parent, const int col, int curr) { int length = 0; int step = 0; while (parent[curr] != -1) { step++; length += abs(parent[curr] - curr) / ((parent[curr] - curr) % col == 0 ? col : 1); curr = parent[curr]; } return {step, length}; } void update_path(std::vector\u003cint\u003e \u0026parent, const int col, int curr, int next) { auto oldPath = get_length(parent, col, next); auto newPath = get_length(parent, col, curr); newPath[0] += 1; newPath[1] += abs(curr - next) / ((curr - next) % col == 0 ? col : 1); if (newPath \u003c oldPath) { parent[next] = curr; } } Thank you for reading this amateur solution, I did this kata just because it is related to pokemon series, nothing else. ",
  "wordCount" : "982",
  "inLanguage": "en",
  "datePublished": "2023-01-18T01:34:32+07:00",
  "dateModified": "2023-01-18T01:34:32+07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yurukute.github.io/Blog/en/post/ice/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Noob's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yurukute.github.io/Blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yurukute.github.io/Blog/en/" accesskey="h" title="Noob&#39;s Blog (Alt + H)">Noob&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://yurukute.github.io/Blog/" title="Tiếng Việt"
                            aria-label="Tiếng Việt">Vi</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yurukute.github.io/Blog/en/archive/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://yurukute.github.io/Blog/en/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://yurukute.github.io/Blog/en/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      ASCII Games: Warning: Ice!
    </h1>
    <div class="post-meta"><span title='2023-01-18 01:34:32 +0700 +07'>January 18, 2023</span>&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://yurukute.github.io/Blog/post/ice/">Vi</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><h1 id="problem">Problem<a hidden class="anchor" aria-hidden="true" href="#problem">#</a></h1>
<p>Source: <a href="https://www.codewars.com/kata/58f4cc4e43251b1be6000082" target="_blank">Codewars</a>
</p>
<p>Any youngster Joeys should probably know what this image means, and why it is <em>traumatic</em>:</p>
<p><img loading="lazy" src="https://archives.bulbagarden.net/media/upload/6/66/Ice_Path_1F_GS.png" alt="IcePath-1F-GS"  />
</p>
<p>In many grid-based 2D puzzle games, there is a typical form of puzzle which are usually referred to as &lsquo;ice puzzle&rsquo;:</p>
<ul>
<li>You have to traverse from point A to point B</li>
<li>You can move towards one of the 4 orthogonal directions, 1 tile at a time</li>
<li>Some of the floors are slippery; if you walk onto a slippery tile, you&rsquo;ll keep sliding in the direction you&rsquo;re going until you land on a non-slippery tile, or you collide with an obstacle/wall</li>
</ul>
<p>For example, the top-left part of the above puzzle has such a solution:</p>
<p><img loading="lazy" src="http://pkmn.net/games/goldsilver/icepath.jpg" alt="IcePathSolution"  />
</p>
<p>You will be given an M x N well-formed rectanglar ASCII map of the form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">map</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    x \n\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  #   \n\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">   E  \n\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> #    \n\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    # \n\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">S    #&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Player starts at the start, and ends by reaching the end.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">legend: 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">S: start (slippery, only 1 exists)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">E: end (non-slippery, only 1 exists)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> : slippery tile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">x: non-slippery tile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#: obstacles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">(You can&#39;t go past map edges, which serves as the walls of the puzzle.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><p>Your solver should find the optimal solution (minimal number of moves, as in, the amount of times you make a step), and return an array of directions: <code>'u', 'd', 'l', 'r'</code> for up/down/left/right respectively. So for the example map above, you should return <code>['u', 'r', 'd', 'l', 'u', 'r']</code>. If there are multiple solutions with the same amount of steps, tiebreak by least distance traversed. If there are still ties, just return any one of them.</p>
<p>Also, you might be passed some maps which does not admit any solutions. In this case, return <code>null</code>.</p>
<h1 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h1>
<p>The maze is read as a string, using graph hurts my brain as well as I&rsquo;m too lazy to transform it into matrix so, let it be.
<img loading="lazy" src="https://emoji.discadia.com/emojis/2d2851a4-4178-42ce-a0e7-facec874849a.png" alt="anya"  />
</p>
<p>As an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#e6db74">&#34;    x </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;  #   </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;   E  </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34; #    </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    # </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;S    #&#34;</span>
</span></span></code></pre></div><p>Consider this maze as a matrix, it&rsquo;s columns equal to <code>position of '\n' + 1</code> besides, this is a numbered matrix, starts from 0.</p>
<p>Conspicuously, if current cell is at position <code>i</code>, it&rsquo;s 4 adjacent cells would be:</p>
<ul>
<li>Upper cell:  <code>i - col</code></li>
<li>Lower cell:  <code>i + col</code></li>
<li>Left cell:   <code>i - 1</code></li>
<li>Right cecll: <code>i + 1</code></li>
</ul>
<p>Thus, a while loop is used to find a move&rsquo;s destination:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define UP    0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DOWN  1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LEFT  2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define RIGHT 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">next_tile</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>map, <span style="color:#66d9ef">int</span> col, <span style="color:#66d9ef">int</span> curr, <span style="color:#66d9ef">char</span> dir) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> (map.length() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> col;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (map[curr] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;E&#39;</span> <span style="color:#f92672">&amp;&amp;</span> is_valid(curr, dir, col, row)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (dir) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> UP:   next <span style="color:#f92672">=</span> curr <span style="color:#f92672">-</span> col; <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> DOWN: next <span style="color:#f92672">=</span> curr <span style="color:#f92672">+</span> col; <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> LEFT: next <span style="color:#f92672">=</span> curr <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;   <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>   next <span style="color:#f92672">=</span> curr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;   <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (map[next] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> curr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (map[next] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;x&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> next;
</span></span><span style="display:flex;"><span>        curr <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> curr;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>is_valid</code> function is responsible for ensuring the movement doesn&rsquo;t go out of the maze&rsquo;s walls</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_valid</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">char</span> dir, <span style="color:#66d9ef">int</span> col, <span style="color:#66d9ef">int</span> row) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (dir) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> UP:   <span style="color:#66d9ef">return</span> pos <span style="color:#f92672">&gt;=</span> col;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> DOWN: <span style="color:#66d9ef">return</span> pos <span style="color:#f92672">&lt;=</span> col <span style="color:#f92672">*</span> (row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> LEFT: <span style="color:#66d9ef">return</span> pos <span style="color:#f92672">%</span> col <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (pos <span style="color:#f92672">-</span> col <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">%</span> col <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The main algorithm for this kata is breadth first search (depth first search is possible, however, it can not take care of the bigger maze). When traverse a cell, calculate it&rsquo;s destinations (<code>next</code>) for each of 4 directions, then push them to queue. There are 2 case would occur: There is another path which leads to <code>next</code> and there is none.</p>
<p>If another path exists, <code>next</code> would not be pushed to queue but its path would be updated so that the solution is an optimal one. Init <code>precell</code> array to store cells&rsquo; previous cell, <code>-1</code> as default, to supports tracing back a path from <code>start</code> to any cell.</p>
<p>Moreover, pay attention to avoid adding start cell into queue, which causes infinite loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> ice_maze_solver(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>map) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> map.find(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, start <span style="color:#f92672">=</span> map.find(<span style="color:#e6db74">&#34;S&#34;</span>), end <span style="color:#f92672">=</span> map.find(<span style="color:#e6db74">&#34;E&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> solvable <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> solution;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> precell(map.length(), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> queue;
</span></span><span style="display:flex;"><span>    queue.push(start);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>queue.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> curr <span style="color:#f92672">=</span> queue.front();
</span></span><span style="display:flex;"><span>        queue.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(curr <span style="color:#f92672">==</span> end){
</span></span><span style="display:flex;"><span>            solvable <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> next <span style="color:#f92672">=</span> next_tile(map, col, curr, i);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">!=</span> curr <span style="color:#f92672">&amp;&amp;</span> next <span style="color:#f92672">!=</span> precell[curr]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(precell[next] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>                    update_path(precell, col, curr, next);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (next <span style="color:#f92672">!=</span> start){
</span></span><span style="display:flex;"><span>                    precell[next] <span style="color:#f92672">=</span> curr;
</span></span><span style="display:flex;"><span>                    queue.push(next);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (solvable){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (end <span style="color:#f92672">!=</span> start) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> move;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((precell[end] <span style="color:#f92672">-</span> end) <span style="color:#f92672">%</span> col <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                move <span style="color:#f92672">=</span> (precell[end] <span style="color:#f92672">&gt;</span> end) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;u&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;d&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                move <span style="color:#f92672">=</span> (precell[end] <span style="color:#f92672">&gt;</span> end) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;l&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;r&#39;</span>;
</span></span><span style="display:flex;"><span>            solution.insert(solution.begin(), move);
</span></span><span style="display:flex;"><span>            end <span style="color:#f92672">=</span> precell[end];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> solution;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The path is updated through 2 factors:</p>
<ol>
<li>Number of steps</li>
<li>Total path length, where:
<ul>
<li>The distance between 2 cells in the same horizontal row is $|i-j|$</li>
<li>If they&rsquo;re in the same vertical row: $\dfrac{|i-j|}{col}$</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> get_length(
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span>parent, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> col, <span style="color:#66d9ef">int</span> curr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> step   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (parent[curr] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        step<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        length <span style="color:#f92672">+=</span> abs(parent[curr] <span style="color:#f92672">-</span> curr) <span style="color:#f92672">/</span> ((parent[curr] <span style="color:#f92672">-</span> curr) <span style="color:#f92672">%</span> col <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> col : <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        curr <span style="color:#f92672">=</span> parent[curr];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {step, length};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_path</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>parent, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> col, <span style="color:#66d9ef">int</span> curr, <span style="color:#66d9ef">int</span> next) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> oldPath <span style="color:#f92672">=</span> get_length(parent, col, next);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> newPath <span style="color:#f92672">=</span> get_length(parent, col, curr);
</span></span><span style="display:flex;"><span>    newPath[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    newPath[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> abs(curr <span style="color:#f92672">-</span> next) <span style="color:#f92672">/</span> ((curr <span style="color:#f92672">-</span> next) <span style="color:#f92672">%</span> col <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> col : <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (newPath <span style="color:#f92672">&lt;</span> oldPath) {
</span></span><span style="display:flex;"><span>        parent[next] <span style="color:#f92672">=</span> curr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Thank you for reading this amateur solution, I did this kata just because it is related to pokemon series, nothing else.
<img loading="lazy" src="https://i.kym-cdn.com/entries/icons/original/000/031/926/Screenshot_25.jpg" alt="iyada"  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yurukute.github.io/Blog/en/tags/breadth-first-search/">Breadth first search</a></li>
      <li><a href="https://yurukute.github.io/Blog/en/tags/ascii-games/">ASCII Games</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://yurukute.github.io/Blog/en/post/addingbignumbers/">
    <span class="title">Older post »</span>
    <br>
    <span>Adding Big Numbers</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://yurukute.github.io/Blog/en/">Noob&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
