<!DOCTYPE html>
<html lang="vi" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Sum by Factors | Blog của Dung</title>

<meta name="keywords" content="codewars, eratosthene" />
<meta name="description" content="Bài toán: Nguồn: Codewars.com
Đọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,&hellip;, i_n]$
Output: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) &hellip; ($p_x$ $sum_m$)
Trong đó:
 $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:
I = {12, 15}; //kết quả: &quot;(2 12)(3 27)(5 15)&quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:">
<meta name="author" content="">
<link rel="canonical" href="https://yurukute.github.io/Blog/post/sumbyfactors/" />
<link href="/Blog/assets/css/stylesheet.min.d6b9f5b9a35628f539baeea5ef9a5a2774bbbe4a533799274b9dc35ea1691b4f.css" integrity="sha256-1rn1uaNWKPU5uu6l75paJ3S7vkpTN5knS53DXqFpG08=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://yurukute.github.io/Blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yurukute.github.io/Blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yurukute.github.io/Blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yurukute.github.io/Blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://yurukute.github.io/Blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<link rel="alternate" hreflang="en" href="https://yurukute.github.io/Blog/en/post/sumbyfactors/" />


<meta property="og:title" content="Sum by Factors" />
<meta property="og:description" content="Bài toán: Nguồn: Codewars.com
Đọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,&hellip;, i_n]$
Output: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) &hellip; ($p_x$ $sum_m$)
Trong đó:
 $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:
I = {12, 15}; //kết quả: &quot;(2 12)(3 27)(5 15)&quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yurukute.github.io/Blog/post/sumbyfactors/" />
<meta property="article:published_time" content="2021-01-18T16:50:30+07:00" />
<meta property="article:modified_time" content="2021-01-18T16:50:30+07:00" /><meta property="og:site_name" content="Blog của Dung" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Sum by Factors"/>
<meta name="twitter:description" content="Bài toán: Nguồn: Codewars.com
Đọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,&hellip;, i_n]$
Output: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) &hellip; ($p_x$ $sum_m$)
Trong đó:
 $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:
I = {12, 15}; //kết quả: &quot;(2 12)(3 27)(5 15)&quot; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sum by Factors",
  "name": "Sum by Factors",
  "description": "Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,\u0026amp;hellip;, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) \u0026amp;hellip; ($p_x$ …",
  "keywords": [
    "codewars", "eratosthene"
  ],
  "articleBody": "Bài toán: Nguồn: Codewars.com\nĐọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,…, i_n]$\nOutput: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) … ($p_x$ $sum_m$)\nTrong đó:\n $p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p  Ví dụ:\nI = {12, 15}; //kết quả: \"(2 12)(3 27)(5 15)\" Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:\n Nếu số $i_j$ chia hết cho $p$  $sum$ += $i_j$    Liệt kê các số nguyên tố Các liệt kê nhanh nhất là dùng sàng. Nhưng mà sàng đến bao nhiêu? Chính là sàng đến giá trị tuyệt đối lớn nhất trong số các phần tử của mảng I, gọi là max. Vì vậy, việc đầu tiến sau khi nhập mảng vào thì ta tìm max. Cách để sàng nguyên tố chắc ai cũng biết, không biết thì đây. Các số mình kiểm tra thì nhiều nhưng chỉ có vài trong số đó là số nguyên tố. Vì vậy, sau khi sàng xong, mình chỉ lưu lại những số nào là số nguyên tố thôi\nstd::vectorint sieve(int n){ std::vectorbool isprime(n+1, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i*i  n; i++) if(isprime[i]==1) for(int j = i*i; j  n; j += i) isprime[j]=0; std::vectorint res; for(int i = 0; i  n+1; i++) if(isprime[i]) res.push_back(i); return res; }; Bắt đầu xử lí for(auto i : primes){ ans += '('; int sum = 0; for(auto j : lst) if(j % i == 0) sum += j; if(sum) ans = ans + to_string(i) + ' ' + to_string(sum); else{ ans.pop_back(); continue; } ans += ')'; } Trong đoạn code trên, mình dùng một cái hàm to_string(). Đây là hàm mình tự viết. Bởi vì output ở dạng chuỗi nên mình cần phải chuyển p và sum về dạng chuỗi rồi gắn vào ans:\nstd::string to_string(int n){ std::string prefix = \"\", s = \"\"; //Lưu lại dấu \"-\" nếu n là số âm  if(n  0){ n *= -1; prefix = \"-\"; } while(n  0){ int x = n % 10; n /= 10; //Đây là phép tách số từ sau ra trước. Vì vậy các số tách ra sau cần phải thêm vào hàng đầu.  s.insert(s.begin(), x+48); } return prefix+s; }; Thế là xong! Ghép lại là có thể submit UwU.\nTái bút Thật ra cái code này còn naive lắm. Submit xong sẽ thấy ngay nhiều solution code ngắn và sáng tạo. Mình thì bám váo cấu trúc của kata, tức là không import thêm thư viện nào vào, vì vậy mới phải viết thêm hàm to_string(). Nếu không có hàm đó thì code sẽ ngắn lại đáng kể đấy!\n",
  "wordCount" : "469",
  "inLanguage": "vi",
  "datePublished": "2021-01-18T16:50:30+07:00",
  "dateModified": "2021-01-18T16:50:30+07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yurukute.github.io/Blog/post/sumbyfactors/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog của Dung",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yurukute.github.io/Blog/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yurukute.github.io/Blog/" accesskey="h" title="Blog của Dung (Alt + H)">Blog của Dung</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
                <span class="lang-switch">
                    <span>|</span>
                    <ul>
                        <li>
                            <a href="https://yurukute.github.io/Blog/en/" title="English"
                                aria-label="English">En</a>
                        </li>
                    </ul>
                </span>
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://yurukute.github.io/Blog/archive" title="Lưu trữ">
                    <span>Lưu trữ</span>
                </a>
            </li>
            <li>
                <a href="https://yurukute.github.io/Blog/search" title="Tìm kiếm">
                    <span>Tìm kiếm</span>
                </a>
            </li>
            <li>
                <a href="https://yurukute.github.io/Blog/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li></ul>
    </nav>
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Sum by Factors
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">January 18, 2021
&nbsp;|&nbsp;
      <ul class="i18n_list">Translations:
        <li>
          <a href="https://yurukute.github.io/Blog/en/post/sumbyfactors/">En</a>
        </li>
      </ul>
    </div>
  </header> 

  <div class="post-content">
<h2 id="bài-toán">Bài toán:<a hidden class="anchor" aria-hidden="true" href="#bài-toán">#</a></h2>
<p>Nguồn: <a href="https://www.codewars.com/kata/54d496788776e49e6b00052f">Codewars.com</a></p>
<h3 id="đọc-hiểu">Đọc hiểu:<a hidden class="anchor" aria-hidden="true" href="#đọc-hiểu">#</a></h3>
<p>Input: Một mảng các số nguyên: $I = [i_1, i_2 ,&hellip;, i_n]$</p>
<p>Output: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) &hellip; ($p_x$ $sum_m$)</p>
<p>Trong đó:</p>
<ul>
<li>$p$ : số nguyên tố</li>
<li>$sum$ : tổng các số trong mảng I chia hết cho p</li>
</ul>
<p>Ví dụ:</p>
<pre><code>I = {12, 15}; //kết quả: &quot;(2 12)(3 27)(5 15)&quot;
</code></pre><p>Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:</p>
<ul>
<li>Nếu số $i_j$ chia hết cho $p$
<ul>
<li>$sum$ += $i_j$</li>
</ul>
</li>
</ul>
<h2 id="liệt-kê-các-số-nguyên-tố">Liệt kê các số nguyên tố<a hidden class="anchor" aria-hidden="true" href="#liệt-kê-các-số-nguyên-tố">#</a></h2>
<p>Các liệt kê nhanh nhất là dùng sàng. Nhưng mà sàng đến bao nhiêu? Chính là sàng đến giá trị tuyệt đối lớn nhất trong số các phần tử của mảng I, gọi là <code>max</code>. Vì vậy, việc đầu tiến sau khi nhập mảng vào thì ta tìm <code>max</code>. Cách để sàng nguyên tố chắc ai cũng biết, không biết thì <a href="https://vnoi.info/wiki/translate/he/Number-Theory-2.md">đây</a>. Các số mình kiểm tra thì nhiều nhưng chỉ có vài trong số đó là số nguyên tố. Vì vậy, sau khi sàng xong, mình chỉ lưu lại những số nào là số nguyên tố thôi</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sieve(<span style="color:#66d9ef">int</span> n){
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> isprime(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
    isprime[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> isprime[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i<span style="color:#f92672">*</span>i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(isprime[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>)
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">*</span>i; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">+=</span> i)
                isprime[j]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(isprime[i])
            res.push_back(i);
    <span style="color:#66d9ef">return</span> res;
};
</code></pre></div><h2 id="bắt-đầu-xử-lí">Bắt đầu xử lí<a hidden class="anchor" aria-hidden="true" href="#bắt-đầu-xử-lí">#</a></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i : primes){
    ans <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;(&#39;</span>;
    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : lst)
        <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            sum <span style="color:#f92672">+=</span> j;
    <span style="color:#66d9ef">if</span>(sum)
        ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">+</span> to_string(i) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">+</span> to_string(sum);
    <span style="color:#66d9ef">else</span>{
        ans.pop_back();
        <span style="color:#66d9ef">continue</span>;
    }
    ans <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;)&#39;</span>;
}
</code></pre></div><p>Trong đoạn code trên, mình dùng một cái hàm <code>to_string()</code>. Đây là hàm mình tự viết. Bởi vì output ở dạng chuỗi nên mình cần phải chuyển <code>p</code> và <code>sum</code> về dạng chuỗi rồi gắn vào <code>ans</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">    std<span style="color:#f92672">::</span>string to_string(<span style="color:#66d9ef">int</span> n){
    std<span style="color:#f92672">::</span>string prefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>, s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">//Lưu lại dấu &#34;-&#34; nếu n là số âm
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
        n <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        prefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-&#34;</span>;
    }
    <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>){
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
        <span style="color:#75715e">//Đây là phép tách số từ sau ra trước. Vì vậy các số tách ra sau cần phải thêm vào hàng đầu.
</span><span style="color:#75715e"></span>        s.insert(s.begin(), x<span style="color:#f92672">+</span><span style="color:#ae81ff">48</span>); 
    }
    <span style="color:#66d9ef">return</span> prefix<span style="color:#f92672">+</span>s;
};
</code></pre></div><p>Thế là xong! Ghép lại là có thể submit UwU.</p>
<h2 id="tái-bút">Tái bút<a hidden class="anchor" aria-hidden="true" href="#tái-bút">#</a></h2>
<p>Thật ra cái code này còn naive lắm. Submit xong sẽ thấy ngay nhiều solution code ngắn và sáng tạo. Mình thì bám váo cấu trúc của kata, tức là không import thêm thư viện nào vào, vì vậy mới phải viết thêm hàm <code>to_string()</code>. Nếu không có hàm đó thì code sẽ ngắn lại đáng kể đấy!</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yurukute.github.io/Blog/tags/codewars/">Codewars</a></li>
      <li><a href="https://yurukute.github.io/Blog/tags/eratosthene/">eratosthene</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://yurukute.github.io/Blog/">Blog của Dung</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/Blog/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
