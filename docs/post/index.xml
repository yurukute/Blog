<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Blog của Noob</title>
    <link>https://yurukute.github.io/Blog/post/</link>
    <description>Recent content in Posts on Blog của Noob</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 18 Jan 2023 01:34:25 +0700</lastBuildDate><atom:link href="https://yurukute.github.io/Blog/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ASCII Games: Cảnh báo: Băng trơn!</title>
      <link>https://yurukute.github.io/Blog/post/ice/</link>
      <pubDate>Wed, 18 Jan 2023 01:34:25 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/ice/</guid>
      <description>Bài toán Source: Codewars Giới thiệu Bất cứ nhóc Joey nào cũng biết bức ảnh này nghĩa là gì và tại sao nó là một nỗi đau (về mặt tâm lý TvT):
Trong nhiều trò chơi giải đố ma trận 2D, có một loại điển hình được gọi là &amp;lsquo;ice puzzle&amp;rsquo;:
Bạn cần phải đi từ điểm A sang điểm B Bạn có thể di chuyển theo 1 trong 4 hướng trực giao Một vài ô sẽ có tính trơn: Nếu bạn bước vào ô trơn, bạn sẽ bị trượt trên hướng đang đi cho đến khi gặp một ô không trơn hoặc va chạm vào vật cản/tường.</description>
    </item>
    
    <item>
      <title>Cộng 2 số lớn</title>
      <link>https://yurukute.github.io/Blog/post/addingbignumbers/</link>
      <pubDate>Tue, 07 Jun 2022 20:43:34 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/addingbignumbers/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Viết chương trình trả về tổng của 2 số nguyên. Đầu vào là 2 số được biểu diễn dưới dạng chuỗi và kết quả trả về cũng lả chuỗi.
Ví dụ
add(&amp;#34;123&amp;#34;, &amp;#34;321&amp;#34;); -&amp;gt; &amp;#34;444&amp;#34; add(&amp;#34;11&amp;#34;, &amp;#34;99&amp;#34;); -&amp;gt; &amp;#34;110&amp;#34; Lời giải Trong số học, phép cộng có thể được thực hiện bằng cách sắp các số hạng theo chiều dọc và cộng lần lượt từng cột bắt đầu từ cột đơn vị (ngoài cùng bên phải).</description>
    </item>
    
    <item>
      <title>Thang máy</title>
      <link>https://yurukute.github.io/Blog/post/thelift/</link>
      <pubDate>Mon, 06 Jun 2022 00:45:02 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/thelift/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Một tòa nhà nhiều tầng có thang máy trong đó. Ở mỗi tầng có một hàng người chờ được di chuyển đến tầng họ muốn, được thể hiện bằng một số.
Nhiệm vụ: Đưa tất cả mọi người đến các tầng mà họ muốn đến trong khi tuân thủ các quy luật bên dưới.
TRƯỚC (Mọi người trong hàng đợi) SAU (Mọi người tại đích đến của họ) +--+ +--+ /----------------| |----------------\ /----------------| |----------------\ 10| | | 1,4,3,2 | 10| 10 | | | |----------------| |----------------| |----------------| |----------------| 9| | | 1,10,2 | 9| | | | |----------------| |----------------| |----------------| |----------------| 8| | | | 8| | | | |----------------| |----------------| |----------------| |----------------| 7| | | 3,6,4,5,6 | 7| | | | |----------------| |----------------| |----------------| |----------------| 6| | | | 6| 6,6,6 | | | |----------------| |----------------| |----------------| |----------------| 5| | | | 5| 5,5 | | | |----------------| |----------------| |----------------| |----------------| 4| | | 0,0,0 | 4| 4,4,4 | | | |----------------| |----------------| |----------------| |----------------| 3| | | | 3| 3,3 | | | |----------------| |----------------| |----------------| |----------------| 2| | | 4 | 2| 2,2,2 | | | |----------------| |----------------| |----------------| |----------------| 1| | | 6,5,2 | 1| 1,1 | | | |----------------| |----------------| |----------------| |----------------| G| | | | G| 0,0,0 | | | |====================================| |====================================| Trả về danh sách tất cả các tầng mà thang máy đã dừng lại (theo thứ tự dừng).</description>
    </item>
    
    <item>
      <title>Hamming Number</title>
      <link>https://yurukute.github.io/Blog/post/hammingnumber/</link>
      <pubDate>Mon, 23 May 2022 17:37:36 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/hammingnumber/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Số Hamming là một số dương có dạng $2^ỉ3^j5^k$ với $i, j, k$ là các số không âm.
Viết chương trình tính số Hamming nhỏ nhất thứ n.
Đặc biệt:
Số Hamming đầu tiên là $1 = 2^03^05^0$ Số Hamming thứ hai là $2 = 2^13^05^0$ Số Hamming thứ ba là $3 = 2^03^15^0$ Số Hamming thứ tư là $4 = 2^23^05^0$ Số Hamming thứ năm là $5 = 2^03^05^1$ 20 số Hamming nhỏ nhất đầu tiên được đưa vào trong test mẫu.</description>
    </item>
    
    <item>
      <title>Số phân số tối giản với mẫu số d</title>
      <link>https://yurukute.github.io/Blog/post/reducedfractions/</link>
      <pubDate>Wed, 08 Dec 2021 17:49:22 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/reducedfractions/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Với $n$ là tử số và $d$ là mẫu số, phân số được định nghĩa là tối giản nếu và chỉ nếu $GCD(n,d) = 1$.
Ví dụ, $\displaystyle\frac{5}{16}$ là phân số tối giản, trong khi $\displaystyle\frac{6}{16}$ không phải vì cả 6 và 16 đều chia hết cho 2 nên phân số rút gọn thành $\displaystyle\frac{3}{8}$
Cho một số $d$, hỏi có bao nhiêu phân số thực sự (phân số có tử bé hơn mẫu) tối giản nếu dùng $d$ làm mẫu số?</description>
    </item>
    
    <item>
      <title>Hàm Carmichael</title>
      <link>https://yurukute.github.io/Blog/post/carmichael/</link>
      <pubDate>Sat, 04 Sep 2021 05:23:34 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/carmichael/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Trong lý thuyết số, hàm Carmichael của một số nguyên dương $n$, ký hiệu $\lambda(n)$, là số nguyên dương m nhỏ nhất sao cho $a^m \equiv 1 \mod n$ với mọi $a \leq n$ là các số nguyên tố cùng nhau với n.
Ví dụ $n = 8$. Các số nguyên tố cùng nhau với $8$ không vượt quá $8: 1, 3, 5, 7.$ $$ \begin{aligned} 1^2 \equiv 1 \mod 8 \\ 3^2 \equiv 1 \mod 8 \\ 5^2 \equiv 1 \mod 8 \\ 7^2 \equiv 1 \mod 8 \\ \end{aligned} $$</description>
    </item>
    
    <item>
      <title>Tổng các khoảng</title>
      <link>https://yurukute.github.io/Blog/post/sumofintervals/</link>
      <pubDate>Tue, 27 Jul 2021 09:40:22 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/sumofintervals/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/
Ví dụ
sum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =&amp;gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =&amp;gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =&amp;gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau.</description>
    </item>
    
    <item>
      <title>Chuyển đổi số la mã</title>
      <link>https://yurukute.github.io/Blog/post/romannumeral/</link>
      <pubDate>Sun, 25 Jul 2021 18:51:05 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/romannumeral/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Cho lớp RomanNumerals để chuyển đổi các chữ số la mã về số nguyên và ngược lại.
#include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; class RomanHelper{ public: std::string to_roman(unsigned int n){ } int from_roman(std::string rn){ } } RomanNumerals; Việc chuyển đổi phải tuân theo nguyên tắc sau:
Chữ số La Mã hiện đại được viết bằng cách thể hiện từng chữ số riêng biệt bắt đầu bằng chữ số tận cùng bên trái và bỏ qua bất kỳ chữ số nào có giá trị bằng 0.</description>
    </item>
    
    <item>
      <title>Hai con mã</title>
      <link>https://yurukute.github.io/Blog/post/2knights/</link>
      <pubDate>Thu, 27 May 2021 18:13:29 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/2knights/</guid>
      <description>Bài toán Nguồn: CSES In ra tổng số cách đặt hai con mã lên bàn cờ $k \times k, k = 1,2,&amp;hellip;,n$ ($n$ nhập từ bàn phím) sao cho chúng không ăn nhau. Ví dụ:
Input: 8 Output: 0 6 28 96 252 550 1056 1848 Lời giải Ý tưởng Phương pháp đơn giản là ứng với mỗi vị trí của con mã thứ nhất, mình tìm các vị trí thích hợp cho con mã thứ hai rồi trả về tổng số vị trí tìm được.</description>
    </item>
    
    <item>
      <title>Dãy con tăng đơn điệu dài nhất</title>
      <link>https://yurukute.github.io/Blog/post/lis/</link>
      <pubDate>Tue, 09 Mar 2021 19:44:16 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/lis/</guid>
      <description>Bài toán Nguồn:
Tiếng Việt: Codeforces - Bản dễ Có thể giải với $O(n^2)$ Codeforces - Bản khó Cần giải bằng $O(n\log n)$ Tiếng Anh: Leetcode Cho một dãy số nguyên nums. Tìm độ dài của dãy con tăng đơn điệu dài nhất. Biết rằng dãy con tăng đơn điệu là 1 dãy $a_1,..,a_k$ thỏa mãn $$ \begin{align} &amp;amp;i_1 &amp;lt; i_2 &amp;lt; \dots &amp;lt; i_k,\\\ &amp;amp;nums[i_1] &amp;lt; nums[i_2] &amp;lt; \dots &amp;lt; nums[i_k] \end{align} $$ Ví dụ:</description>
    </item>
    
    <item>
      <title>Xâu con chung dài nhất</title>
      <link>https://yurukute.github.io/Blog/post/lcs/</link>
      <pubDate>Wed, 17 Feb 2021 20:36:47 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/lcs/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Theo Wikipedia :
Bài toán xâu con chung dài nhất là bài toán tìm một xâu có độ dài lớn nhất và là xâu con của mọi xâu trong một tập hợp các xâu. Khác với chuỗi con, các phần tử của xâu con không nhất thiết phải liên tiếp nhau.
Với 2 chuỗi được nhập vào, nhiệm vụ của bạn chính là tìm ra xâu con dài nhất của chúng.</description>
    </item>
    
    <item>
      <title>Tổng số cách phân tích n</title>
      <link>https://yurukute.github.io/Blog/post/explosivesum/</link>
      <pubDate>Mon, 15 Feb 2021 18:49:54 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/explosivesum/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?
Theo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số) Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:
Input: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω&amp;lt;)☆.</description>
    </item>
    
    <item>
      <title>Fibonacci</title>
      <link>https://yurukute.github.io/Blog/post/fibonacci/</link>
      <pubDate>Fri, 12 Feb 2021 04:39:42 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/fibonacci/</guid>
      <description>Bài toán Nguồn: Codeforces Đọc hiểu Tìm phần dư của số Fibonacci thứ $n$ ($n &amp;lt;= 10^{18}$) cho $10^9 + 7$. Như vậy, mình cần tìm $F_n$ trong dãy số được định nghĩa: $$
\begin{aligned} F_0 &amp;amp; = 0\\ F_1 &amp;amp; = 1\\ F_i &amp;amp; = F_{i-1} + F_{i-2} (i &amp;gt;= 2) \end{aligned} $$ Ví dụ:
Input: 50 Output: 586268941 Lời giải Cách 1: Quy hoạch động Xem phương trình sai phân của dãy fibonacci là công thức truy hồi, mình có thể viết thành đoạn code sau:</description>
    </item>
    
    <item>
      <title>Tổng số cách đổi xu</title>
      <link>https://yurukute.github.io/Blog/post/countchange/</link>
      <pubDate>Tue, 09 Feb 2021 13:12:26 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/countchange/</guid>
      <description>Bài toán Nguồn: Leetcode , Codewars Đọc hiểu: Bạn có một lượng đồng xu với các mệnh giá khác nhau và một tổng số tiền amount. Nhiệm vụ của bạn là tính xem có bao nhiêu cách khác nhau để đổi được số tiền với số xu đã cho. Số lượng xu không giới hạn.
Ví dụ:
Input: amount = 5, coins = {1,2,5} Output: 4 //{5, 2+2+1, 2+1+1+1, 1+1+1+1+1} Lời giải Với bài này mình sẽ lần lượt đi qua các giai đoạn của nó mà ở mỗi gia đoạn số xu của mình sẽ thay đổi dẫn đến sự thay đổi của kết quả bài toán.</description>
    </item>
    
    <item>
      <title>Số xu cần ít nhất để đổi một số tiền</title>
      <link>https://yurukute.github.io/Blog/post/coinchange/</link>
      <pubDate>Mon, 08 Feb 2021 15:29:10 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/coinchange/</guid>
      <description>Bài toán Nguồn: Leetcode Đọc hiểu Bạn có một lượng đồng xu có các mệnh giá khác nhau và tổng số tiền amount. Nhiệm vụ của bạn là tìm số xu ít cần ít nhất để tạo nên số tiền đó (không giới hạn số đồng xu). Nếu số tiền đó không thể tạo thành thì trả về -1.
Ví dụ:
Input: coins = {1,2,5}, amount = 11 Output: 3 //2 đồng 5 và 1 đồng 1 Input: coins = {2}, amount = 3 Output: -1 Lời giải Cách 1: Vét cạn bằng đệ qui Lấy ví dụ như trên, mình có amount là 11.</description>
    </item>
    
    <item>
      <title>Ứng dụng của các phép thao tác bit</title>
      <link>https://yurukute.github.io/Blog/post/bitwise/</link>
      <pubDate>Fri, 29 Jan 2021 20:52:26 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/bitwise/</guid>
      <description>Sơ lược Phép thao tác trên bit Kí hiệu Mô tả AND &amp;amp; Cả hai bit là 1, trả về 1. Ngược lại trả về 0. OR \ Một trong hai bit là 1, trả về 1. Ngược lại trả về 0. XOR ^ Hai bit khác nhau trả về 1. Ngược lại trả về 0. NOT ~ Đảo bit, 0 thành 1, 1 thành 0. Dịch trái - Shift left &amp;lt;&amp;lt; Dịch tất cả các bit sang trái.</description>
    </item>
    
    <item>
      <title>Phân tích thừa số nguyên tố của n!</title>
      <link>https://yurukute.github.io/Blog/post/factorialdecomp/</link>
      <pubDate>Tue, 26 Jan 2021 00:08:16 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/factorialdecomp/</guid>
      <description>Bài toán Nguồn: Codewars Cho một số $n$ được nhập vào, việc của tụi mình là phân tích giai thừa của nó ra thừa số nguyên tố. Ví dụ:
Input: n = 12 Output: 2^10 * 3^5 * 5^2 * 7 * 11 Có 1 lưu ý nho nhỏ là giá trị của $n$ có thể lên tới 4000, tất nhiên, 4000! sẽ trở thành 1 con số không hề nhỏ, nó có hơn 12000 chữ số lận á!</description>
    </item>
    
    <item>
      <title>Phân tích thừa số nguyên tố</title>
      <link>https://yurukute.github.io/Blog/post/primesinnumbers/</link>
      <pubDate>Sat, 23 Jan 2021 20:46:06 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/primesinnumbers/</guid>
      <description>Bài toán Nguồn: Codewars Đọc hiểu Cho một số dương $n$ &amp;gt; 1. Phân tích $n$ ra tích các số nguyên tố theo dạng:
($p_1$**$n_1$)($p_2$**$n_2$)&amp;hellip;($p_k$**$n_k$)
Trong đó: a**b nghĩa là $a^b$ $p_i$ liệt kê theo thứ tự tăng dần Nếu $n_i$ = 1 thì không ghi ra Ví dụ:
Input: n = 86240 Output: (2**5)(5)(7**2) Lời giải Để phân tích ra thừa số nguyên tố, mỉnh đem chia số đó cho ước nguyên tố nhỏ nhất của nó.</description>
    </item>
    
    <item>
      <title>T-Primes</title>
      <link>https://yurukute.github.io/Blog/post/t-primes/</link>
      <pubDate>Fri, 22 Jan 2021 15:08:53 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/t-primes/</guid>
      <description>Bài toán Nguồn: Codeforces Đọc hiểu Một số được gọi là t-prime nếu nó có đúng 3 ước số dương. Một số nguyên dương sẽ có 2 ước số là 1 và chính nó. Ngoài ra, nếu số đó, tạm gọi là $x$, có thêm 1 ước số nhỏ hơn $\sqrt{x}$ thì chắc chắn nó sẽ có ước khác. Để $x$ có đúng 3 ước số thì ước số nhỏ hơn $\sqrt{x}$ của nó phải là 1 số nguyên tố.</description>
    </item>
    
    <item>
      <title>Sum by Factors</title>
      <link>https://yurukute.github.io/Blog/post/sumbyfactors/</link>
      <pubDate>Mon, 18 Jan 2021 16:50:30 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/sumbyfactors/</guid>
      <description>Bài toán: Nguồn: Codewars.com Đọc hiểu: Input: Một mảng các số nguyên: $I = [i_1, i_2 ,&amp;hellip;, i_n]$
Output: một chuỗi theo dạng ($p_1$ $sum_1$) ($p_2$ $sum_2$) &amp;hellip; ($p_x$ $sum_m$)
Trong đó:
$p$ : số nguyên tố $sum$ : tổng các số trong mảng I chia hết cho p Ví dụ:
I = {12, 15}; //kết quả: &amp;#34;(2 12)(3 27)(5 15)&amp;#34; Như vậy, để giải được bài này ta cần tìm các số nguyên tố từ nhỏ đến lớn, ứng với mỗi số nguyên tố, ta có:</description>
    </item>
    
    <item>
      <title>Đoạn Con Có Tổng Lớn Nhất</title>
      <link>https://yurukute.github.io/Blog/post/maxsubarraysum/</link>
      <pubDate>Sun, 17 Jan 2021 20:45:26 +0700</pubDate>
      
      <guid>https://yurukute.github.io/Blog/post/maxsubarraysum/</guid>
      <description>Bài toán: Nguồn: Codewars.com Cho một dãy gồm n số nguyên $a_1, a_2,&amp;hellip;, a_n$. Hãy tìm một đoạn con (dãy gồm các phần tử liên tiếp nhau) có tổng lớn nhất.
Input: {-2, 1, -3, 4, -1, 2, 1, -5, 4} Output: 6 //vì đoạn con có tổng lớn nhất là {4, -1, 2, 1} Trường hợp đơn giản nhất là mảng chỉ có số dương, khi đó kết quả chính là tổng tất cả các số trong mảng.</description>
    </item>
    
  </channel>
</rss>
