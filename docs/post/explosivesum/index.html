<!DOCTYPE html>
<html lang="vi" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Tổng số cách phân tích n | Blog của Noob</title>

<meta name="keywords" content="Quy hoạch động" />
<meta name="description" content="Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?
Theo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số)  Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:
 Input: 4 Output: 5 //4, 3&#43;1, 2&#43;2, 2&#43;1&#43;1, 1&#43;1&#43;1&#43;1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω&lt;)☆.">
<meta name="author" content="">
<link rel="canonical" href="https://yurukute.github.io/Blog/post/explosivesum/" />
<link href="/Blog/assets/css/stylesheet.min.5601e01efed08baf0633c521dde519f4a73330d89816e94e954a68436d36e6bd.css" integrity="sha256-VgHgHv7Qi68GM8Uh3eUZ9KczMNiYFulOlUpoQ2025r0=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://yurukute.github.io/Blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yurukute.github.io/Blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yurukute.github.io/Blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yurukute.github.io/Blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://yurukute.github.io/Blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<link rel="alternate" hreflang="vi" href="https://yurukute.github.io/Blog/post/explosivesum/" />
<link rel="alternate" hreflang="en" href="https://yurukute.github.io/Blog/en/post/explosivesum/" />


<meta property="og:title" content="Tổng số cách phân tích n" />
<meta property="og:description" content="Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?
Theo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số)  Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:
 Input: 4 Output: 5 //4, 3&#43;1, 2&#43;2, 2&#43;1&#43;1, 1&#43;1&#43;1&#43;1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω&lt;)☆." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yurukute.github.io/Blog/post/explosivesum/" />
<meta property="article:published_time" content="2021-02-15T18:49:54+07:00" />
<meta property="article:modified_time" content="2021-02-15T18:49:54+07:00" /><meta property="og:site_name" content="Blog của Noob" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tổng số cách phân tích n"/>
<meta name="twitter:description" content="Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?
Theo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số)  Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:
 Input: 4 Output: 5 //4, 3&#43;1, 2&#43;2, 2&#43;1&#43;1, 1&#43;1&#43;1&#43;1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω&lt;)☆."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tổng số cách phân tích n",
  "name": "Tổng số cách phân tích n",
  "description": "Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?\nTheo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số)  Trong số học, sự phân …",
  "keywords": [
    "Quy hoạch động"
  ],
  "articleBody": "Bài toán Nguồn: Codewars Đọc hiểu Có bao nhiêu cách phân tích số n thành tổng các số?\nTheo wikipedia: https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số)  Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Ví dụ:\n Input: 4 Output: 5 //4, 3+1, 2+2, 2+1+1, 1+1+1+1 Lời giải Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (OωMình có bảng quy hoạch động (ways) sau:\n    0 1 2 3 4     0        1        2        3        4         Như vậy,ways[i][j] sẽ là số cách phân tích số $j$ thành tổng các số nguyên dương $\\leq i$. Cách phân tích số $j$ có thể chia làm hai loại\n  Không chứa số i\nBài toán lúc này trở thành số cách phân tích số $i$ thành tổng các số nguyên dương $, nói cách khác là $\\leq i - 1$\n  Chứa số i\nKhi đó, nếu bỏ đi $i$ mình sẽ được các cách phân tích số $j - i$\n  Rõ ràng, các cách phân tích chỉ có thể là loại 1 nếu $i  j$, ngược lại, số cách sẽ là tổng 2 loại trên. Vì thế: $$ways[i][j]= \\begin{cases} ways[i-1][j], \u0026 i  j \\\\\nways[i-1][j] + ways[i][j-i], \u0026 i \\leq j \\end{cases} $$\nĐể tính được ways[i][j] thì mình phải tính trướcways[i-1][j] và ways[i][j-i] nên ban đầu mình phải điền vào hàng 0, cơ sở của bảng. Vì số cách phân tích số 0 là 1 nên ways[0][0] = 1, còn lại tất cả sẽ là 0. Sau đó, dùng công thức truy hồi tìm tất cả các ô, lúc này ways[n][n] sẽ là kết quả mình cần tìm.\n#include using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vectorstd::vectorull ways(n+1, std::vectorull (n+1, 0)); ways[0][0] = 1; for(unsigned int i = 1; i  n; i++){ for(unsigned int j = i; j  n; j++){ ways[i][j] = ways[i-1][j]; if(i  j) ways[i][j] += ways[i][j-i]; } } return ways[n][n]; }     0 1 2 3 4     0 1 0 0 0 0   1 1 1 1 1 1   2 1 1 2 2 3   3 1 1 2 3 4   4 1 1 2 3 5    Cải tiến Có thể thấy, sau khi tính xong dòng thứ $n$ thì việc lưu trữ các dòng từ $1$ đến $n-1$ là dư thừa bởi vì việc tính dòng $n+1$ chỉ phụ thuộc vào dòng $n$. Nên mình sẽ dùng mảng 1 chiểu để lưu trữ và tự tính chính nó.\n#include using ull = unsigned long long; ull exp_sum(unsigned int n) { std::vectorull ways(n+1, 0); ways[0] = 1; for(unsigned int i = 1; i  n; i++){ for(unsigned int j = i; j  n; j++){ ways[j] += ways[j - i]; } } return ways[n]; }    0 1 2 3 4     1 1 2 3 5    Cảm ơn bạn vì đã đọc.\nBài viết liên quan Tổng số đổi đồng xu ",
  "wordCount" : "527",
  "inLanguage": "vi",
  "datePublished": "2021-02-15T18:49:54+07:00",
  "dateModified": "2021-02-15T18:49:54+07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yurukute.github.io/Blog/post/explosivesum/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog của Noob",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yurukute.github.io/Blog/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yurukute.github.io/Blog/" accesskey="h" title="Blog của Noob (Alt + H)">Blog của Noob</a>
            <span class="logo-switches">
                <a id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </a>
                
                

                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://yurukute.github.io/Blog/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://yurukute.github.io/Blog/archive" title="Lưu trữ">
                    <span>Lưu trữ</span>
                </a>
            </li>
            <li>
                <a href="https://yurukute.github.io/Blog/search" title="Tìm kiếm">
                    <span>Tìm kiếm</span>
                </a>
            </li>
            <li>
                <a href="https://yurukute.github.io/Blog/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li></ul>
    </nav>
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Tổng số cách phân tích n
    </h1>
    <div class="post-meta">February 15, 2021
&nbsp;|&nbsp;<ul class="i18n_list">Bản dịch:
        <li>
          <a href="https://yurukute.github.io/Blog/en/post/explosivesum/">En</a>
        </li>
      </ul>
    </div>
  </header> 

  <div class="post-content">
<h2 id="bài-toán">Bài toán<a hidden class="anchor" aria-hidden="true" href="#bài-toán">#</a></h2>
<p>Nguồn: <a href="https://www.codewars.com/kata/52ec24228a515e620b0005ef" target="_blank">Codewars</a>
</p>
<h3 id="đọc-hiểu">Đọc hiểu<a hidden class="anchor" aria-hidden="true" href="#đọc-hiểu">#</a></h3>
<p><strong>Có bao nhiêu cách phân tích số n thành tổng các số?</strong></p>
<p>Theo wikipedia:  <a href="https://vi.wikipedia.org/wiki/Ph%c3%a2n_ho%e1%ba%a1ch_%28l%c3%bd_thuy%e1%ba%bft_s%e1%bb%91%29" target="_blank">https://vi.wikipedia.org/wiki/Phân_hoạch_(lý_thuyết_số)</a>
</p>
<blockquote>
<p>Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích.
Ví dụ:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Input:  <span style="color:#ae81ff">4</span>
Output: <span style="color:#ae81ff">5</span> <span style="color:#75715e">//4, 3+1, 2+2, 2+1+1, 1+1+1+1
</span></code></pre></div><h2 id="lời-giải">Lời giải<a hidden class="anchor" aria-hidden="true" href="#lời-giải">#</a></h2>
<p>Bài toàn này có thể dùng phương pháp liệt kê để đếm nhưng mà như vậy rất là chậm khi $n$ là số lớn nên mình sẽ dùng quy hoạch động (Oω&lt;)☆.</p>
<p>Mình có bảng quy hoạch động (<code>ways</code>) sau:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Như vậy,<code>ways[i][j]</code> sẽ là <em>số cách phân tích số $j$ thành tổng các số nguyên dương $\leq i$</em>.
Cách phân tích số $j$ có thể chia làm hai loại</p>
<ul>
<li>
<p>Không chứa số i</p>
<p>Bài toán lúc này trở thành <em>số cách phân tích số $i$ thành tổng các số nguyên dương $&lt; i$</em>, nói cách khác là $\leq i - 1$</p>
</li>
<li>
<p>Chứa số i</p>
<p>Khi đó, nếu bỏ đi $i$ mình sẽ được các cách phân tích số $j - i$</p>
</li>
</ul>
<p>Rõ ràng, các cách phân tích chỉ có thể là loại 1 nếu $i &gt; j$, ngược lại, số cách sẽ là tổng 2 loại trên. Vì thế:
$$ways[i][j]=
\begin{cases}
ways[i-1][j],                   &amp; i &gt; j  \\<br>
ways[i-1][j] + ways[i][j-i],    &amp; i \leq j
\end{cases}
$$</p>
<p>Để tính được <code>ways[i][j]</code> thì mình phải tính trước<code>ways[i-1][j]</code> và <code>ways[i][j-i]</code> nên ban đầu mình phải điền vào hàng 0, cơ sở của bảng. Vì số cách phân tích số 0 là 1 nên <code>ways[0][0] = 1</code>, còn lại tất cả sẽ là 0. Sau đó, dùng công thức truy hồi tìm tất cả các ô, lúc này <code>ways[n][n]</code> sẽ là kết quả mình cần tìm.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> ull <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;

ull <span style="color:#a6e22e">exp_sum</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n) {
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>ull<span style="color:#f92672">&gt;&gt;</span> ways(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>ull<span style="color:#f92672">&gt;</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>));
    ways[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>){
            ways[i][j] <span style="color:#f92672">=</span> ways[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j];
            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;=</span> j)
                ways[i][j] <span style="color:#f92672">+=</span> ways[i][j<span style="color:#f92672">-</span>i];
        }
    }
    <span style="color:#66d9ef">return</span> ways[n][n];
}
</code></pre></div><table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td><strong>5</strong></td>
</tr>
</tbody>
</table>
<h3 id="cải-tiến">Cải tiến<a hidden class="anchor" aria-hidden="true" href="#cải-tiến">#</a></h3>
<p>Có thể thấy, sau khi tính xong dòng thứ $n$ thì việc lưu trữ các dòng từ $1$ đến $n-1$ là dư thừa bởi vì việc tính dòng $n+1$ chỉ phụ thuộc vào dòng $n$. Nên mình sẽ dùng mảng 1 chiểu để lưu trữ và tự tính chính nó.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> ull <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;

ull <span style="color:#a6e22e">exp_sum</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n) {
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>ull<span style="color:#f92672">&gt;</span> ways(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
    ways[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>){
            ways[j] <span style="color:#f92672">+=</span> ways[j <span style="color:#f92672">-</span> i];
        }
    }
    <span style="color:#66d9ef">return</span> ways[n];
}
</code></pre></div><table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td><strong>5</strong></td>
</tr>
</tbody>
</table>
<p>Cảm ơn bạn vì đã đọc.</p>
<h2 id="bài-viết-liên-quan">Bài viết liên quan<a hidden class="anchor" aria-hidden="true" href="#bài-viết-liên-quan">#</a></h2>
<p><a href="https://yurukute.github.io/Blog/post/countchange/">Tổng số đổi đồng xu</a>
</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yurukute.github.io/Blog/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/">Quy hoạch động</a></li>
    </ul>
    <nav class="paginav">
      <a class="prev" href="https://yurukute.github.io/Blog/post/fibonacci/">
        <span class="title">« Bài viết trước</span>
        <br>
        <span>Fibonacci</span>
      </a>
    </nav>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://yurukute.github.io/Blog/">Blog của Noob</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/Blog/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
