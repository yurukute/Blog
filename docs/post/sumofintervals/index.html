<!DOCTYPE html>
<html lang="vi" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Tổng các khoảng | Blog của Noob</title>
<meta name="keywords" content="Số học">
<meta name="description" content="Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/
Ví dụ
sum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =&gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =&gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =&gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau.">
<meta name="author" content="">
<link rel="canonical" href="https://yurukute.github.io/Blog/post/sumofintervals/">
<link crossorigin="anonymous" href="/Blog/assets/css/stylesheet.57c292ec064ba4167235f240fee0ce43ec98bb63c5fb0460293cca4fb4aaa7a1.css" integrity="sha256-V8KS7AZLpBZyNfJA/uDOQ&#43;yYu2PF&#43;wRgKTzKT7Sqp6E=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yurukute.github.io/Blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yurukute.github.io/Blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yurukute.github.io/Blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yurukute.github.io/Blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://yurukute.github.io/Blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="vi" href="https://yurukute.github.io/Blog/post/sumofintervals/">
<link rel="alternate" hreflang="en" href="https://yurukute.github.io/Blog/en/post/sumofintervals/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });

  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<meta property="og:title" content="Tổng các khoảng" />
<meta property="og:description" content="Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/
Ví dụ
sum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =&gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =&gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =&gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yurukute.github.io/Blog/post/sumofintervals/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-27T09:40:22+07:00" />
<meta property="article:modified_time" content="2021-07-27T09:40:22+07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tổng các khoảng"/>
<meta name="twitter:description" content="Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/
Ví dụ
sum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =&gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =&gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =&gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yurukute.github.io/Blog/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tổng các khoảng",
      "item": "https://yurukute.github.io/Blog/post/sumofintervals/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tổng các khoảng",
  "name": "Tổng các khoảng",
  "description": "Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/\nVí dụ\nsum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u0026gt; 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u0026gt; 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u0026gt; 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau.",
  "keywords": [
    "Số học"
  ],
  "articleBody": "Bài toán Nguồn: Codewars Đọc hiểu Viết hàm tên sumIntervals/sum_intervals() nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/\nVí dụ\nsum_intervals( { {1,2}, {6, 10}, {11, 15} } ); // =\u003e 9 sum_intervals( { {1,4}, {7, 10}, {3, 5} } ); // =\u003e 7 sum_intervals( { {1,5}, {10, 20}, {1, 6}, {16, 19}, {5, 11} } ); // =\u003e 19 Lời giải Để ý rằng, nếu một khoảng có thời điểm đầu nhỏ hơn thời điểm cuối của khoảng liền trước thì chúng đang lồng nhau. Có hai trường hợp như sau:\nĐầu khoảng này là đuôi khoảng kia. Ví dụ: [1, 4] và [3, 5] Thời điểm cuối của khoảng thứ hai lớn hơn thời điểm cuối của khoảng thứ nhất Khoảng sau khi gộp là: [1, 5] Khoảng này nằm hoàn toàn trong khoảng kia. Ví dụ: [1, 5] và [2, 4] Thời điểm cuối của khoảng thứ hai nhỏ hơn thời điểm cuối của khoảng thứ nhất Khoảng sau khi gộp là khoảng thứ nhất: [1, 5] Vậy, trước tiên mình cần sort intervals từ bé đến lớn theo các thời điểm đầu để không bỏ sót các khoảng lồng nhau nào, dẫn đến kết quả trả về cao hơn kỳ vọng. Dùng một mảng merged để lưu các khoảng sau khi gộp, với merged.back() đóng vai trò là khoảng liền trước khoảng đang xét. Lúc này, nếu khoảng đang xét có lồng với khoảng trước thì cập nhật thời điểm cuối của khoảng trước đó - merged.back() - cho phù hợp, nếu không thì thêm khoảng đang xét vào merged. Sau cùng chỉ cần cộng các khoảng đã gộp là xong.\n#include #include #include int sum_intervals(std::vector\u003cstd::pair\u003cint, int\u003e\u003e intervals) { int size = intervals.size(); std::sort(intervals.begin(), intervals.end()); std::vector\u003cstd::pair\u003cint,int\u003e\u003e merged = {{intervals[0].first, inttervals[0].second}}; for(int i = 1; i \u003c size; i++){ if(intervals[i].first \u003c= merged.back().second) //Lồng nhau: if (intervals[i].second \u003e= merged.back().second) // Trường hợp (1) merged.back().second = intervals.second; else continue; // Trường hợp (2) else merged.push_back(intervals[i]); // Không lồng nhau } int res = 0; for(const auto \u0026i : merged) res += i.second - i.first; return res; } Cải tiến Gọi x là thời điểm cuối của khoảng trước khoảng đang xét (tức là nó chứa giá trị của merged.back().second ở trên). Vẫn với hai trường hợp lồng nhau nhưng mình sẽ thay đổi thứ tự của các trường hợp khi xét:\nNếu thời điểm cuối của khoảng đang xét lớn hơn hoặc bằng x sẽ có 2 khả năng: Nếu thời điểm đầu của nó mà nhỏ hơn x thì nó đang bị lồng theo trường hợp (1) Nếu thời điểm đầu của nó mà lớn hơn x thì nó không có lồng nhau với khoảng trước nó. Dù là khả năng thứ nhất hay thứ hai thì giá trị của x sẽ cần được cập nhật thành thời điểm cuối của khoảng đang xét. Ngược lại, nếu nó nhỏ hơn x thì nó đang bị lồng theo trường hợp (2). Tức là có thể bỏ qua nó. Với phương pháp này mình chỉ sử dụng cấu trúc if một lần và không cần mảng merged khiến code trông gọn hơn.\n#include #include #include int sum_intervals(std::vector\u003cstd::pair\u003cint, int\u003e\u003e intervals) { std::sort(intervals.begin(), intervals.end()); int x = intervals[0].first, res = 0; for (auto \u0026i : intervals){ if (i.second \u003e= x){ res += i.second - (i.first \u003e x ? i.first : x); x = i.second; } } return res; } Cảm ơn bạn vì đã đọc.\n",
  "wordCount" : "619",
  "inLanguage": "vi",
  "datePublished": "2021-07-27T09:40:22+07:00",
  "dateModified": "2021-07-27T09:40:22+07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yurukute.github.io/Blog/post/sumofintervals/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog của Noob",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yurukute.github.io/Blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yurukute.github.io/Blog/" accesskey="h" title="Blog của Noob (Alt + H)">Blog của Noob</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://yurukute.github.io/Blog/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Tổng các khoảng
    </h1>
    <div class="post-meta"><span title='2021-07-27 09:40:22 +0700 +0700'>27 Tháng 7, 2021</span>&nbsp;|&nbsp;Bản dịch:
<ul class="i18n_list">
    <li>
        <a href="https://yurukute.github.io/Blog/en/post/sumofintervals/">En</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><h2 id="bài-toán">Bài toán<a hidden class="anchor" aria-hidden="true" href="#bài-toán">#</a></h2>
<p>Nguồn: <a href="https://www.codewars.com/kata/52b7ed099cdc285c300001cd" target="_blank">Codewars</a>
</p>
<h3 id="đọc-hiểu">Đọc hiểu<a hidden class="anchor" aria-hidden="true" href="#đọc-hiểu">#</a></h3>
<p>Viết hàm tên <code>sumIntervals</code>/<code>sum_intervals()</code> nhận vào 1 mảng các cặp số nguyên biểu thị thời điểm đầu và cuối của một khoảng. Nhiệm vụ của mình là tính tổng độ dài của các khoảng ấy. Các khoảng lồng nhau như [1, 4] với [3, 5] thì tính là [1, 5] luôn o.o)/</p>
<p>Ví dụ</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>sum_intervals( {
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">10</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">15</span>}
</span></span><span style="display:flex;"><span>} ); <span style="color:#75715e">// =&gt; 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>sum_intervals( {
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">10</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>} ); <span style="color:#75715e">// =&gt; 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>sum_intervals( {
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">19</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">11</span>}
</span></span><span style="display:flex;"><span>} ); <span style="color:#75715e">// =&gt; 19
</span></span></span></code></pre></div><h2 id="lời-giải">Lời giải<a hidden class="anchor" aria-hidden="true" href="#lời-giải">#</a></h2>
<p>Để ý rằng, nếu một khoảng có thời điểm đầu <strong>nhỏ hơn</strong> thời điểm cuối của khoảng liền trước thì chúng đang <strong>lồng nhau</strong>. Có hai trường hợp như sau:</p>
<ul>
<li>Đầu khoảng này là đuôi khoảng kia. Ví dụ: [1, 4] và [3, 5]
<ul>
<li>Thời điểm cuối của khoảng thứ hai <strong>lớn hơn</strong> thời điểm cuối của khoảng thứ nhất</li>
<li>Khoảng sau khi gộp là: [1, 5]</li>
</ul>
</li>
<li>Khoảng này nằm hoàn toàn trong khoảng kia. Ví dụ: [1, 5] và [2, 4]
<ul>
<li>Thời điểm cuối của khoảng thứ hai <strong>nhỏ hơn</strong> thời điểm cuối của khoảng thứ nhất</li>
<li>Khoảng sau khi gộp là khoảng thứ nhất: [1, 5]</li>
</ul>
</li>
</ul>
<p>Vậy, trước tiên mình cần sort <code>intervals</code> từ bé đến lớn theo các thời điểm đầu để không bỏ sót các khoảng lồng nhau nào, dẫn đến kết quả trả về cao hơn kỳ vọng. Dùng một mảng <code>merged</code> để lưu các khoảng sau khi gộp, với <code>merged.back()</code> đóng vai trò là khoảng liền trước khoảng đang xét. Lúc này, nếu khoảng đang xét có lồng với khoảng trước thì cập nhật thời điểm cuối của khoảng trước đó - <code>merged.back()</code> -  cho phù hợp, nếu không thì thêm khoảng đang xét vào <code>merged</code>. Sau cùng chỉ cần cộng các khoảng đã gộp là xong.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum_intervals</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> intervals) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> intervals.size();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(intervals.begin(), intervals.end());
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> merged <span style="color:#f92672">=</span> {{intervals[<span style="color:#ae81ff">0</span>].first, inttervals[<span style="color:#ae81ff">0</span>].second}};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(intervals[i].first <span style="color:#f92672">&lt;=</span> merged.back().second)      <span style="color:#75715e">//Lồng nhau:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (intervals[i].second <span style="color:#f92672">&gt;=</span> merged.back().second)    <span style="color:#75715e">// Trường hợp (1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                merged.back().second <span style="color:#f92672">=</span> intervals.second; 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">continue</span>;                                      <span style="color:#75715e">// Trường hợp (2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> merged.push_back(intervals[i]);                <span style="color:#75715e">// Không lồng nhau
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>i : merged)
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> i.second <span style="color:#f92672">-</span> i.first;   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="cải-tiến">Cải tiến<a hidden class="anchor" aria-hidden="true" href="#cải-tiến">#</a></h3>
<p>Gọi <code>x</code> là thời điểm cuối của khoảng trước khoảng đang xét (tức là nó chứa giá trị của <code>merged.back().second</code> ở trên). Vẫn với hai trường hợp lồng nhau nhưng mình sẽ thay đổi thứ tự của các trường hợp khi xét:</p>
<ul>
<li>Nếu thời điểm cuối của khoảng đang xét <strong>lớn hơn</strong> hoặc bằng x sẽ có 2 khả năng:
<ul>
<li>Nếu thời điểm đầu của nó mà <strong>nhỏ hơn</strong> x thì nó đang bị lồng theo <strong>trường hợp (1)</strong></li>
<li>Nếu thời điểm đầu của nó mà <strong>lớn hơn</strong> x thì nó <strong>không có lồng nhau</strong> với khoảng trước nó.</li>
<li>Dù là khả năng thứ nhất hay thứ hai thì giá trị của x sẽ cần được cập nhật thành thời điểm cuối của khoảng đang xét.</li>
</ul>
</li>
<li>Ngược lại, nếu nó <strong>nhỏ hơn</strong> x thì nó đang bị lồng theo <strong>trường hợp (2)</strong>. Tức là có thể bỏ qua nó.</li>
</ul>
<p>Với phương pháp này mình chỉ sử dụng cấu trúc <code>if</code> một lần và không cần mảng <code>merged</code> khiến code trông gọn hơn.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum_intervals</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> intervals) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(intervals.begin(), intervals.end());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> intervals[<span style="color:#ae81ff">0</span>].first, res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>i : intervals){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i.second <span style="color:#f92672">&gt;=</span> x){
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> i.second <span style="color:#f92672">-</span> (i.first <span style="color:#f92672">&gt;</span> x <span style="color:#f92672">?</span> i.first : x);
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> i.second;
</span></span><span style="display:flex;"><span>        }    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Cảm ơn bạn vì đã đọc.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yurukute.github.io/Blog/tags/s%E1%BB%91-h%E1%BB%8Dc/">Số học</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://yurukute.github.io/Blog/post/carmichael/">
    <span class="title">« Bài mới hơn</span>
    <br>
    <span>Hàm Carmichael</span>
  </a>
  <a class="next" href="https://yurukute.github.io/Blog/post/romannumeral/">
    <span class="title">Bài cũ hơn »</span>
    <br>
    <span>Chuyển đổi số la mã</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>© 2021 Noob</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
